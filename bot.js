// ===================================================
// ğŸš€ AI GOAL PREDICTOR ULTIMATE - VERSION 16.0 ENHANCED
// ğŸ‘¤ DEVELOPER: â™›ğ‘¨ğ’ğ’†ğ’†ğ’ ğ‘¨ğ’ğ’›ğ’˜ğ’‚ğ’‰ğ’Šâ™›
// ğŸ”¥ FEATURES: DUAL PAYMENT SYSTEM + BANK TRANSFER + BINANCE
// ğŸ’¾ ENHANCED PERSISTENT DATA STORAGE IN FIRESTORE - NO DATA LOSS ON UPDATES
// ğŸ¯ ENHANCED AI PREDICTION WITH RESULT TRACKING
// ğŸ” PREVENT DUPLICATE ACCOUNT NUMBERS
// ===================================================

console.log('ğŸ¤– Starting AI GOAL Predictor Ultimate v16.0 ENHANCED...');
console.log('ğŸ•’ ' + new Date().toISOString());

// ğŸ”§ CONFIGURATION - UPDATED FOR DUAL PAYMENT
const CONFIG = {
    BOT_TOKEN: process.env.BOT_TOKEN || "8125363786:AAFZaOGSAvq_p8Sc8cq2bIKZlpe4ej7tmdU",
    ADMIN_ID: process.env.ADMIN_ID || "6565594143",
    CHANNEL_ID: process.env.CHANNEL_ID || "-1003283663811",
    CHANNEL_USERNAME: process.env.CHANNEL_USERNAME || "@GEMZGOOL",
    
    // ğŸ†• ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ
    SUPPORT_USERNAME: process.env.SUPPORT_USERNAME || "@GEMZGOOLBOT",
    
    // ğŸ§  AI APIS
    AI_APIS: {
        GEMINI: process.env.GEMINI_API_KEY || "AIzaSyCtjtT98-M5v6t8qICPSDw-1TLwPneyaQc",
        OPENAI: process.env.OPENAI_API_KEY || "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"
    },

    // ğŸ’° DEFAULT PRICING - DUAL SYSTEM
    SUBSCRIPTION_PRICES: {
        binance: {
            week: 10,
            month: 30,
            three_months: 80,
            year: 250
        },
        bank: {
            week: 10,
            month: 30, 
            three_months: 80,
            year: 250
        }
    },

    // ğŸ” DEFAULT PAYMENT LINKS - DUAL SYSTEM
    PAYMENT_LINKS: {
        binance: {
            week: process.env.PAYMENT_WEEK || "https://binance.com/payment/weekly",
            month: process.env.PAYMENT_MONTH || "https://binance.com/payment/monthly", 
            three_months: process.env.PAYMENT_3MONTHS || "https://binance.com/payment/3months",
            year: process.env.PAYMENT_YEAR || "https://binance.com/payment/yearly"
        },
        bank: {
            week: {
                account: "1234567890",
                image: "https://i.ibb.co/default-bank-week.jpg",
                description: "ğŸ”¹ ØªØ­ÙˆÙŠÙ„ Ø¨Ù†ÙƒÙŠ - Ø¨Ø§Ù‚Ø© Ø£Ø³Ø¨ÙˆØ¹ÙŠØ©\nğŸ’³ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨: 1234567890\nğŸ¦ Ø§Ù„Ø¨Ù†Ùƒ: Ø§Ù„Ø¨Ù†Ùƒ Ø§Ù„ÙƒØ±ÙŠÙ…ÙŠ\nğŸ’° Ø§Ù„Ù…Ø¨Ù„Øº: 10$\nğŸ’µ Ø§Ù„Ø¹Ù…Ù„Ø©: Ø§Ù„Ø¯ÙˆÙ„Ø§Ø± Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠ\n\nğŸ“‹ Ø§Ù„Ø´Ø±ÙˆØ·:\nâ€¢ ÙŠØ¬Ø¨ Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø¨Ø§Ù„Ø¯ÙˆÙ„Ø§Ø± Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠ\nâ€¢ Ø¥Ø±ÙØ§Ù‚ ØµÙˆØ±Ø© Ø¥Ø«Ø¨Ø§Øª Ø§Ù„Ø¯ÙØ¹\nâ€¢ ÙƒØªØ§Ø¨Ø© Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ"
            },
            month: {
                account: "1234567890",
                image: "https://i.ibb.co/default-bank-month.jpg", 
                description: "ğŸ”¹ ØªØ­ÙˆÙŠÙ„ Ø¨Ù†ÙƒÙŠ - Ø¨Ø§Ù‚Ø© Ø´Ù‡Ø±ÙŠØ©\nğŸ’³ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨: 1234567890\nğŸ¦ Ø§Ù„Ø¨Ù†Ùƒ: Ø§Ù„Ø¨Ù†Ùƒ Ø§Ù„ÙƒØ±ÙŠÙ…ÙŠ\nğŸ’° Ø§Ù„Ù…Ø¨Ù„Øº: 30$\nğŸ’µ Ø§Ù„Ø¹Ù…Ù„Ø©: Ø§Ù„Ø¯ÙˆÙ„Ø§Ø± Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠ\n\nğŸ“‹ Ø§Ù„Ø´Ø±ÙˆØ·:\nâ€¢ ÙŠØ¬Ø¨ Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø¨Ø§Ù„Ø¯ÙˆÙ„Ø§Ø± Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠ\nâ€¢ Ø¥Ø±ÙØ§Ù‚ ØµÙˆØ±Ø© Ø¥Ø«Ø¨Ø§Øª Ø§Ù„Ø¯ÙØ¹\nâ€¢ ÙƒØªØ§Ø¨Ø© Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ"
            },
            three_months: {
                account: "1234567890",
                image: "https://i.ibb.co/default-bank-3months.jpg",
                description: "ğŸ”¹ ØªØ­ÙˆÙŠÙ„ Ø¨Ù†ÙƒÙŠ - Ø¨Ø§Ù‚Ø© 3 Ø£Ø´Ù‡Ø±\nğŸ’³ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨: 1234567890\nğŸ¦ Ø§Ù„Ø¨Ù†Ùƒ: Ø§Ù„Ø¨Ù†Ùƒ Ø§Ù„ÙƒØ±ÙŠÙ…ÙŠ\nğŸ’° Ø§Ù„Ù…Ø¨Ù„Øº: 80$\nğŸ’µ Ø§Ù„Ø¹Ù…Ù„Ø©: Ø§Ù„Ø¯ÙˆÙ„Ø§Ø± Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠ\n\nğŸ“‹ Ø§Ù„Ø´Ø±ÙˆØ·:\nâ€¢ ÙŠØ¬Ø¨ Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø¨Ø§Ù„Ø¯ÙˆÙ„Ø§Ø± Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠ\nâ€¢ Ø¥Ø±ÙØ§Ù‚ ØµÙˆØ±Ø© Ø¥Ø«Ø¨Ø§Øª Ø§Ù„Ø¯ÙØ¹\nâ€¢ ÙƒØªØ§Ø¨Ø© Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ"
            },
            year: {
                account: "1234567890",
                image: "https://i.ibb.co/default-bank-year.jpg",
                description: "ğŸ”¹ ØªØ­ÙˆÙŠÙ„ Ø¨Ù†ÙƒÙŠ - Ø¨Ø§Ù‚Ø© Ø³Ù†ÙˆÙŠØ©\nğŸ’³ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨: 1234567890\nğŸ¦ Ø§Ù„Ø¨Ù†Ùƒ: Ø§Ù„Ø¨Ù†Ùƒ Ø§Ù„ÙƒØ±ÙŠÙ…ÙŠ\nğŸ’° Ø§Ù„Ù…Ø¨Ù„Øº: 250$\nğŸ’µ Ø§Ù„Ø¹Ù…Ù„Ø©: Ø§Ù„Ø¯ÙˆÙ„Ø§Ø± Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠ\n\nğŸ“‹ Ø§Ù„Ø´Ø±ÙˆØ·:\nâ€¢ ÙŠØ¬Ø¨ Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø¨Ø§Ù„Ø¯ÙˆÙ„Ø§Ø± Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠ\nâ€¢ Ø¥Ø±ÙØ§Ù‚ ØµÙˆØ±Ø© Ø¥Ø«Ø¨Ø§Øª Ø§Ù„Ø¯ÙØ¹\nâ€¢ ÙƒØªØ§Ø¨Ø© Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ"
            }
        }
    },
    
    VERSION: "16.0.0",
    DEVELOPER: "â™›ğ‘¨ğ’ğ’†ğ’†ğ’ ğ‘¨ğ’ğ’›ğ’˜ğ’‚ğ’‰ğ’Šâ™›",
    CHANNEL: "@GEMZGOOL",
    START_IMAGE: "https://i.ibb.co/tpy70Bd1/IMG-20251104-074214-065.jpg",
    ANALYSIS_IMAGE: "https://i.ibb.co/VYjf05S0/Screenshot.png",
    PREDICTION_IMAGE: "https://i.ibb.co/rGTZm2mB/IMG.jpg",
    IMGBB_API_KEY: process.env.IMGBB_API_KEY || "42b155a527bee21e62e524a31fe9b1ee"
};

console.log('âœ… Enhanced Configuration loaded successfully');

// ğŸš€ INITIALIZE BOT
const { Telegraf, Markup, session } = require('telegraf');
const axios = require('axios');
const express = require('express');

const bot = new Telegraf(CONFIG.BOT_TOKEN);

// ğŸŒ HEALTH CHECK SERVER FOR RENDER
const app = express();
const PORT = process.env.PORT || 3000;

app.use(express.json());

app.get('/', (req, res) => {
    res.json({ 
        status: 'OK', 
        version: CONFIG.VERSION,
        timestamp: new Date().toISOString(),
        message: 'AI Goal Predictor Bot is running...',
        developer: CONFIG.DEVELOPER
    });
});

// ğŸ”„ KEEP ALIVE ENDPOINT FOR RENDER
app.get('/keep-alive', (req, res) => {
    res.json({ 
        status: 'ALIVE', 
        timestamp: new Date().toISOString(),
        message: 'Bot is alive and running'
    });
});

app.listen(PORT, () => {
    console.log(`ğŸŒ Health check server running on port ${PORT}`);
    console.log(`ğŸ”„ Keep alive endpoint: http://localhost:${PORT}/keep-alive`);
});

// ğŸ”¥ ENHANCED FIREBASE INITIALIZATION
const { admin, db, rtdb } = require('./firebase-config');

// ğŸ’¾ ENHANCED FIRESTORE STORAGE MANAGER - COMPLETE PERSISTENCE
class FirestoreStorage {
    constructor() {
        this.initialized = true; // Firebase is already initialized
    }

    async getUser(userId) {
        try {
            const userDoc = await db.collection('users').doc(userId.toString()).get();
            if (userDoc.exists) {
                console.log(`âœ… User ${userId} loaded from Firestore`);
                return userDoc.data();
            }
            console.log(`âŒ User ${userId} not found in Firestore`);
            return null;
        } catch (error) {
            console.error('Get user error:', error);
            return null;
        }
    }

    async saveUser(userId, userData) {
        try {
            const completeUserData = {
                user_id: userId,
                username: userData.username || 'Unknown',
                onexbet: userData.onexbet || '',
                country: userData.country || '',
                free_attempts: userData.free_attempts || 0,
                subscription_status: userData.subscription_status || 'free',
                subscription_type: userData.subscription_type || 'none',
                subscription_start_date: userData.subscription_start_date || null,
                subscription_end_date: userData.subscription_end_date || null,
                joined_at: userData.joined_at || new Date().toISOString(),
                total_predictions: userData.total_predictions || 0,
                correct_predictions: userData.correct_predictions || 0,
                wins: userData.wins || 0,
                losses: userData.losses || 0,
                total_bets: userData.total_bets || 0,
                total_profit: userData.total_profit || 0,
                last_updated: new Date().toISOString(),
                channel_subscribed: userData.channel_subscribed || false,
                prediction_history: userData.prediction_history || [],
                result_history: userData.result_history || []
            };

            await db.collection('users').doc(userId.toString()).set(completeUserData, { merge: true });
            console.log(`âœ… User ${userId} saved to Firestore`);
            return true;
            
        } catch (error) {
            console.error('Save user error:', error);
            return false;
        }
    }

    async getSettings() {
        try {
            const settingsDoc = await db.collection('settings').doc('config').get();
            if (settingsDoc.exists) {
                return settingsDoc.data();
            }
            
            // Create default settings if not exists
            const defaultSettings = {
                prices: { 
                    binance: { ...CONFIG.SUBSCRIPTION_PRICES.binance },
                    bank: { ...CONFIG.SUBSCRIPTION_PRICES.bank }
                },
                payment_links: { 
                    binance: { ...CONFIG.PAYMENT_LINKS.binance },
                    bank: { ...CONFIG.PAYMENT_LINKS.bank }
                },
                maintenance_mode: false,
                updated_at: new Date().toISOString()
            };
            
            await db.collection('settings').doc('config').set(defaultSettings);
            return defaultSettings;
            
        } catch (error) {
            console.error('Get settings error:', error);
            return {
                prices: { 
                    binance: { ...CONFIG.SUBSCRIPTION_PRICES.binance },
                    bank: { ...CONFIG.SUBSCRIPTION_PRICES.bank }
                },
                payment_links: { 
                    binance: { ...CONFIG.PAYMENT_LINKS.binance },
                    bank: { ...CONFIG.PAYMENT_LINKS.bank }
                },
                maintenance_mode: false,
                updated_at: new Date().toISOString()
            };
        }
    }

    async updateSettings(newSettings) {
        try {
            const updatedSettings = {
                ...newSettings,
                updated_at: new Date().toISOString()
            };

            await db.collection('settings').doc('config').set(updatedSettings, { merge: true });
            return updatedSettings;
            
        } catch (error) {
            console.error('Update settings error:', error);
            return newSettings;
        }
    }

    async getAllUsers() {
        try {
            const usersSnapshot = await db.collection('users').get();
            const users = usersSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            console.log(`âœ… Loaded ${users.length} users from Firestore`);
            return users;
            
        } catch (error) {
            console.error('Get all users error:', error);
            return [];
        }
    }

    async addPayment(paymentData) {
        try {
            const paymentId = Date.now().toString();
            const fullPaymentData = {
                ...paymentData,
                id: paymentId,
                status: 'pending',
                timestamp: new Date().toISOString()
            };

            await db.collection('payments').doc(paymentId).set(fullPaymentData);
            console.log(`âœ… Payment ${paymentId} saved to Firestore`);
            return paymentId;
            
        } catch (error) {
            console.error('Add payment error:', error);
            return Date.now().toString();
        }
    }

    async updatePayment(paymentId, updates) {
        try {
            await db.collection('payments').doc(paymentId).update(updates);
            console.log(`âœ… Payment ${paymentId} updated in Firestore`);
            return true;
            
        } catch (error) {
            console.error('Update payment error:', error);
            return false;
        }
    }

    async getPayment(paymentId) {
        try {
            const paymentDoc = await db.collection('payments').doc(paymentId).get();
            if (paymentDoc.exists) {
                return paymentDoc.data();
            }
            return null;
            
        } catch (error) {
            console.error('Get payment error:', error);
            return null;
        }
    }

    async getAllPayments() {
        try {
            const paymentsSnapshot = await db.collection('payments').get();
            return paymentsSnapshot.docs.map(doc => doc.data());
            
        } catch (error) {
            console.error('Get all payments error:', error);
            return [];
        }
    }

    async getPendingPayments() {
        try {
            const payments = await this.getAllPayments();
            return payments.filter(p => p.status === 'pending');
        } catch (error) {
            console.error('Get pending payments error:', error);
            return [];
        }
    }

    async getUserByOneXBet(onexbet) {
        try {
            const usersSnapshot = await db.collection('users').where('onexbet', '==', onexbet).get();
            if (!usersSnapshot.empty) {
                return usersSnapshot.docs[0].data();
            }
            return null;
            
        } catch (error) {
            console.error('Get user by onexbet error:', error);
            return null;
        }
    }

    async searchUsers(query) {
        try {
            const users = await this.getAllUsers();
            const lowerQuery = query.toLowerCase();
            
            return users.filter(user => 
                (user.user_id && user.user_id.toString().includes(query)) ||
                (user.username && user.username.toLowerCase().includes(lowerQuery)) ||
                (user.onexbet && user.onexbet.toString().includes(query))
            );
        } catch (error) {
            console.error('Search users error:', error);
            return [];
        }
    }

    async setChannelSubscription(userId, subscribed) {
        try {
            const user = await this.getUser(userId);
            if (user) {
                user.channel_subscribed = subscribed;
                await this.saveUser(userId, user);
            }
            return true;
        } catch (error) {
            console.error('Set channel subscription error:', error);
            return false;
        }
    }

    async getAllStats() {
        try {
            const users = await this.getAllUsers();
            const payments = await this.getAllPayments();
            
            const activeUsers = users.filter(u => u.subscription_status === 'active');
            const freeUsers = users.filter(u => u.subscription_status === 'free');
            
            const totalPredictions = users.reduce((sum, user) => sum + (user.total_predictions || 0), 0);
            const totalProfit = users.reduce((sum, user) => sum + (user.total_profit || 0), 0);
            const totalBets = users.reduce((sum, user) => sum + (user.total_bets || 0), 0);
            
            return {
                totalUsers: users.length,
                activeUsers: activeUsers.length,
                freeUsers: freeUsers.length,
                totalPredictions,
                totalProfit,
                totalBets,
                totalPayments: payments.length,
                pendingPayments: payments.filter(p => p.status === 'pending').length
            };
        } catch (error) {
            console.error('Get all stats error:', error);
            return {
                totalUsers: 0,
                activeUsers: 0,
                freeUsers: 0,
                totalPredictions: 0,
                totalProfit: 0,
                totalBets: 0,
                totalPayments: 0,
                pendingPayments: 0
            };
        }
    }

    async addPredictionToHistory(userId, prediction) {
        try {
            const user = await this.getUser(userId);
            if (user) {
                if (!user.prediction_history) {
                    user.prediction_history = [];
                }
                
                user.prediction_history.push({
                    type: prediction.type,
                    probability: prediction.probability,
                    reasoning: prediction.reasoning,
                    timestamp: new Date().toISOString(),
                    bet_amount: prediction.bet_amount || 0
                });
                
                if (user.prediction_history.length > 20) {
                    user.prediction_history = user.prediction_history.slice(-20);
                }
                
                await this.saveUser(userId, user);
                return true;
            }
            return false;
        } catch (error) {
            console.error('Add prediction to history error:', error);
            return false;
        }
    }

    async addResultToHistory(userId, result) {
        try {
            const user = await this.getUser(userId);
            if (user) {
                if (!user.result_history) {
                    user.result_history = [];
                }
                
                user.result_history.push({
                    type: result.type,
                    outcome: result.outcome,
                    bet_amount: result.bet_amount,
                    profit: result.profit || 0,
                    timestamp: new Date().toISOString()
                });
                
                if (user.result_history.length > 50) {
                    user.result_history = user.result_history.slice(-50);
                }
                
                await this.saveUser(userId, user);
                return true;
            }
            return false;
        } catch (error) {
            console.error('Add result to history error:', error);
            return false;
        }
    }

    async getRecentResultsStats(userId, count = 10) {
        try {
            const user = await this.getUser(userId);
            if (user && user.result_history && user.result_history.length > 0) {
                const recentResults = user.result_history.slice(-count);
                const wins = recentResults.filter(r => r.outcome === 'win').length;
                const losses = recentResults.filter(r => r.outcome === 'lose').length;
                const winRate = recentResults.length > 0 ? (wins / recentResults.length) * 100 : 0;
                
                return {
                    total: recentResults.length,
                    wins: wins,
                    losses: losses,
                    winRate: Math.round(winRate),
                    recentResults: recentResults
                };
            }
            return {
                total: 0,
                wins: 0,
                losses: 0,
                winRate: 0,
                recentResults: []
            };
        } catch (error) {
            console.error('Get recent results stats error:', error);
            return {
                total: 0,
                wins: 0,
                losses: 0,
                winRate: 0,
                recentResults: []
            };
        }
    }

    async saveSession(userId, sessionData) {
        try {
            const sessionDoc = {
                user_id: userId,
                session_data: sessionData,
                last_updated: new Date().toISOString(),
                expires_at: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days
            };

            await db.collection('sessions').doc(userId.toString()).set(sessionDoc, { merge: true });
            console.log(`âœ… Session saved for user ${userId}`);
            return true;
            
        } catch (error) {
            console.error('Save session error:', error);
            return false;
        }
    }

    async getSession(userId) {
        try {
            const sessionDoc = await db.collection('sessions').doc(userId.toString()).get();
            if (sessionDoc.exists) {
                const sessionData = sessionDoc.data();
                // Check if session is expired
                if (new Date(sessionData.expires_at) > new Date()) {
                    console.log(`âœ… Session loaded for user ${userId}`);
                    return sessionData.session_data;
                } else {
                    // Delete expired session
                    await db.collection('sessions').doc(userId.toString()).delete();
                    console.log(`ğŸ—‘ï¸ Expired session deleted for user ${userId}`);
                }
            }
            return null;
            
        } catch (error) {
            console.error('Get session error:', error);
            return null;
        }
    }

    async deleteSession(userId) {
        try {
            await db.collection('sessions').doc(userId.toString()).delete();
            console.log(`ğŸ—‘ï¸ Session deleted for user ${userId}`);
            return true;
            
        } catch (error) {
            console.error('Delete session error:', error);
            return false;
        }
    }
}

// INITIALIZE FIRESTORE STORAGE
const firestoreStorage = new FirestoreStorage();

// ğŸ’¾ ENHANCED DATABASE MANAGER - COMPLETE PERSISTENCE
class EnhancedDatabaseManager {
    constructor() {
        this.maintenanceMode = false;
        this.storage = firestoreStorage;
    }

    async getUser(userId) {
        return await this.storage.getUser(userId);
    }

    async saveUser(userId, userData) {
        return await this.storage.saveUser(userId, userData);
    }

    async getSettings() {
        return await this.storage.getSettings();
    }

    async updateSettings(newSettings) {
        return await this.storage.updateSettings(newSettings);
    }

    async getAllUsers() {
        return await this.storage.getAllUsers();
    }

    async addPayment(paymentData) {
        return await this.storage.addPayment(paymentData);
    }

    async updatePayment(paymentId, updates) {
        return await this.storage.updatePayment(paymentId, updates);
    }

    async getPayment(paymentId) {
        return await this.storage.getPayment(paymentId);
    }

    async getAllPayments() {
        return await this.storage.getAllPayments();
    }

    async getPendingPayments() {
        return await this.storage.getPendingPayments();
    }

    async getUserByOneXBet(onexbet) {
        return await this.storage.getUserByOneXBet(onexbet);
    }

    isMaintenanceMode() {
        return this.maintenanceMode;
    }

    async setMaintenanceMode(enabled) {
        try {
            const settings = await this.getSettings();
            settings.maintenance_mode = enabled;
            await this.updateSettings(settings);
            this.maintenanceMode = enabled;
            return true;
        } catch (error) {
            this.maintenanceMode = enabled;
            return true;
        }
    }

    async searchUsers(query) {
        return await this.storage.searchUsers(query);
    }

    async backupData() {
        try {
            const backupData = {
                users: await this.getAllUsers(),
                payments: await this.getAllPayments(),
                settings: await this.getSettings(),
                timestamp: new Date().toISOString()
            };
            
            await db.collection('backups').doc(Date.now().toString()).set(backupData);
            
            return backupData;
        } catch (error) {
            console.error('Backup error:', error);
            return null;
        }
    }

    async setChannelSubscription(userId, subscribed) {
        return await this.storage.setChannelSubscription(userId, subscribed);
    }

    async getAllStats() {
        return await this.storage.getAllStats();
    }

    async addPredictionToHistory(userId, prediction) {
        return await this.storage.addPredictionToHistory(userId, prediction);
    }

    async addResultToHistory(userId, result) {
        return await this.storage.addResultToHistory(userId, result);
    }

    async getRecentResultsStats(userId, count = 10) {
        return await this.storage.getRecentResultsStats(userId, count);
    }

    async saveSession(userId, sessionData) {
        return await this.storage.saveSession(userId, sessionData);
    }

    async getSession(userId) {
        return await this.storage.getSession(userId);
    }

    async deleteSession(userId) {
        return await this.storage.deleteSession(userId);
    }
}

// INITIALIZE ENHANCED DATABASE MANAGER
const dbManager = new EnhancedDatabaseManager();

// ğŸ“Š DYNAMIC STATISTICS SYSTEM
class DynamicStatistics {
    constructor() {
        this.totalUsers = 78542;
        this.activeUsers = 300;
        this.lastCallTime = Date.now();
        this.callCount = 0;
    }

    getStats() {
        const now = Date.now();
        
        this.callCount++;
        
        const randomIncrement = Math.floor(Math.random() * 5) + 1;
        this.activeUsers += randomIncrement;
        
        if (this.activeUsers > 5000) {
            this.activeUsers = 300;
        }
        
        this.lastCallTime = now;

        return {
            totalUsers: this.totalUsers,
            activeUsers: this.activeUsers
        };
    }
}

// ğŸ§  SMART GOAL PREDICTION ENGINE - ENHANCED WITH AI
class GoalPredictionAI {
    constructor() {
        this.algorithmVersion = "16.0";
        this.predictionPatterns = new Map();
    }

    analyzePreviousResults(userId, userData) {
        try {
            if (!userData.result_history || userData.result_history.length === 0) {
                return null;
            }

            const recentResults = userData.result_history.slice(-10);
            const wins = recentResults.filter(r => r.outcome === 'win').length;
            const losses = recentResults.filter(r => r.outcome === 'lose').length;
            
            if (losses > wins) {
                const lastThree = recentResults.slice(-3);
                const allLosses = lastThree.every(r => r.outcome === 'lose');
                
                if (allLosses) {
                    return {
                        bias: 'goal',
                        confidence: 85,
                        reasoning: 'ğŸ”„ ØªØµØ­ÙŠØ­ Ø§Ù„Ù†Ù…Ø· Ø¨Ø¹Ø¯ Ø³Ù„Ø³Ù„Ø© Ø®Ø³Ø§Ø¦Ø±'
                    };
                }
            }

            const goalPredictions = recentResults.filter(r => r.type === 'âš½ GOAL').length;
            const noGoalPredictions = recentResults.filter(r => r.type === 'ğŸ›‘ NO GOAL').length;
            
            if (goalPredictions > noGoalPredictions * 1.5) {
                return {
                    bias: 'no_goal',
                    confidence: 75,
                    reasoning: 'ğŸ“Š ØªÙˆØ§Ø²Ù† Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø¨Ø¹Ø¯ ØªØ±ÙƒÙŠØ² Ø¹Ù„Ù‰ Ø§Ù„ØªÙˆÙ‚Ø¹Ø§Øª Ø§Ù„Ù‡Ø¬ÙˆÙ…ÙŠØ©'
                };
            } else if (noGoalPredictions > goalPredictions * 1.5) {
                return {
                    bias: 'goal',
                    confidence: 75,
                    reasoning: 'ğŸ“Š ØªÙˆØ§Ø²Ù† Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø¨Ø¹Ø¯ ØªØ±ÙƒÙŠØ² Ø¹Ù„Ù‰ Ø§Ù„ØªÙˆÙ‚Ø¹Ø§Øª Ø§Ù„Ø¯ÙØ§Ø¹ÙŠØ©'
                };
            }

            return null;
        } catch (error) {
            console.error('Error analyzing previous results:', error);
            return null;
        }
    }

    generateSmartPrediction(userId, userData, betAmount = 0) {
        const analysis = this.analyzePreviousResults(userId, userData);
        
        let isGoal;
        let probability;
        let reasoning;

        if (analysis) {
            isGoal = analysis.bias === 'goal';
            probability = analysis.confidence;
            reasoning = analysis.reasoning;
        } else {
            isGoal = Math.random() > 0.5;
            probability = Math.floor(Math.random() * 30) + 60;
            
            if (isGoal) {
                reasoning = `ğŸ”¥ Ø§Ù„Ø¶ØºØ· Ø§Ù„Ù‡Ø¬ÙˆÙ…ÙŠ Ø§Ù„Ù…Ø³ØªÙ…Ø± ÙŠØ´ÙŠØ± Ù„Ù‡Ø¯Ù Ù‚Ø±ÙŠØ¨ Ø¨Ù†Ø³Ø¨Ø© ${probability}%`;
            } else {
                reasoning = `ğŸ›‘ Ø§Ù„Ø¯ÙØ§Ø¹ Ø§Ù„Ù…Ù†Ø¸Ù… ÙŠØ­Ø¯ Ù…Ù† Ø§Ù„ÙØ±Øµ Ø¨Ù†Ø³Ø¨Ø© ${probability}%`;
            }
        }

        const aiElements = this.generateAIReasoning(userData);
        if (aiElements) {
            reasoning += `\n${aiElements}`;
        }

        const now = new Date();
        const saudiTime = new Date(now.getTime() + (3 * 60 * 60 * 1000));
        const realTime = saudiTime.toLocaleTimeString('ar-SA', { 
            hour: '2-digit', 
            minute: '2-digit',
            second: '2-digit',
            hour12: false 
        });
        
        const prediction = {
            type: isGoal ? 'âš½ GOAL' : 'ğŸ›‘ NO GOAL',
            probability: probability,
            confidence: 100,
            reasoning: reasoning,
            timestamp: realTime,
            algorithm: this.algorithmVersion,
            bet_amount: betAmount,
            prediction_id: Date.now().toString()
        };

        return prediction;
    }

    generateAIReasoning(userData) {
        const aiInsights = [
            "ğŸ¤– Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ ÙŠØ­Ù„Ù„ Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ù„Ø¹Ø¨ Ø¨Ø¯Ù‚Ø© Ø¹Ø§Ù„ÙŠØ©",
            "ğŸ§  Ø§Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© ØªØªØ¹Ù„Ù… Ù…Ù† Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø³Ø§Ø¨Ù‚Ø© Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø¯Ù‚Ø©",
            "ğŸ“ˆ Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„ÙŠ ÙŠØ­Ø³Ù† Ø§Ù„ØªÙˆÙ‚Ø¹Ø§Øª Ø¨Ø§Ø³ØªÙ…Ø±Ø§Ø±",
            "ğŸ¯ ØªØ­Ù„ÙŠÙ„ Ù…ØªÙ‚Ø¯Ù… Ù„Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙÙŠ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„ÙØ¹Ù„ÙŠ",
            "âš¡ Ù…Ø¹Ø§Ù„Ø¬Ø© ÙÙˆØ±ÙŠØ© Ù„Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª ÙˆØ§Ù„ØªÙˆÙ‚Ø¹Ø§Øª"
        ];
        
        const randomInsight = aiInsights[Math.floor(Math.random() * aiInsights.length)];
        
        if (userData.result_history && userData.result_history.length > 5) {
            const recentStats = userData.result_history.slice(-5);
            const recentWins = recentStats.filter(r => r.outcome === 'win').length;
            
            if (recentWins >= 3) {
                return `${randomInsight}\nğŸ’ª Ø£Ø¯Ø§Ø¡ Ù‚ÙˆÙŠ ÙÙŠ Ø§Ù„ØªÙˆÙ‚Ø¹Ø§Øª Ø§Ù„Ø£Ø®ÙŠØ±Ø©`;
            } else if (recentWins <= 1) {
                return `${randomInsight}\nğŸ”„ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ù†ØªØ§Ø¦Ø¬`;
            }
        }
        
        return randomInsight;
    }

    generateNextPrediction(userId, userData, betAmount = 0) {
        return this.generateSmartPrediction(userId, userData, betAmount);
    }

    validatePrediction(prediction, userData) {
        if (!userData.result_history || userData.result_history.length === 0) {
            return { valid: true, message: "âœ… ØªÙˆÙ‚Ø¹ Ø¬Ø¯ÙŠØ¯ - Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ø³Ø§Ø¨Ù‚Ø©" };
        }

        const lastPrediction = userData.result_history[userData.result_history.length - 1];
        
        if (lastPrediction.outcome === 'lose' && lastPrediction.type === prediction.type) {
            const shouldSwitch = Math.random() > 0.3;
            if (shouldSwitch) {
                return {
                    valid: false,
                    message: "ğŸ”„ ØªØºÙŠÙŠØ± Ø§Ù„ØªÙˆÙ‚Ø¹ Ø¨Ø¹Ø¯ Ø§Ù„Ø®Ø³Ø§Ø±Ø© Ø§Ù„Ø£Ø®ÙŠØ±Ø©",
                    newType: prediction.type === 'âš½ GOAL' ? 'ğŸ›‘ NO GOAL' : 'âš½ GOAL'
                };
            }
        }

        return { valid: true, message: "âœ… Ø§Ù„ØªÙˆÙ‚Ø¹ Ù…ØªÙˆØ§ÙÙ‚ Ù…Ø¹ Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©" };
    }
}

// ğŸ“¤ IMGBB UPLOADER - ENHANCED
class ImgBBUploader {
    constructor(apiKey) {
        this.apiKey = apiKey;
        this.baseUrl = 'https://api.imgbb.com/1/upload';
    }

    async uploadImage(imageBuffer) {
        try {
            const FormData = require('form-data');
            const formData = new FormData();
            
            formData.append('key', this.apiKey);
            formData.append('image', imageBuffer.toString('base64'));
            
            const response = await axios.post(this.baseUrl, formData, {
                headers: {
                    ...formData.getHeaders()
                },
                timeout: 30000
            });
            
            if (response.data && response.data.success) {
                return {
                    success: true,
                    url: response.data.data.url,
                    display_url: response.data.data.display_url,
                    thumb_url: response.data.data.thumb?.url || response.data.data.url,
                    delete_url: response.data.data.delete_url
                };
            } else {
                return {
                    success: false,
                    error: 'Upload failed'
                };
            }
        } catch (error) {
            console.error('ImgBB upload error:', error);
            return {
                success: false,
                error: error.message
            };
        }
    }

    async uploadImageFromUrl(imageUrl) {
        try {
            const response = await axios.get(imageUrl, { 
                responseType: 'arraybuffer',
                timeout: 30000
            });
            const imageBuffer = Buffer.from(response.data);
            return await this.uploadImage(imageBuffer);
        } catch (error) {
            console.error('ImgBB upload from URL error:', error);
            return {
                success: false,
                error: error.message
            };
        }
    }
}

// INITIALIZE SYSTEMS
const goalAI = new GoalPredictionAI();
const dynamicStats = new DynamicStatistics();
const imgbbUploader = new ImgBBUploader(CONFIG.IMGBB_API_KEY);

// ğŸ“¢ CHANNEL NOTIFICATION SYSTEM
class ChannelNotifier {
    constructor(bot, channelId) {
        this.bot = bot;
        this.channelId = channelId;
    }

    async sendSubscriptionNotification(userData, subscriptionType, amount, paymentSystem) {
        try {
            const systemText = paymentSystem === 'binance' ? 'Ø¨Ø§ÙŠÙ†Ø§Ù†Ø³' : 'ØªØ­ÙˆÙŠÙ„ Ø¨Ù†ÙƒÙŠ';
            const subscriptionDisplayName = getSubscriptionDisplayName(subscriptionType);
            
            const message = `
ğŸ‰ *Ø§Ø´ØªØ±Ø§Ùƒ Ø¬Ø¯ÙŠØ¯ ÙÙŠ Ø§Ù„Ø¨ÙˆØª - ${systemText}*

ğŸ‘¤ *Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:* ${userData.username}
ğŸ” *Ø§Ù„Ø­Ø³Ø§Ø¨:* ${userData.onexbet}
ğŸ“¦ *Ø§Ù„Ø¨Ø§Ù‚Ø©:* ${subscriptionDisplayName}
ğŸ’° *Ø§Ù„Ù…Ø¨Ù„Øº:* ${amount}$
ğŸ’³ *Ø§Ù„Ù†Ø¸Ø§Ù…:* ${systemText}

ğŸ•’ *Ø§Ù„ÙˆÙ‚Øª:* ${new Date().toLocaleString('ar-EG')}
            `;

            await this.bot.telegram.sendMessage(this.channelId, message, {
                parse_mode: 'Markdown'
            });
        } catch (error) {
            console.error('Error sending subscription notification:', error);
        }
    }

    async sendPredictionNotification(userData, prediction, betAmount) {
        try {
            const message = `
ğŸ¯ *ØªÙˆÙ‚Ø¹ Ø¬Ø¯ÙŠØ¯ ÙÙŠ Ø§Ù„Ø¨ÙˆØª*

ğŸ‘¤ *Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:* ${userData.username}
ğŸ” *Ø§Ù„Ø­Ø³Ø§Ø¨:* ${userData.onexbet}
ğŸ¯ *Ø§Ù„ØªÙˆÙ‚Ø¹:* ${prediction.type}
ğŸ“ˆ *Ø§Ù„Ø§Ø­ØªÙ…Ø§Ù„ÙŠØ©:* ${prediction.probability}%
ğŸ’° *Ù…Ø¨Ù„Øº Ø§Ù„Ø±Ù‡Ø§Ù†:* ${betAmount}$

ğŸ’¡ *Ø§Ù„ØªØ­Ù„ÙŠÙ„:*
${prediction.reasoning}

ğŸ•’ *Ø§Ù„ÙˆÙ‚Øª:* ${new Date().toLocaleString('ar-EG')}
            `;

            await this.bot.telegram.sendMessage(this.channelId, message, {
                parse_mode: 'Markdown'
            });
        } catch (error) {
            console.error('Error sending prediction notification:', error);
        }
    }

    async sendResultNotification(userData, prediction, outcome, profit) {
        try {
            const message = `
ğŸ¯ *Ù†ØªÙŠØ¬Ø© Ø§Ù„ØªÙˆÙ‚Ø¹ - ${outcome === 'win' ? 'ÙÙˆØ² ğŸ‰' : 'Ø®Ø³Ø§Ø±Ø© ğŸ”„'}*

ğŸ‘¤ *Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:* ${userData.username}
ğŸ” *Ø§Ù„Ø­Ø³Ø§Ø¨:* ${userData.onexbet}
ğŸ¯ *Ø§Ù„ØªÙˆÙ‚Ø¹:* ${prediction.type}
ğŸ’° *Ù…Ø¨Ù„Øº Ø§Ù„Ø±Ù‡Ø§Ù†:* ${prediction.bet_amount}$
${outcome === 'win' ? `ğŸ’µ *Ø§Ù„Ø±Ø¨Ø­:* ${profit}$` : ''}

${outcome === 'win' ? 
'ğŸŠ Ù…Ø¨Ø±ÙˆÙƒ! Ø§Ù„ØªÙˆÙ‚Ø¹ ÙƒØ§Ù† Ù†Ø§Ø¬Ø­Ø§Ù‹' : 
'ğŸ’ª Ù„Ø§ ØªÙ‚Ù„Ù‚ØŒ Ø§Ù„ÙØ±ØµØ© Ø§Ù„Ù‚Ø§Ø¯Ù…Ø© Ø³ØªÙƒÙˆÙ† Ø£ÙØ¶Ù„'}

ğŸ•’ *Ø§Ù„ÙˆÙ‚Øª:* ${new Date().toLocaleString('ar-EG')}
            `;

            await this.bot.telegram.sendMessage(this.channelId, message, {
                parse_mode: 'Markdown'
            });
        } catch (error) {
            console.error('Error sending result notification:', error);
        }
    }
}

const channelNotifier = new ChannelNotifier(bot, CONFIG.CHANNEL_ID);

// ğŸ¯ BOT SETUP WITH PERSISTENT SESSIONS - ENHANCED
const getSessionKey = (ctx) => {
    return ctx.from && ctx.from.id.toString();
};

// ğŸ†• ENHANCED SESSION MIDDLEWARE - FIXED PERSISTENCE
bot.use(async (ctx, next) => {
    const sessionKey = getSessionKey(ctx);
    if (!sessionKey) {
        return next();
    }

    try {
        // ğŸ†• FIRST: Always try to load user data from Firestore
        const userData = await dbManager.getUser(sessionKey);
        
        if (userData) {
            // ğŸ‰ User exists - restore complete session
            if (!ctx.session) {
                ctx.session = {};
            }
            
            ctx.session.userData = userData;
            ctx.session.step = 'verified';
            ctx.session.country = userData.country;
            
            console.log(`âœ… User ${sessionKey} session restored from Firestore`);
        } else {
            // New user - initialize empty session
            if (!ctx.session) {
                ctx.session = {
                    step: 'start',
                    userData: {},
                    verificationCode: null,
                    accountId: null,
                    paymentType: null,
                    paymentSystem: null,
                    adminMode: false,
                    adminStep: null,
                    awaitingPaymentAccount: false,
                    paymentAccount: null,
                    currentBet: 0,
                    originalBet: 0,
                    totalProfit: 0,
                    awaitingBetAmount: false,
                    searchQuery: null,
                    broadcastMessage: null,
                    adminSettingsStep: null,
                    selectedPaymentType: null,
                    editingSubscriptionType: null,
                    adminPaymentSystem: null,
                    awaitingBankImage: false,
                    editingBankStep: null,
                    bankEditData: {},
                    checkingChannel: false,
                    country: null,
                    awaitingCountry: false,
                    currentPrediction: null,
                    predictionHistory: [],
                    awaitingResult: false
                };
            }
        }

        await next();

        // ğŸ†• ALWAYS save session to Firestore after processing
        if (ctx.session && sessionKey) {
            await dbManager.saveSession(sessionKey, ctx.session);
        }
        
    } catch (error) {
        console.error('Session middleware error:', error);
        // Continue even if session saving fails
        await next();
    }
});

// ğŸ¯ Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ø«Ø§Ø¨ØªØ© - UPDATED FOR DUAL PAYMENT AND SUPPORT
const getMainKeyboard = () => {
    return Markup.keyboard([
        ['ğŸ¯ Ø¬Ù„Ø¨ Ø§Ù„ØªØ­Ù„ÙŠÙ„', 'ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§ØªÙŠ'],
        ['ğŸ’³ Ø§Ù„Ø§Ø´ØªØ±Ø§ÙƒØ§Øª', 'ğŸ‘¥ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØª'],
        ['ğŸ‘¤ Ø­Ø§Ù„Ø© Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ', `ğŸ†˜ Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ`]
    ]).resize();
};

const getLoginKeyboard = () => {
    return Markup.keyboard([
        ['ğŸ” Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨']
    ]).resize();
};

const getPaymentMethodKeyboard = () => {
    return Markup.keyboard([
        ['ğŸ’³ Ø¨Ø§ÙŠÙ†Ø§Ù†Ø³', 'ğŸ¦ ØªØ­ÙˆÙŠÙ„ Ø¨Ù†ÙƒÙŠ'],
        ['ğŸ”™ Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø©']
    ]).resize();
};

const getSubscriptionKeyboard = () => {
    return Markup.keyboard([
        ['ğŸ’° Ø£Ø³Ø¨ÙˆØ¹ÙŠ', 'ğŸ’° Ø´Ù‡Ø±ÙŠ'],
        ['ğŸ’° 3 Ø£Ø´Ù‡Ø±', 'ğŸ’° Ø³Ù†ÙˆÙŠ'],
        ['ğŸ”™ Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø©']
    ]).resize();
};

const getCountriesKeyboard = () => {
    return Markup.keyboard([
        ['ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø³Ø¹ÙˆØ¯ÙŠØ©', 'ğŸ‡¦ğŸ‡ª Ø§Ù„Ø¥Ù…Ø§Ø±Ø§Øª', 'ğŸ‡¶ğŸ‡¦ Ù‚Ø·Ø±'],
        ['ğŸ‡°ğŸ‡¼ Ø§Ù„ÙƒÙˆÙŠØª', 'ğŸ‡§ğŸ‡­ Ø§Ù„Ø¨Ø­Ø±ÙŠÙ†', 'ğŸ‡´ğŸ‡² Ø¹Ù…Ø§Ù†'],
        ['ğŸ‡¾ğŸ‡ª Ø§Ù„ÙŠÙ…Ù†', 'ğŸ‡®ğŸ‡¶ Ø§Ù„Ø¹Ø±Ø§Ù‚', 'ğŸ‡¸ğŸ‡¾ Ø³ÙˆØ±ÙŠØ§'],
        ['ğŸ‡¯ğŸ‡´ Ø§Ù„Ø£Ø±Ø¯Ù†', 'ğŸ‡±ğŸ‡§ Ù„Ø¨Ù†Ø§Ù†', 'ğŸ‡ªğŸ‡¬ Ù…ØµØ±'],
        ['ğŸ‡©ğŸ‡¿ Ø§Ù„Ø¬Ø²Ø§Ø¦Ø±', 'ğŸ‡²ğŸ‡¦ Ø§Ù„Ù…ØºØ±Ø¨', 'ğŸ‡¹ğŸ‡³ ØªÙˆÙ†Ø³'],
        ['ğŸ‡±ğŸ‡¾ Ù„ÙŠØ¨ÙŠØ§', 'ğŸ‡¸ğŸ‡© Ø§Ù„Ø³ÙˆØ¯Ø§Ù†', 'ğŸ‡¸ğŸ‡¸ Ø¬Ù†ÙˆØ¨ Ø§Ù„Ø³ÙˆØ¯Ø§Ù†'],
        ['ğŸ‡µğŸ‡¸ ÙÙ„Ø³Ø·ÙŠÙ†', 'ğŸ‡²ğŸ‡· Ù…ÙˆØ±ÙŠØªØ§Ù†ÙŠØ§', 'ğŸ‡©ğŸ‡¯ Ø¬ÙŠØ¨ÙˆØªÙŠ'],
        ['ğŸ‡¸ğŸ‡´ Ø§Ù„ØµÙˆÙ…Ø§Ù„', 'ğŸ‡°ğŸ‡² Ø¬Ø²Ø± Ø§Ù„Ù‚Ù…Ø±']
    ]).resize();
};

// ğŸ› ï¸ UTILITY FUNCTIONS
function calculateRemainingDays(endDate) {
    try {
        const end = new Date(endDate);
        const now = new Date();
        const diffTime = end - now;
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
        return diffDays > 0 ? diffDays : 0;
    } catch (error) {
        return 0;
    }
}

function addSubscriptionDays(startDate, type) {
    try {
        const start = new Date(startDate);
        const types = {
            week: 7,
            month: 30,
            three_months: 90,
            year: 365
        };
        start.setDate(start.getDate() + types[type]);
        return start.toISOString();
    } catch (error) {
        const newDate = new Date();
        newDate.setDate(newDate.getDate() + 30);
        return newDate.toISOString();
    }
}

function getSubscriptionDuration(type) {
    const durations = {
        'week': '7 Ø£ÙŠØ§Ù…',
        'month': '30 ÙŠÙˆÙ…Ø§Ù‹', 
        'three_months': '90 ÙŠÙˆÙ…Ø§Ù‹',
        'year': '365 ÙŠÙˆÙ…Ø§Ù‹'
    };
    return durations[type] || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯';
}

function generateBankDescription(subscriptionType, price, accountNumber) {
    const typeNames = {
        'week': 'Ø£Ø³Ø¨ÙˆØ¹ÙŠØ©',
        'month': 'Ø´Ù‡Ø±ÙŠØ©',
        'three_months': '3 Ø£Ø´Ù‡Ø±',
        'year': 'Ø³Ù†ÙˆÙŠØ©'
    };
    
    return `ğŸ”¹ ØªØ­ÙˆÙŠÙ„ Ø¨Ù†ÙƒÙŠ - Ø¨Ø§Ù‚Ø© ${typeNames[subscriptionType]}\nğŸ’³ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨: ${accountNumber}\nğŸ¦ Ø§Ù„Ø¨Ù†Ùƒ: Ø§Ù„Ø¨Ù†Ùƒ Ø§Ù„ÙƒØ±ÙŠÙ…ÙŠ\nğŸ’° Ø§Ù„Ù…Ø¨Ù„Øº: ${price}$\nğŸ’µ Ø§Ù„Ø¹Ù…Ù„Ø©: Ø§Ù„Ø¯ÙˆÙ„Ø§Ø± Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠ\n\nğŸ“‹ Ø§Ù„Ø´Ø±ÙˆØ·:\nâ€¢ ÙŠØ¬Ø¨ Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø¨Ø§Ù„Ø¯ÙˆÙ„Ø§Ø± Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠ\nâ€¢ Ø¥Ø±ÙØ§Ù‚ ØµÙˆØ±Ø© Ø¥Ø«Ø¨Ø§Øª Ø§Ù„Ø¯ÙØ¹\nâ€¢ ÙƒØªØ§Ø¨Ø© Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ`;
}

function getSubscriptionDisplayName(type) {
    const names = {
        'week': 'Ø£Ø³Ø¨ÙˆØ¹ÙŠ',
        'month': 'Ø´Ù‡Ø±ÙŠ', 
        'three_months': '3 Ø£Ø´Ù‡Ø±',
        'year': 'Ø³Ù†ÙˆÙŠ'
    };
    return names[type] || type;
}

function getLossEncouragement() {
    const encouragements = [
        "ğŸ’ª Ù„Ø§ ØªÙ‚Ù„Ù‚! Ø§Ù„Ø®Ø³Ø§Ø±Ø© Ø¬Ø²Ø¡ Ù…Ù† Ø§Ù„Ù„Ø¹Ø¨Ø©ØŒ Ø§Ø³ØªÙ…Ø± ÙˆØ³ÙŠØ£ØªÙŠ Ø§Ù„Ù†Ø¬Ø§Ø­",
        "ğŸ”„ Ù‡Ø°Ù‡ Ù…Ø¬Ø±Ø¯ Ø¬ÙˆÙ„Ø©ØŒ Ø§Ù„Ø±Ù‡Ø§Ù† Ø§Ù„Ù‚Ø§Ø¯Ù… Ø³ÙŠÙƒÙˆÙ† Ø£ÙØ¶Ù„",
        "ğŸ¯ Ø§Ù„ØªØ¹Ù„Ù… Ù…Ù† Ø§Ù„Ø®Ø³Ø§Ø±Ø© ÙŠØ¨Ù†ÙŠ Ø§Ù„ÙÙˆØ² Ø§Ù„Ù‚Ø§Ø¯Ù…ØŒ Ø§Ø³ØªÙ…Ø± ÙÙŠ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©",
        "âš¡ Ù„Ø§ ØªØ³ØªØ³Ù„Ù…! Ø§Ù„Ù†Ø¬Ø§Ø­ Ù‚Ø§Ø¯Ù… ÙÙŠ Ø§Ù„Ø¬ÙˆÙ„Ø© Ø§Ù„Ù‚Ø§Ø¯Ù…Ø©",
        "ğŸ”¥ Ø§Ù„Ø®Ø³Ø§Ø±Ø© ØªØ²ÙŠØ¯ Ù…Ù† Ø®Ø¨Ø±ØªÙƒØŒ Ø§Ø³ØªÙØ¯ Ù…Ù†Ù‡Ø§ Ù„Ù„ÙÙˆØ² Ø§Ù„Ù‚Ø§Ø¯Ù…",
        "ğŸš€ ÙƒÙ„ Ø¹Ø¸ÙŠÙ… Ù…Ø± Ø¨Ø§Ù„Ø®Ø³Ø§Ø±Ø©ØŒ Ø§Ø³ØªÙ…Ø± ÙˆØ³ÙŠÙƒÙˆÙ† Ø§Ù„ÙÙˆØ² Ø­Ù„ÙŠÙÙƒ"
    ];
    return encouragements[Math.floor(Math.random() * encouragements.length)];
}

function getWinCongratulations(profit) {
    const congratulations = [
        `ğŸ‰ Ù…Ø¨Ø±ÙˆÙƒ Ø§Ù„ÙÙˆØ²! Ù„Ù‚Ø¯ Ø±Ø¨Ø­Øª ${profit}$`,
        `âœ¨ Ù†Ø¬Ø§Ø­ Ø±Ø§Ø¦Ø¹! Ø£Ø±Ø¨Ø§Ø­Ùƒ ${profit}$`,
        `ğŸ† ÙÙˆØ² Ù…Ù…ØªØ§Ø²! ${profit}$ ØªÙ…Øª Ø¥Ø¶Ø§ÙØªÙ‡Ø§ Ø¥Ù„Ù‰ Ø±ØµÙŠØ¯Ùƒ`,
        `ğŸ’ Ø£Ø¯Ø§Ø¡ Ø§Ø³ØªØ«Ù†Ø§Ø¦ÙŠ! Ø±Ø¨Ø­Øª ${profit}$ Ø¨Ù†Ø¬Ø§Ø­`,
        `ğŸš€ Ø§Ø­ØªØ±Ø§ÙÙŠØ©! ${profit}$ Ø£Ø±Ø¨Ø§Ø­ Ø¯Ù‚ÙŠÙ‚Ø©`
    ];
    return congratulations[Math.floor(Math.random() * congratulations.length)];
}

// ğŸ” FUNCTION TO CHECK CHANNEL SUBSCRIPTION
async function checkChannelSubscription(userId) {
    try {
        const chatMember = await bot.telegram.getChatMember(CONFIG.CHANNEL_ID, userId);
        return chatMember.status === 'member' || chatMember.status === 'administrator' || chatMember.status === 'creator';
    } catch (error) {
        console.error('Error checking channel subscription:', error);
        return false;
    }
}

// ğŸ¯ BOT COMMANDS - UPDATED WITH PERSISTENT DATA

bot.start(async (ctx) => {
    try {
        const settings = await dbManager.getSettings();
        if (settings.maintenance_mode && ctx.from.id.toString() !== CONFIG.ADMIN_ID) {
            await ctx.replyWithMarkdown('ğŸ”§ *Ø§Ù„Ø¨ÙˆØª ØªØ­Øª Ø§Ù„ØµÙŠØ§Ù†Ø©*\n\nâ° Ù†Ø¹Ù…Ù„ Ø¹Ù„Ù‰ ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø®Ø¯Ù…Ø© Ù„ÙƒÙ…\nğŸ”„ Ø³Ù†Ø¹ÙˆØ¯ Ù‚Ø±ÙŠØ¨Ø§Ù‹ Ø¨Ø£ÙØ¶Ù„ Ù…Ù…Ø§ ÙƒØ§Ù†\n\nğŸ“ Ù„Ù„Ø§Ø³ØªÙØ³Ø§Ø±: ' + CONFIG.DEVELOPER);
            return;
        }

        const userId = ctx.from.id.toString();
        const userName = ctx.from.first_name;

        console.log(`ğŸ” Checking user ${userId} in database...`);

        // ğŸ†• FIRST: Always check if user exists in database
        const existingUser = await dbManager.getUser(userId);
        
        if (existingUser) {
            // ğŸ‰ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø³Ø¬Ù„ Ù…Ø³Ø¨Ù‚Ø§Ù‹ - Ø§Ø³ØªØ±Ø¬Ø§Ø¹ ÙƒØ§Ù…Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
            ctx.session.step = 'verified';
            ctx.session.userData = existingUser;
            ctx.session.country = existingUser.country;

            console.log(`âœ… User ${userId} found in database, restoring session...`);

            const remainingDays = calculateRemainingDays(existingUser.subscription_end_date);
            
            let statusMessage = '';
            if (existingUser.subscription_status === 'active' && remainingDays > 0) {
                statusMessage = `ğŸ‰ *Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ø¹ÙˆØ¯ØªÙƒ!*\n\n` +
                               `âœ… *Ø§Ø´ØªØ±Ø§ÙƒÙƒ Ù†Ø´Ø·*\n` +
                               `ğŸ” Ø§Ù„Ø­Ø³Ø§Ø¨: \`${existingUser.onexbet}\`\n` +
                               `ğŸ“¦ Ø§Ù„Ù†ÙˆØ¹: ${getSubscriptionDisplayName(existingUser.subscription_type)}\n` +
                               `ğŸ“… Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡: ${new Date(existingUser.subscription_end_date).toLocaleDateString('ar-EG')}\n` +
                               `â³ Ù…ØªØ¨Ù‚ÙŠ: ${remainingDays} ÙŠÙˆÙ…`;
            } else if (existingUser.free_attempts > 0) {
                statusMessage = `ğŸ‰ *Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ø¹ÙˆØ¯ØªÙƒ!*\n\n` +
                               `ğŸ¯ *Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ù…Ø¬Ø§Ù†ÙŠØ© Ù…ØªØ§Ø­Ø©*\n` +
                               `ğŸ” Ø§Ù„Ø­Ø³Ø§Ø¨: \`${existingUser.onexbet}\`\n` +
                               `ğŸ†“ Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ù…Ø¬Ø§Ù†ÙŠØ©: ${existingUser.free_attempts}`;
            } else {
                statusMessage = `ğŸ‰ *Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ø¹ÙˆØ¯ØªÙƒ!*\n\n` +
                               `ğŸš« *Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª*\n` +
                               `ğŸ” Ø§Ù„Ø­Ø³Ø§Ø¨: \`${existingUser.onexbet}\`\n` +
                               `ğŸ’³ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ù„Ù„Ù…ØªØ§Ø¨Ø¹Ø©`;
            }

            await ctx.replyWithMarkdown(statusMessage, getMainKeyboard());
            
        } else {
            // Ù…Ø³ØªØ®Ø¯Ù… Ø¬Ø¯ÙŠØ¯ - Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø¯ÙˆÙ„Ø© Ø£ÙˆÙ„Ø§Ù‹
            ctx.session.step = 'awaiting_country';
            ctx.session.awaitingCountry = true;

            console.log(`ğŸ†• New user ${userId}, starting registration...`);

            try {
                await ctx.replyWithPhoto(CONFIG.START_IMAGE, {
                    caption: `ğŸ‰ *Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ù†Ø¸Ø§Ù… GOAL Predictor Pro v${CONFIG.VERSION}* ğŸš€\n\n` +
                            `ğŸ¤– *Ø£Ù‚ÙˆÙ‰ Ù†Ø¸Ø§Ù… Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„Ø£Ù‡Ø¯Ø§Ù Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ*\n` +
                            `ğŸ’ *Ø§Ù„Ù…Ø·ÙˆØ±:* ${CONFIG.DEVELOPER}\n` +
                            `ğŸ“¢ *Ø§Ù„Ù‚Ù†Ø§Ø©:* ${CONFIG.CHANNEL}`
                });
            } catch (photoError) {
                await ctx.replyWithMarkdown(`ğŸ‰ *Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ù†Ø¸Ø§Ù… GOAL Predictor Pro v${CONFIG.VERSION}* ğŸš€`);
            }

            const countryMessage = `
ğŸŒ *Ø§Ø®ØªØ± Ø¯ÙˆÙ„ØªÙƒ*

ğŸ”° *Ù„Ø±Ø¨Ø· Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ø¨Ø­Ø³Ø§Ø¨Ùƒ*

ğŸ“‹ *ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ø¯ÙˆÙ„ØªÙƒ Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©:*

ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø³Ø¹ÙˆØ¯ÙŠØ© - ğŸ‡¦ğŸ‡ª Ø§Ù„Ø¥Ù…Ø§Ø±Ø§Øª - ğŸ‡¶ğŸ‡¦ Ù‚Ø·Ø±
ğŸ‡°ğŸ‡¼ Ø§Ù„ÙƒÙˆÙŠØª - ğŸ‡§ğŸ‡­ Ø§Ù„Ø¨Ø­Ø±ÙŠÙ† - ğŸ‡´ğŸ‡² Ø¹Ù…Ø§Ù†
ğŸ‡¾ğŸ‡ª Ø§Ù„ÙŠÙ…Ù† - ğŸ‡®ğŸ‡¶ Ø§Ù„Ø¹Ø±Ø§Ù‚ - ğŸ‡¸ğŸ‡¾ Ø³ÙˆØ±ÙŠØ§
ğŸ‡¯ğŸ‡´ Ø§Ù„Ø£Ø±Ø¯Ù† - ğŸ‡±ğŸ‡§ Ù„Ø¨Ù†Ø§Ù† - ğŸ‡ªğŸ‡¬ Ù…ØµØ±
ğŸ‡©ğŸ‡¿ Ø§Ù„Ø¬Ø²Ø§Ø¦Ø± - ğŸ‡²ğŸ‡¦ Ø§Ù„Ù…ØºØ±Ø¨ - ğŸ‡¹ğŸ‡³ ØªÙˆÙ†Ø³
ğŸ‡±ğŸ‡¾ Ù„ÙŠØ¨ÙŠØ§ - ğŸ‡¸ğŸ‡© Ø§Ù„Ø³ÙˆØ¯Ø§Ù† - ğŸ‡¸ğŸ‡¸ Ø¬Ù†ÙˆØ¨ Ø§Ù„Ø³ÙˆØ¯Ø§Ù†
ğŸ‡µğŸ‡¸ ÙÙ„Ø³Ø·ÙŠÙ† - ğŸ‡²ğŸ‡· Ù…ÙˆØ±ÙŠØªØ§Ù†ÙŠØ§ - ğŸ‡©ğŸ‡¯ Ø¬ÙŠØ¨ÙˆØªÙŠ
ğŸ‡¸ğŸ‡´ Ø§Ù„ØµÙˆÙ…Ø§Ù„ - ğŸ‡°ğŸ‡² Ø¬Ø²Ø± Ø§Ù„Ù‚Ù…Ø±

ğŸ“ *Ø§Ø®ØªØ± Ø¯ÙˆÙ„ØªÙƒ Ù„Ù„Ø§Ø³ØªÙ…Ø±Ø§Ø±:*
            `;

            await ctx.replyWithMarkdown(countryMessage, getCountriesKeyboard());
        }

    } catch (error) {
        console.error('Start command error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù…ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù„Ø§Ø­Ù‚Ø§Ù‹');
    }
});

// ğŸ“ HANDLE TEXT MESSAGES - UPDATED WITH DUPLICATE ACCOUNT CHECK
bot.on('text', async (ctx) => {
    try {
        const settings = await dbManager.getSettings();
        if (settings.maintenance_mode && ctx.from.id.toString() !== CONFIG.ADMIN_ID) {
            await ctx.replyWithMarkdown('ğŸ”§ *Ø§Ù„Ø¨ÙˆØª ØªØ­Øª Ø§Ù„ØµÙŠØ§Ù†Ø©*\n\nâ° Ù†Ø¹Ù…Ù„ Ø¹Ù„Ù‰ ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø®Ø¯Ù…Ø© Ù„ÙƒÙ…\nğŸ”„ Ø³Ù†Ø¹ÙˆØ¯ Ù‚Ø±ÙŠØ¨Ø§Ù‹ Ø¨Ø£ÙØ¶Ù„ Ù…Ù…Ø§ ÙƒØ§Ù†\n\nğŸ“ Ù„Ù„Ø§Ø³ØªÙØ³Ø§Ø±: ' + CONFIG.DEVELOPER);
            return;
        }

        const text = ctx.message.text;
        const session = ctx.session;
        const userId = ctx.from.id.toString();

        // ğŸ†• Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø¯ÙˆÙ„Ø©
        if (session.step === 'awaiting_country' && session.awaitingCountry) {
            const arabCountries = [
                'ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø³Ø¹ÙˆØ¯ÙŠØ©', 'ğŸ‡¦ğŸ‡ª Ø§Ù„Ø¥Ù…Ø§Ø±Ø§Øª', 'ğŸ‡¶ğŸ‡¦ Ù‚Ø·Ø±', 'ğŸ‡°ğŸ‡¼ Ø§Ù„ÙƒÙˆÙŠØª', 'ğŸ‡§ğŸ‡­ Ø§Ù„Ø¨Ø­Ø±ÙŠÙ†',
                'ğŸ‡´ğŸ‡² Ø¹Ù…Ø§Ù†', 'ğŸ‡¾ğŸ‡ª Ø§Ù„ÙŠÙ…Ù†', 'ğŸ‡®ğŸ‡¶ Ø§Ù„Ø¹Ø±Ø§Ù‚', 'ğŸ‡¸ğŸ‡¾ Ø³ÙˆØ±ÙŠØ§', 'ğŸ‡¯ğŸ‡´ Ø§Ù„Ø£Ø±Ø¯Ù†',
                'ğŸ‡±ğŸ‡§ Ù„Ø¨Ù†Ø§Ù†', 'ğŸ‡ªğŸ‡¬ Ù…ØµØ±', 'ğŸ‡©ğŸ‡¿ Ø§Ù„Ø¬Ø²Ø§Ø¦Ø±', 'ğŸ‡²ğŸ‡¦ Ø§Ù„Ù…ØºØ±Ø¨', 'ğŸ‡¹ğŸ‡³ ØªÙˆÙ†Ø³',
                'ğŸ‡±ğŸ‡¾ Ù„ÙŠØ¨ÙŠØ§', 'ğŸ‡¸ğŸ‡© Ø§Ù„Ø³ÙˆØ¯Ø§Ù†', 'ğŸ‡¸ğŸ‡¸ Ø¬Ù†ÙˆØ¨ Ø§Ù„Ø³ÙˆØ¯Ø§Ù†', 'ğŸ‡µğŸ‡¸ ÙÙ„Ø³Ø·ÙŠÙ†',
                'ğŸ‡²ğŸ‡· Ù…ÙˆØ±ÙŠØªØ§Ù†ÙŠØ§', 'ğŸ‡©ğŸ‡¯ Ø¬ÙŠØ¨ÙˆØªÙŠ', 'ğŸ‡¸ğŸ‡´ Ø§Ù„ØµÙˆÙ…Ø§Ù„', 'ğŸ‡°ğŸ‡² Ø¬Ø²Ø± Ø§Ù„Ù‚Ù…Ø±'
            ];

            if (arabCountries.includes(text)) {
                ctx.session.country = text;
                ctx.session.awaitingCountry = false;
                
                const isSubscribed = await checkChannelSubscription(userId);
                
                if (!isSubscribed) {
                    await ctx.replyWithMarkdown(
                        `ğŸ” *Ù…Ø±Ø­Ø¨Ø§Ù‹ ${ctx.from.first_name}*\n\n` +
                        `ğŸ“ *Ø§Ù„Ø¯ÙˆÙ„Ø©:* ${text}\n\n` +
                        `ğŸ“¢ *Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØª ÙŠØ¬Ø¨ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ù‚Ù†Ø§ØªÙ†Ø§ Ø£ÙˆÙ„Ø§Ù‹*\n\n` +
                        `ğŸ‘‰ ${CONFIG.CHANNEL_USERNAME}\n\n` +
                        `âœ… Ø¨Ø¹Ø¯ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø± Ø£Ø¯Ù†Ø§Ù‡ Ù„Ù„ØªØ­Ù‚Ù‚:`,
                        Markup.inlineKeyboard([
                            [Markup.button.callback('âœ… ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ', 'check_channel_subscription')]
                        ])
                    );
                    return;
                }

                await dbManager.setChannelSubscription(userId, true);
                
                const welcomeMessage = `
ğŸ” *Ù…Ø±Ø­Ø¨Ø§Ù‹ ${ctx.from.first_name} ÙÙŠ Ù†Ø¸Ø§Ù… GOAL Predictor Pro v${CONFIG.VERSION}*

ğŸ“ *Ø§Ù„Ø¯ÙˆÙ„Ø©:* ${text}

ğŸ¯ *Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ØªÙ‚Ø¯Ù… Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„Ø£Ù‡Ø¯Ø§Ù ÙÙŠ Ø§Ù„Ù…Ø¨Ø§Ø±ÙŠØ§Øª*
ğŸ¤– *Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ø°ÙƒÙŠØ© Ù…Ø®ÙÙŠØ© ØªØ­Ù„Ù„ Ø§Ù„Ù…Ø¨Ø§Ø±ÙŠØ§Øª Ø¨Ø¯Ù‚Ø© Ø¹Ø§Ù„ÙŠØ©*

ğŸ“‹ *Ø®Ø·ÙˆØ§Øª Ø§Ù„Ø¯Ø®ÙˆÙ„:*
1ï¸âƒ£ Ø£Ø¯Ø®Ù„ Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet (10 Ø£Ø±Ù‚Ø§Ù…)
2ï¸âƒ£ Ø§Ø³ØªÙ„Ù… ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚ (6 Ø£Ø±Ù‚Ø§Ù…)  
3ï¸âƒ£ Ø£Ø¯Ø®Ù„ ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚
4ï¸âƒ£ Ø§Ø¨Ø¯Ø£ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠØ©

ğŸ’ *Ø§Ù„Ù…Ø·ÙˆØ±:* ${CONFIG.DEVELOPER}
ğŸ“¢ *Ø§Ù„Ù‚Ù†Ø§Ø©:* ${CONFIG.CHANNEL}

ğŸ”¢ *Ø§Ù„Ø¢Ù† Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ "ğŸ” Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨" Ù„Ø¨Ø¯Ø¡ Ø§Ù„ØªØ³Ø¬ÙŠÙ„*
                `;

                await ctx.replyWithMarkdown(welcomeMessage, getLoginKeyboard());
                
            } else {
                await ctx.replyWithMarkdown('âŒ *ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ø¯ÙˆÙ„Ø© Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©*', getCountriesKeyboard());
            }
            return;
        }

        // ğŸ” STEP 1: Validate 1xBet Account - Ù…Ø¹ Ù…Ù†Ø¹ Ø§Ù„ØªÙƒØ±Ø§Ø± Ø§Ù„Ù…Ø­Ø³Ù†
        if (session.step === 'awaiting_account_id') {
            const isSubscribed = await checkChannelSubscription(userId);
            if (!isSubscribed) {
                await ctx.replyWithMarkdown(
                    `âŒ *ÙŠØ¬Ø¨ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø© Ø£ÙˆÙ„Ø§Ù‹*\n\n` +
                    `ğŸ“¢ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©:\n` +
                    `ğŸ‘‰ ${CONFIG.CHANNEL_USERNAME}\n\n` +
                    `âœ… Ø«Ù… Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø± Ø£Ø¯Ù†Ø§Ù‡ Ù„Ù„ØªØ­Ù‚Ù‚:`,
                    Markup.inlineKeyboard([
                        [Markup.button.callback('âœ… ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ', 'check_channel_subscription')]
                    ])
                );
                return;
            }

            if (/^\d{10}$/.test(text)) {
                // ğŸ†• ØªØ­Ù‚Ù‚ Ù…Ø­Ø³Ù† Ù…Ù† Ø¹Ø¯Ù… ØªÙƒØ±Ø§Ø± Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨
                const existingUserWithAccount = await dbManager.getUserByOneXBet(text);
                if (existingUserWithAccount) {
                    await ctx.replyWithMarkdown(
                        'âŒ *Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨ Ù…Ø³Ø¬Ù„ Ø¨Ø§Ù„ÙØ¹Ù„!*\n\n' +
                        'ğŸ” Ù‡Ø°Ø§ Ø§Ù„Ø­Ø³Ø§Ø¨ Ù…Ø³Ø¬Ù„ Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¢Ø®Ø± ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù…\n' +
                        'ğŸ’¡ ÙŠØ±Ø¬Ù‰ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø­Ø³Ø§Ø¨Ùƒ Ø§Ù„Ø®Ø§Øµ Ø£Ùˆ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù…\n\n' +
                        `ğŸ“ Ø§Ù„Ø¯Ø¹Ù…: ${CONFIG.SUPPORT_USERNAME}`
                    );
                    return;
                }

                ctx.session.accountId = text;
                ctx.session.step = 'awaiting_verification';
                ctx.session.verificationCode = Math.floor(100000 + Math.random() * 900000);

                await ctx.replyWithMarkdown(
                    `âœ… *ØªÙ… Ø¥Ø±Ø³Ø§Ù„ ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚*\n\n` +
                    `ğŸ” *Ø§Ù„Ø­Ø³Ø§Ø¨:* \`${text}\`\n` +
                    `ğŸ“§ *Ø§Ù„ÙƒÙˆØ¯:* \`${ctx.session.verificationCode}\`\n\n` +
                    `ğŸ”¢ *Ø§Ù„Ø®Ø·ÙˆØ© 2:* Ø£Ø±Ø³Ù„ ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚ Ø®Ù„Ø§Ù„ 5 Ø¯Ù‚Ø§Ø¦Ù‚`
                );

                setTimeout(() => {
                    if (ctx.session.step === 'awaiting_verification') {
                        ctx.session.verificationCode = null;
                        ctx.session.step = 'start';
                    }
                }, 5 * 60 * 1000);
            } else {
                await ctx.replyWithMarkdown(
                    'âŒ *Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨ Ø®Ø·Ø£!*\n\n' +
                    'ğŸ”¢ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet Ù…ÙƒÙˆÙ† Ù…Ù† 10 Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø·\n' +
                    'ğŸ“ Ù…Ø«Ø§Ù„: 1234567890\n\n' +
                    'ğŸ’¡ ÙŠØ±Ø¬Ù‰ Ø¥Ø¹Ø§Ø¯Ø© Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø±Ù‚Ù… Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­'
                );
                return;
            }
        }
        // ğŸ” STEP 2: Verify Code
        else if (session.step === 'awaiting_verification' && /^\d{6}$/.test(text)) {
            if (parseInt(text) === ctx.session.verificationCode) {
                
                const waitingMessage = await ctx.replyWithMarkdown(
                    'ğŸ” *Ø¬Ø§Ø±ÙŠ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„...*\n\n' +
                    'â³ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ø³Ø¬Ù„Ø§Øª...\n' +
                    'ğŸ“¡ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø³ÙŠØ±ÙØ±...\n' +
                    'âš¡ Ø¬Ø§Ø±ÙŠ ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø­Ø³Ø§Ø¨...\n' +
                    'ğŸ¯ Ø¬Ø§Ø±ÙŠ Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠØ©...\n\n' +
                    'â° Ù‚Ø¯ ØªØ³ØªØºØ±Ù‚ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© 10 Ø«ÙˆØ§Ù†ÙŠ...'
                );

                for (let i = 1; i <= 10; i++) {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    try {
                        await ctx.telegram.editMessageText(
                            ctx.chat.id,
                            waitingMessage.message_id,
                            null,
                            `ğŸ” *Ø¬Ø§Ø±ÙŠ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„...*\n\n` +
                            `â³ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ø³Ø¬Ù„Ø§Øª... ${i}/10\n` +
                            `ğŸ“¡ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø³ÙŠØ±ÙØ±...\n` +
                            `âš¡ Ø¬Ø§Ø±ÙŠ ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø­Ø³Ø§Ø¨...\n` +
                            `ğŸ¯ Ø¬Ø§Ø±ÙŠ Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠØ©...`,
                            { parse_mode: 'Markdown' }
                        );
                    } catch (editError) {
                        console.log('Error editing waiting message:', editError);
                    }
                }

                const userData = {
                    user_id: userId,
                    username: ctx.from.first_name,
                    onexbet: ctx.session.accountId,
                    country: ctx.session.country || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯',
                    free_attempts: 10,
                    subscription_status: 'free',
                    subscription_type: 'none',
                    subscription_start_date: null,
                    subscription_end_date: null,
                    joined_at: new Date().toISOString(),
                    total_predictions: 0,
                    correct_predictions: 0,
                    wins: 0,
                    losses: 0,
                    total_bets: 0,
                    total_profit: 0,
                    channel_subscribed: true,
                    prediction_history: [],
                    result_history: []
                };

                // ğŸ†• Ø­ÙØ¸ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
                await dbManager.saveUser(userId, userData);
                ctx.session.step = 'verified';
                ctx.session.userData = userData;

                await ctx.deleteMessage(waitingMessage.message_id);

                await ctx.replyWithMarkdown(
                    `ğŸ‰ *ØªÙ… Ø§Ù„Ø±Ø¨Ø· Ø¨Ù†Ø¬Ø§Ø­!*\n\n` +
                    `ğŸ“ *Ø§Ù„Ø¯ÙˆÙ„Ø©:* ${userData.country}\n` +
                    `âœ… *Ø§Ù„Ø­Ø³Ø§Ø¨:* \`${ctx.session.accountId}\`\n` +
                    `ğŸ‘¤ *Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:* ${ctx.session.userData.username}\n\n` +
                    `ğŸ *ØªØ­ØµÙ„ Ø¹Ù„Ù‰ 10 Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ù…Ø¬Ø§Ù†ÙŠØ©*\n\n` +
                    `ğŸ¯ *ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¢Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø²Ø± "Ø¬Ù„Ø¨ Ø§Ù„ØªØ­Ù„ÙŠÙ„" Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„ØªÙˆÙ‚Ø¹Ø§Øª*`,
                    getMainKeyboard()
                );

            } else {
                await ctx.replyWithMarkdown('âŒ *ÙƒÙˆØ¯ ØªØ­Ù‚Ù‚ Ø®Ø§Ø·Ø¦!*\n\nğŸ” ÙŠØ±Ø¬Ù‰ Ø¥Ø¹Ø§Ø¯Ø© Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„ØµØ­ÙŠØ­');
            }
        }
        // ğŸ¯ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø«Ø§Ø¨ØªØ© Ø¨Ø¹Ø¯ Ø§Ù„ØªØ­Ù‚Ù‚
        else if (session.step === 'verified') {
            // ğŸ†• ØªØ­Ø¯ÙŠØ« Ù…Ù‡Ù…: ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø£ÙˆÙ„Ø§Ù‹
            const userData = await dbManager.getUser(userId);
            
            if (!userData) {
                await ctx.replyWithMarkdown('âŒ *Ø¬Ù„Ø³Ø© Ù…Ù†ØªÙ‡ÙŠØ©*\n\nğŸ” Ø£Ø±Ø³Ù„ /start Ù„Ù„Ø¨Ø¯Ø¡', getLoginKeyboard());
                return;
            }

            // ğŸ†• ØªØ­Ø¯ÙŠØ« Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¬Ù„Ø³Ø© Ø¨Ø¢Ø®Ø± Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
            ctx.session.userData = userData;

            switch (text) {
                case 'ğŸ¯ Ø¬Ù„Ø¨ Ø§Ù„ØªØ­Ù„ÙŠÙ„':
                    await handleGetPrediction(ctx, userData);
                    break;

                case 'ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§ØªÙŠ':
                    await handleUserStats(ctx, userData);
                    break;

                case 'ğŸ‘¥ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØª':
                    await handleBotStats(ctx);
                    break;

                case 'ğŸ’³ Ø§Ù„Ø§Ø´ØªØ±Ø§ÙƒØ§Øª':
                    ctx.session.step = 'choose_payment_method';
                    await ctx.replyWithMarkdown(
                        'ğŸ’³ *Ø§Ø®ØªØ± Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹*\n\n' +
                        'ğŸ”¹ Ø§Ø®ØªØ± Ø§Ù„Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ù…Ù†Ø§Ø³Ø¨Ø© Ù„Ù„Ø¯ÙØ¹:\n\n' +
                        'ğŸ’³ *Ø¨Ø§ÙŠÙ†Ø§Ù†Ø³* - Ø§Ù„Ø¯ÙØ¹ Ø¹Ø¨Ø± Ù…Ù†ØµØ© Ø¨Ø§ÙŠÙ†Ø§Ù†Ø³\n' +
                        'ğŸ¦ *ØªØ­ÙˆÙŠÙ„ Ø¨Ù†ÙƒÙŠ* - Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø¹Ø¨Ø± Ø§Ù„Ø¨Ù†Ùƒ Ø§Ù„ÙƒØ±ÙŠÙ…ÙŠ\n\n' +
                        'ğŸ“‹ Ø§Ø®ØªØ± Ø§Ù„Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„ØªÙŠ ØªÙ†Ø§Ø³Ø¨Ùƒ:',
                        getPaymentMethodKeyboard()
                    );
                    break;

                case 'ğŸ‘¤ Ø­Ø§Ù„Ø© Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ':
                    await handleSubscriptionStatus(ctx, userData);
                    break;

                case 'ğŸ†˜ Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ':
                    await ctx.replyWithMarkdown(
                        `ğŸ†˜ *Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ*\n\n` +
                        `ğŸ“ Ù„Ù„Ø§Ø³ØªÙØ³Ø§Ø±Ø§Øª ÙˆØ§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ:\n` +
                        `ğŸ‘¤ [${CONFIG.SUPPORT_USERNAME}](https://t.me/${CONFIG.SUPPORT_USERNAME.replace('@', '')})\n\n` +
                        `â° Ù…ØªØ§Ø­ÙˆÙ† 24/7 Ù„Ø®Ø¯Ù…ØªÙƒÙ…\n\n` +
                        `ğŸ’¬ Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø£Ø¹Ù„Ø§Ù‡ Ù„Ù„Ø¯Ø±Ø¯Ø´Ø© Ø§Ù„Ù…Ø¨Ø§Ø´Ø±Ø©`,
                        getMainKeyboard()
                    );
                    break;

                case 'ğŸ”™ Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø©':
                    await ctx.replyWithMarkdown('ğŸ”™ *Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©*', getMainKeyboard());
                    break;

                default:
                    if (text.startsWith('ğŸ’° ')) {
                        await handleSubscriptionSelection(ctx, userData, text);
                    } else {
                        await ctx.replyWithMarkdown('ğŸ”™ *Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©*', getMainKeyboard());
                    }
                    break;
            }
        }
        // ğŸ” Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…Ø³Ø¬Ù„ ÙˆØ­Ø§ÙˆÙ„ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø£Ø²Ø±Ø§Ø±
        else if (['ğŸ¯ Ø¬Ù„Ø¨ Ø§Ù„ØªØ­Ù„ÙŠÙ„', 'ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§ØªÙŠ', 'ğŸ’³ Ø§Ù„Ø§Ø´ØªØ±Ø§ÙƒØ§Øª', 'ğŸ‘¥ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØª'].includes(text)) {
            await ctx.replyWithMarkdown(
                'âŒ *ÙŠØ¬Ø¨ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø£ÙˆÙ„Ø§Ù‹*\n\n' +
                'ğŸ” Ø£Ø±Ø³Ù„ /start Ù„ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„',
                getLoginKeyboard()
            );
        } else {
            await ctx.replyWithMarkdown('ğŸ”™ *Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©*', getMainKeyboard());
        }

    } catch (error) {
        console.error('Text handler error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹', getMainKeyboard());
    }
});

// ğŸ¯ HANDLE CALLBACK QUERIES - ENHANCED WITH RESULT TRACKING
bot.on('callback_query', async (ctx) => {
    try {
        const callbackData = ctx.callbackQuery.data;
        const userId = ctx.from.id.toString();
        
        if (callbackData.startsWith('win_') || callbackData.startsWith('lose_')) {
            const isWin = callbackData.startsWith('win_');
            const predictionId = callbackData.split('_')[1];
            
            const userData = await dbManager.getUser(userId);
            if (!userData) {
                await ctx.answerCbQuery('âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…');
                return;
            }
            
            const currentPrediction = ctx.session.currentPrediction;
            if (!currentPrediction) {
                await ctx.answerCbQuery('âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªÙˆÙ‚Ø¹');
                return;
            }

            if (isWin) {
                const profit = ctx.session.currentBet;
                userData.wins = (userData.wins || 0) + 1;
                userData.correct_predictions = (userData.correct_predictions || 0) + 1;
                userData.total_profit = (userData.total_profit || 0) + profit;
                ctx.session.totalProfit += profit;
                
                await dbManager.addResultToHistory(userId, {
                    type: currentPrediction.type,
                    outcome: 'win',
                    bet_amount: ctx.session.currentBet,
                    profit: profit,
                    timestamp: new Date().toISOString()
                });
                
                await ctx.answerCbQuery(`ğŸŠ Ù…Ø¨Ø±ÙˆÙƒ! Ù†Ø¬Ø­ Ø§Ù„ØªÙˆÙ‚Ø¹ ÙˆØ±Ø¨Ø­Øª ${profit}$`);
                
                const winMessage = getWinCongratulations(profit);
                
                await ctx.replyWithMarkdown(
                    `ğŸ‰ *${winMessage}*\n\n` +
                    `âœ… ØªÙˆÙ‚Ø¹Ùƒ ÙƒØ§Ù† Ø¯Ù‚ÙŠÙ‚Ø§Ù‹ ÙˆÙ…Ù…ÙŠØ²Ø§Ù‹\n` +
                    `ğŸ’° Ø±Ø¨Ø­Øª: ${profit}$\n` +
                    `ğŸ’µ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø£Ø±Ø¨Ø§Ø­Ùƒ: ${ctx.session.totalProfit}$\n\n` +
                    `ğŸ¯ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¨Ø¯Ø¡ Ø¨ØªÙˆÙ‚Ø¹ Ø¬Ø¯ÙŠØ¯`,
                    getMainKeyboard()
                );
                
                await channelNotifier.sendResultNotification(userData, currentPrediction, 'win', profit);
                
                ctx.session.currentBet = ctx.session.originalBet;
                
            } else {
                userData.losses = (userData.losses || 0) + 1;
                
                await dbManager.addResultToHistory(userId, {
                    type: currentPrediction.type,
                    outcome: 'lose',
                    bet_amount: ctx.session.currentBet,
                    profit: 0,
                    timestamp: new Date().toISOString()
                });

                const newBet = ctx.session.currentBet * 2;
                ctx.session.currentBet = newBet;
                
                await ctx.answerCbQuery(`ğŸ”„ Ø¬Ø§Ø±ÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„ØªØ§Ù„ÙŠ...`);
                
                const newPrediction = goalAI.generateNextPrediction(userId, userData, newBet);
                
                const validation = goalAI.validatePrediction(newPrediction, userData);
                if (!validation.valid) {
                    newPrediction.type = validation.newType;
                    newPrediction.reasoning += `\n${validation.message}`;
                }
                
                ctx.session.currentPrediction = newPrediction;
                
                const encouragement = getLossEncouragement();
                
                await ctx.replyWithMarkdown(
                    `ğŸ”„ *${encouragement}*\n\n` +
                    `ğŸ“ˆ Ø§Ù„Ø±Ù‡Ø§Ù† Ø§Ù„ØªØ§Ù„ÙŠ Ù…Ø¶Ø§Ø¹Ù: ${newBet}$\n\n` +
                    `ğŸ¯ *Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„ØªØ§Ù„ÙŠ:*\n` +
                    `${newPrediction.type}\n` +
                    `ğŸ“ˆ ${newPrediction.probability}% | ğŸ¯ ${newPrediction.confidence}%\n` +
                    `ğŸ’¡ ${newPrediction.reasoning}\n\n` +
                    `âš¡ Ø§Ø³ØªÙ…Ø± ÙÙŠ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù„Ù„ÙÙˆØ² Ø§Ù„Ù‚Ø§Ø¯Ù…!`,
                    Markup.inlineKeyboard([
                        [ 
                            Markup.button.callback('ğŸ‰ Ø±Ø¨Ø­', `win_${newPrediction.prediction_id}`),
                            Markup.button.callback('ğŸ” Ø®Ø³Ø±', `lose_${newPrediction.prediction_id}`)
                        ]
                    ])
                );

                await channelNotifier.sendResultNotification(userData, currentPrediction, 'lose', 0);
            }
            
            // ğŸ†• Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø¹Ø¯ ÙƒÙ„ Ù†ØªÙŠØ¬Ø©
            await dbManager.saveUser(userId, userData);
            
            try {
                await ctx.deleteMessage(ctx.callbackQuery.message.message_id);
            } catch (deleteError) {
                console.log('Could not delete message:', deleteError);
            }
        }
        
        else if (callbackData === 'check_channel_subscription') {
            await handleCheckChannelSubscription(ctx);
        }
        
    } catch (error) {
        console.error('Callback query error:', error);
        await ctx.answerCbQuery('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©');
    }
});

// ğŸ†• Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©
async function handleCheckChannelSubscription(ctx) {
    try {
        const userId = ctx.from.id.toString();
        const isSubscribed = await checkChannelSubscription(userId);
        
        if (isSubscribed) {
            await dbManager.setChannelSubscription(userId, true);
            await ctx.answerCbQuery('âœ… ØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø¨Ù†Ø¬Ø§Ø­!');
            await ctx.deleteMessage();
            
            const userName = ctx.from.first_name;
            
            const welcomeMessage = `
ğŸ” *Ù…Ø±Ø­Ø¨Ø§Ù‹ ${userName} ÙÙŠ Ù†Ø¸Ø§Ù… GOAL Predictor Pro v${CONFIG.VERSION}*

ğŸ¯ *Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ØªÙ‚Ø¯Ù… Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„Ø£Ù‡Ø¯Ø§Ù ÙÙŠ Ø§Ù„Ù…Ø¨Ø§Ø±ÙŠØ§Øª*
ğŸ¤– *Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ø°ÙƒÙŠØ© Ù…Ø®ÙÙŠØ© ØªØ­Ù„Ù„ Ø§Ù„Ù…Ø¨Ø§Ø±ÙŠØ§Øª Ø¨Ø¯Ù‚Ø© Ø¹Ø§Ù„ÙŠØ©*

ğŸ“‹ *Ø®Ø·ÙˆØ§Øª Ø§Ù„Ø¯Ø®ÙˆÙ„:*
1ï¸âƒ£ Ø£Ø¯Ø®Ù„ Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet (10 Ø£Ø±Ù‚Ø§Ù…)
2ï¸âƒ£ Ø§Ø³ØªÙ„Ù… ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚ (6 Ø£Ø±Ù‚Ø§Ù…)  
3ï¸âƒ£ Ø£Ø¯Ø®Ù„ ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚
4ï¸âƒ£ Ø§Ø¨Ø¯Ø£ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠØ©

ğŸ’ *Ø§Ù„Ù…Ø·ÙˆØ±:* ${CONFIG.DEVELOPER}
ğŸ“¢ *Ø§Ù„Ù‚Ù†Ø§Ø©:* ${CONFIG.CHANNEL}

ğŸ”¢ *Ø§Ù„Ø¢Ù† Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ "ğŸ” Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨" Ù„Ø¨Ø¯Ø¡ Ø§Ù„ØªØ³Ø¬ÙŠÙ„*
            `;

            await ctx.replyWithMarkdown(welcomeMessage, getLoginKeyboard());
        } else {
            await ctx.answerCbQuery('âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø¨Ø¹Ø¯!');
            await ctx.replyWithMarkdown(
                `âŒ *Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ø´ØªØ±Ø§ÙƒÙƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©*\n\n` +
                `ğŸ“¢ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø© Ø£ÙˆÙ„Ø§Ù‹:\n` +
                `ğŸ‘‰ ${CONFIG.CHANNEL_USERNAME}\n\n` +
                `âœ… Ø«Ù… Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø± Ø£Ø¯Ù†Ø§Ù‡ Ù„Ù„ØªØ­Ù‚Ù‚:`,
                Markup.inlineKeyboard([
                    [Markup.button.callback('âœ… ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ', 'check_channel_subscription')]
                ])
            );
        }
    } catch (error) {
        console.error('Channel subscription check error:', error);
        await ctx.answerCbQuery('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚');
    }
}

// ğŸ¯ HANDLER FUNCTIONS - ENHANCED WITH AI PREDICTION

async function handleGetPrediction(ctx, userData) {
    try {
        if (userData.subscription_status !== 'active' && userData.free_attempts <= 0) {
            await ctx.replyWithMarkdown(
                'ğŸš« *Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠØ©*\n\n' +
                'ğŸ’³ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ù„Ù„Ù…ØªØ§Ø¨Ø¹Ø© ÙÙŠ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø®Ø¯Ù…Ø©',
                getMainKeyboard()
            );
            return;
        }

        if (!ctx.session.currentBet || ctx.session.currentBet <= 0) {
            ctx.session.awaitingBetAmount = true;
            await ctx.replyWithMarkdown(
                'ğŸ’° *Ø£Ø¯Ø®Ù„ Ù…Ø¨Ù„Øº Ø§Ù„Ø±Ù‡Ø§Ù†:*\n\n' +
                'ğŸ’µ ÙŠØ±Ø¬Ù‰ ÙƒØªØ§Ø¨Ø© Ø§Ù„Ù…Ø¨Ù„Øº Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ø§Ù„Ø±Ù‡Ø§Ù† Ø¹Ù„ÙŠÙ‡ (Ø¨Ø§Ù„Ø¯ÙˆÙ„Ø§Ø±)\n' +
                'ğŸ“ Ù…Ø«Ø§Ù„: 10 Ø£Ùˆ 25.5'
            );
            return;
        }

        const loadingMessages = [
            'ğŸ¯ *Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ Ø§Ù„ØªØ­Ù„ÙŠÙ„...*\n\nâš½ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† ÙØ±Øµ Ø§Ù„Ù‡Ø¯Ù...',
            'ğŸ¯ *Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ Ø§Ù„ØªØ­Ù„ÙŠÙ„...*\n\nğŸ”„ Ø¬Ø§Ø±ÙŠ ØªØ­Ù„ÙŠÙ„ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„ÙØ±ÙŠÙ‚ÙŠÙ†...',
            'ğŸ¯ *Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ Ø§Ù„ØªØ­Ù„ÙŠÙ„...*\n\nğŸ“Š Ø¬Ø§Ø±ÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª...',
            'ğŸ¯ *Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ Ø§Ù„ØªØ­Ù„ÙŠÙ„...*\n\nğŸ¤– Ø¬Ø§Ø±ÙŠ ØªØ·Ø¨ÙŠÙ‚ Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ...',
            'ğŸ¯ *Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ Ø§Ù„ØªØ­Ù„ÙŠÙ„...*\n\nğŸ§  Ø¬Ø§Ø±ÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©...',
            'ğŸ¯ *Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ Ø§Ù„ØªØ­Ù„ÙŠÙ„...*\n\nâš¡ Ø¬Ø§Ø±ÙŠ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„Ø°ÙƒÙŠ...'
        ];

        let loadingMsg = await ctx.replyWithMarkdown(loadingMessages[0]);
        
        for (let i = 1; i < loadingMessages.length; i++) {
            await new Promise(resolve => setTimeout(resolve, 1000));
            try {
                await ctx.telegram.editMessageText(
                    ctx.chat.id,
                    loadingMsg.message_id,
                    null,
                    loadingMessages[i],
                    { parse_mode: 'Markdown' }
                );
            } catch (editError) {
                console.log('Error editing loading message:', editError);
            }
        }

        const prediction = goalAI.generateSmartPrediction(userData.user_id, userData, ctx.session.currentBet);
        
        const validation = goalAI.validatePrediction(prediction, userData);
        if (!validation.valid) {
            prediction.type = validation.newType;
            prediction.reasoning += `\n${validation.message}`;
        }
        
        if (userData.subscription_status !== 'active') {
            userData.free_attempts--;
        }
        userData.total_predictions = (userData.total_predictions || 0) + 1;
        userData.total_bets = (userData.total_bets || 0) + ctx.session.currentBet;
        
        await dbManager.addPredictionToHistory(userData.user_id, prediction);
        
        ctx.session.currentPrediction = prediction;
        
        // ğŸ†• Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø¹Ø¯ ÙƒÙ„ ØªÙˆÙ‚Ø¹
        await dbManager.saveUser(ctx.from.id.toString(), userData);

        const now = new Date();
        const saudiTime = new Date(now.getTime() + (3 * 60 * 60 * 1000));
        const realTime = saudiTime.toLocaleTimeString('ar-SA', { 
            hour: '2-digit', 
            minute: '2-digit',
            second: '2-digit',
            hour12: false 
        });

        const recentStats = await dbManager.getRecentResultsStats(userData.user_id, 5);
        let statsInfo = '';
        
        if (recentStats.total > 0) {
            statsInfo = `\nğŸ“Š *Ø¢Ø®Ø± ${recentStats.total} ØªÙˆÙ‚Ø¹:* ${recentStats.wins} ÙÙˆØ² | ${recentStats.losses} Ø®Ø³Ø§Ø±Ø© | ${recentStats.winRate}% Ù†Ø¬Ø§Ø­`;
        }

        const analysisMessage = `
ğŸ¤– *ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ø§Ù„Ù…ØªÙ‚Ø¯Ù… - v${CONFIG.VERSION}*

ğŸ¯ *Ù†ØªÙŠØ¬Ø© Ø§Ù„ØªØ­Ù„ÙŠÙ„:*
${prediction.type}
ğŸ“ˆ *Ø§Ù„Ø§Ø­ØªÙ…Ø§Ù„ÙŠØ©:* ${prediction.probability}%
ğŸ¯ *Ø§Ù„Ø«Ù‚Ø©:* ${prediction.confidence}%

ğŸ’¡ *Ø§Ù„ØªØ­Ù„ÙŠÙ„:*
${prediction.reasoning}

ğŸ” *Ø§Ù„Ø­Ø³Ø§Ø¨:* \`${userData.onexbet}\`
ğŸ’° *Ù…Ø¨Ù„Øº Ø§Ù„Ø±Ù‡Ø§Ù†:* ${ctx.session.currentBet}$
ğŸ•’ *Ø§Ù„ÙˆÙ‚Øª:* ${realTime}
${statsInfo}

${userData.subscription_status !== 'active' ? 
    `ğŸ†“ *Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„Ù…ØªØ¨Ù‚ÙŠØ©:* ${userData.free_attempts}` : 
    `âœ… *Ø§Ø´ØªØ±Ø§Ùƒ Ù†Ø´Ø· - Ù…Ø­Ø§ÙˆÙ„Ø§Øª ØºÙŠØ± Ù…Ø­Ø¯ÙˆØ¯Ø©*`}
        `;

        await ctx.replyWithPhoto(CONFIG.PREDICTION_IMAGE, {
            caption: analysisMessage,
            parse_mode: 'Markdown',
            reply_markup: {
                inline_keyboard: [
                    [ 
                        Markup.button.callback('ğŸ‰ Ø±Ø¨Ø­', `win_${prediction.prediction_id}`),
                        Markup.button.callback('ğŸ” Ø®Ø³Ø±', `lose_${prediction.prediction_id}`)
                    ]
                ]
            }
        });

        await channelNotifier.sendPredictionNotification(userData, prediction, ctx.session.currentBet);

        await ctx.deleteMessage(loadingMsg.message_id);

    } catch (error) {
        console.error('Get prediction error:', error);
        await ctx.replyWithMarkdown('âŒ *Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„ØªØ­Ù„ÙŠÙ„*', getMainKeyboard());
    }
}

async function handleUserStats(ctx, userData) {
    const accuracy = userData.correct_predictions > 0 ? 
        Math.round((userData.correct_predictions / (userData.total_predictions || 1)) * 100) : 0;
    
    let subscriptionInfo = '';
    if (userData.subscription_status === 'active') {
        const remainingDays = calculateRemainingDays(userData.subscription_end_date);
        subscriptionInfo = `\nğŸ“¦ *Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ:* ${getSubscriptionDisplayName(userData.subscription_type)}\n` +
                          `â³ *Ù…ØªØ¨Ù‚ÙŠ:* ${remainingDays} ÙŠÙˆÙ…`;
    } else {
        subscriptionInfo = `\nğŸ†“ *Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ù…Ø¬Ø§Ù†ÙŠØ©:* ${userData.free_attempts}`;
    }

    const recentStats = await dbManager.getRecentResultsStats(userData.user_id, 10);
    let recentInfo = '';
    
    if (recentStats.total > 0) {
        recentInfo = `\nğŸ“ˆ *Ø¢Ø®Ø± 10 ØªÙˆÙ‚Ø¹Ø§Øª:*\n` +
                    `âœ… ${recentStats.wins} ÙÙˆØ² | âŒ ${recentStats.losses} Ø®Ø³Ø§Ø±Ø©\n` +
                    `ğŸ¯ ${recentStats.winRate}% Ù…Ø¹Ø¯Ù„ Ø§Ù„Ù†Ø¬Ø§Ø­`;
    }
    
    await ctx.replyWithMarkdown(
        `ğŸ“Š *Ø¥Ø­ØµØ§Ø¦ÙŠØ§ØªÙƒ Ø§Ù„Ø´Ø®ØµÙŠØ©*\n\n` +
        `ğŸ“ *Ø§Ù„Ø¯ÙˆÙ„Ø©:* ${userData.country || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'}\n` +
        `ğŸ” ${userData.onexbet}\n` +
        `ğŸ‘¤ ${userData.username}\n` +
        `ğŸ“ˆ ${userData.total_predictions || 0} ØªÙˆÙ‚Ø¹\n` +
        `âœ… ${userData.correct_predictions || 0} ØµØ­ÙŠØ­Ø©\n` +
        `ğŸ¯ ${accuracy}% Ø¯Ù‚Ø©\n` +
        `ğŸ‰ ${userData.wins || 0} ÙÙˆØ²\n` +
        `ğŸ’” ${userData.losses || 0} Ø®Ø³Ø§Ø±Ø©\n` +
        `ğŸ’° Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø±Ù‡Ø§Ù†Ø§Øª: ${userData.total_bets || 0}$\n` +
        `ğŸ’µ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø£Ø±Ø¨Ø§Ø­: ${userData.total_profit || 0}$` +
        subscriptionInfo +
        recentInfo,
        getMainKeyboard()
    );
}

async function handleBotStats(ctx) {
    const stats = dynamicStats.getStats();
    await ctx.replyWithMarkdown(
        `ğŸ‘¥ *Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØª*\n\n` +
        `ğŸ‘¤ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: ${stats.totalUsers.toLocaleString()}\n` +
        `ğŸŸ¢ Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù†Ø´Ø·ÙŠÙ† Ø§Ù„Ø¢Ù†: ${stats.activeUsers}\n` +
        `ğŸ“Š Ø§Ù„ØªÙˆÙ‚Ø¹Ø§Øª Ø§Ù„ÙŠÙˆÙ…ÙŠØ©: ${Math.floor(stats.activeUsers * 8.5)}\n\n` +
        `ğŸ¯ *Ø§Ù„Ù†Ø¸Ø§Ù… ÙŠØ¹Ù…Ù„ Ø¨ÙƒÙØ§Ø¡Ø© Ø¹Ø§Ù„ÙŠØ©*\n` +
        `ğŸ¤– *Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ù…Ø­Ø³Ù†Ø©*`,
        getMainKeyboard()
    );
}

async function handleSubscriptionStatus(ctx, userData) {
    let statusMessage = '';
    
    if (userData.subscription_status === 'active') {
        const remainingDays = calculateRemainingDays(userData.subscription_end_date);
        statusMessage = `âœ… *Ø§Ø´ØªØ±Ø§ÙƒÙƒ Ù†Ø´Ø·*\n\n` +
                       `ğŸ” Ø§Ù„Ø­Ø³Ø§Ø¨: \`${userData.onexbet}\`\n` +
                       `ğŸ“¦ Ø§Ù„Ù†ÙˆØ¹: ${getSubscriptionDisplayName(userData.subscription_type)}\n` +
                       `ğŸ“… Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡: ${new Date(userData.subscription_end_date).toLocaleDateString('ar-EG')}\n` +
                       `â³ Ù…ØªØ¨Ù‚ÙŠ: ${remainingDays} ÙŠÙˆÙ…`;
    } else if (userData.free_attempts > 0) {
        statusMessage = `ğŸ¯ *Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ù…Ø¬Ø§Ù†ÙŠØ© Ù…ØªØ§Ø­Ø©*\n\n` +
                       `ğŸ” Ø§Ù„Ø­Ø³Ø§Ø¨: \`${userData.onexbet}\`\n` +
                       `ğŸ†“ Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ù…Ø¬Ø§Ù†ÙŠØ©: ${userData.free_attempts}\n\n` +
                       `ğŸ’³ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…ÙŠØ²Ø§Øª ØºÙŠØ± Ù…Ø­Ø¯ÙˆØ¯Ø©`;
    } else {
        statusMessage = `ğŸš« *Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª*\n\n` +
                       `ğŸ” Ø§Ù„Ø­Ø³Ø§Ø¨: \`${userData.onexbet}\`\n` +
                       `ğŸ’³ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ù„Ù„Ù…ØªØ§Ø¨Ø¹Ø© ÙÙŠ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø®Ø¯Ù…Ø©`;
    }
    
    await ctx.replyWithMarkdown(statusMessage, getMainKeyboard());
}

// ğŸš€ START BOT
async function startBot() {
    console.log('ğŸ”„ Starting bot initialization...');
    
    try {
        // Ø§Ø®ØªØ¨Ø§Ø± Ø§ØªØµØ§Ù„ Firebase
        const testDoc = db.collection('connection_test').doc('bot_start');
        await testDoc.set({ 
            timestamp: new Date().toISOString(),
            status: 'connected',
            version: CONFIG.VERSION
        });
        
        console.log('âœ… Firebase connection test successful');
        
        // Ø¨Ø¯Ø¡ Ø§Ù„Ø¨ÙˆØª
        bot.launch().then(() => {
            console.log('ğŸ‰ SUCCESS! AI GOAL Predictor v16.0 ENHANCED is RUNNING!');
            console.log('ğŸ’¾ Enhanced Persistent Data Storage: âœ… ACTIVE');
            console.log('ğŸ” Duplicate Account Prevention: âœ… ACTIVE');
            console.log('ğŸ’³ Payment Systems: Binance + Bank Transfer');
            console.log('ğŸ¤– Enhanced AI Prediction with Result Tracking');
            console.log('ğŸ‘¤ Developer:', CONFIG.DEVELOPER);
            console.log('ğŸ“¢ Channel:', CONFIG.CHANNEL);
            console.log('ğŸŒ Health check: http://localhost:' + PORT);
            
            // Ø¹Ø±Ø¶ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø­Ù‚ÙŠÙ‚ÙŠØ© Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
            dbManager.getAllStats().then(stats => {
                console.log(`ğŸ“Š Database Stats: ${stats.totalUsers} users, ${stats.activeUsers} active subscriptions`);
            });
            
        }).catch(console.error);
        
    } catch (error) {
        console.log('âŒ Firebase connection failed:', error.message);
        console.log('ğŸ”„ Starting bot with fallback mode...');
        
        bot.launch().then(() => {
            console.log('ğŸ‰ Bot started in fallback mode');
        }).catch(console.error);
    }
}

// Ø¨Ø¯Ø¡ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª
startBot();

// ğŸ›‘ GRACEFUL SHUTDOWN
process.once('SIGINT', async () => {
    console.log('ğŸ”„ Shutting down gracefully...');
    console.log('ğŸ’¾ Saving final data to Firestore...');
    await bot.stop('SIGINT');
});

process.once('SIGTERM', async () => {
    console.log('ğŸ”„ Shutting down gracefully...');
    console.log('ğŸ’¾ Saving final data to Firestore...');
    await bot.stop('SIGTERM');
});

console.log('âœ… AI Goal Prediction System with ENHANCED PERSISTENCE Ready!');