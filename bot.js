// ===================================================
// ğŸš€ AI GOAL PREDICTOR ULTIMATE - VERSION 10.4
// ğŸ‘¤ DEVELOPER: AMIN - @GEMZGOOLBOT
// ğŸ”¥ FEATURES: SMART AI + BETTING SYSTEM + FIREBASE + FULL ADMIN PANEL
// ===================================================

console.log('ğŸ¤– Starting AI GOAL Predictor Ultimate v10.4...');
console.log('ğŸ•’ ' + new Date().toISOString());

// ğŸ”§ CONFIGURATION
const CONFIG = {
    BOT_TOKEN: process.env.BOT_TOKEN || "8125363786:AAFZaOGSAvq_p8Sc8cq2bIKZlpe4ej7tmdU",
    ADMIN_ID: process.env.ADMIN_ID || "6565594143",
    
    // ğŸ§  AI APIS
    AI_APIS: {
        GEMINI: process.env.GEMINI_API_KEY || "AIzaSyCtjtT98-M5v6t8qICPSDw-1TLwPneyaQc",
        OPENAI: process.env.OPENAI_API_KEY || "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"
    },

    // ğŸ’° DEFAULT PRICING
    SUBSCRIPTION_PRICES: {
        week: 10,
        month: 30,
        three_months: 80,
        year: 250
    },

    // ğŸ” DEFAULT PAYMENT LINKS
    PAYMENT_LINKS: {
        week: process.env.PAYMENT_WEEK || "https://binance.com/payment/weekly",
        month: process.env.PAYMENT_MONTH || "https://binance.com/payment/monthly", 
        three_months: process.env.PAYMENT_3MONTHS || "https://binance.com/payment/3months",
        year: process.env.PAYMENT_YEAR || "https://binance.com/payment/yearly"
    },
    
    VERSION: "10.4.0",
    DEVELOPER: "AMIN - @GEMZGOOLBOT",
    CHANNEL: "@GEMZGOOL",
    START_IMAGE: "https://i.ibb.co/tpy70Bd1/IMG-20251104-074214-065.jpg",
    ANALYSIS_IMAGE: "https://i.ibb.co/VYjf05S0/Screenshot.png",
    IMGBB_API_KEY: process.env.IMGBB_API_KEY || "42b155a527bee21e62e524a31fe9b1ee"
};

console.log('âœ… Configuration loaded successfully');

// ğŸš€ INITIALIZE BOT
const { Telegraf, Markup, session } = require('telegraf');
const axios = require('axios');
const express = require('express');

const bot = new Telegraf(CONFIG.BOT_TOKEN);

// ğŸŒ HEALTH CHECK SERVER FOR RENDER
const app = express();
const PORT = process.env.PORT || 3000;

app.use(express.json());

app.get('/', (req, res) => {
    res.json({ 
        status: 'OK', 
        version: CONFIG.VERSION,
        timestamp: new Date().toISOString(),
        message: 'AI Goal Predictor Bot is running...',
        developer: CONFIG.DEVELOPER
    });
});

app.listen(PORT, () => {
    console.log(`ğŸŒ Health check server running on port ${PORT}`);
});

// ğŸ–¼ï¸ FLEXIBLE IMAGE VERIFICATION SYSTEM 
class FlexibleImageVerification {
    constructor() {
        // ÙƒÙ„Ù…Ø§Øª Ù…ÙØªØ§Ø­ÙŠØ© ÙŠØ¬Ø¨ ÙˆØ¬ÙˆØ¯Ù‡Ø§ ÙÙŠ Ø§Ù„ØµÙˆØ±Ø© - Ù…ÙˆØ³Ø¹Ø© Ø¬Ø¯Ø§Ù‹
        this.requiredKeywords = [
            // ÙƒÙ„Ù…Ø§Øª Ø£Ø³Ø§Ø³ÙŠØ© ÙÙŠ Ø§Ù„Ù„Ø¹Ø¨Ø©
            "goal", "Ù‡Ø¯Ù", "Ø±Ù‡Ø§Ù†", "match", "Ù…Ø¨Ø§Ø±Ø§Ø©", "football", 
            "ÙƒØ±Ø© Ù‚Ø¯Ù…", "Ø¬ÙˆÙ„", "goalzz", "1xbet", "1xbet", "bet",
            "Ù…Ø±Ø§Ù‡Ù†Ø©", "ØªÙˆÙ‚Ø¹", "ØªÙ†Ø¨Ø¤", "ÙÙˆØ²", "Ø®Ø³Ø§Ø±Ø©", 
            
            // Ø£Ø³Ù…Ø§Ø¡ Ù„Ø§Ø¹Ø¨ÙŠÙ† Ù…Ø´Ù‡ÙˆØ±ÙŠÙ†
            "messi", "Ù…ÙŠØ³ÙŠ", "ronaldo", "Ø±ÙˆÙ†Ø§Ù„Ø¯Ùˆ", "neymar", "Ù†ÙŠÙ…Ø§Ø±",
            "mbappe", "Ù…Ø¨Ø§Ø¨ÙŠ", "salah", "ØµÙ„Ø§Ø­", "halland", "Ù‡Ø§Ù„Ø§Ù†Ø¯",
            "de bruyne", "Ø¯ÙŠ Ø¨Ø±ÙˆÙŠÙ†", "modric", "Ù…ÙˆØ¯Ø±ÙŠØªØ´", "kane", "ÙƒÙŠÙ†",
            
            // ÙØ±Ù‚ ÙˆØ¯ÙˆØ±ÙŠØ§Øª
            "premier league", "Ø§Ù„Ø¯ÙˆØ±ÙŠ Ø§Ù„Ø§Ù†Ø¬Ù„ÙŠØ²ÙŠ", "la liga", "Ù„Ø§Ù„ÙŠØºØ§",
            "champions league", "Ø¯ÙˆØ±ÙŠ Ø§Ù„Ø£Ø¨Ø·Ø§Ù„", "world cup", "ÙƒØ£Ø³ Ø§Ù„Ø¹Ø§Ù„Ù…",
            "euro", "ÙŠÙˆØ±Ùˆ", "club", "Ù†Ø§Ø¯ÙŠ", "team", "ÙØ±ÙŠÙ‚",
            
            // Ù…ØµØ·Ù„Ø­Ø§Øª Ø±ÙŠØ§Ø¶ÙŠØ©
            "player", "Ù„Ø§Ø¹Ø¨", "stadium", "Ù…Ù„Ø¹Ø¨", "coach", "Ù…Ø¯Ø±Ø¨",
            "referee", "Ø­ÙƒÙ…", "score", "Ù†ØªÙŠØ¬Ø©", "win", "ÙÙˆØ²",
            "lose", "Ø®Ø³Ø§Ø±Ø©", "draw", "ØªØ¹Ø§Ø¯Ù„", "penalty", "Ø¶Ø±Ø¨Ø© Ø¬Ø²Ø§Ø¡",
            
            // ÙƒÙ„Ù…Ø§Øª Ø¹Ø§Ù…Ø© Ù…ØªØ¹Ù„Ù‚Ø© Ø¨Ø§Ù„Ø±ÙŠØ§Ø¶Ø©
            "sport", "Ø±ÙŠØ§Ø¶Ø©", "game", "Ù„Ø¹Ø¨Ø©", "competition", "Ù…Ù†Ø§ÙØ³Ø©",
            "tournament", "Ø¨Ø·ÙˆÙ„Ø©", "league", "Ø¯ÙˆØ±ÙŠ", "cup", "ÙƒØ£Ø³",
            
            // ÙƒÙ„Ù…Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ©
            "no goal", "Ù„Ø§ Ù‡Ø¯Ù", "nogoal", "Ù„Ø§-Ù‡Ø¯Ù", "Ù‡Ø¯Ù Ù„Ø§", "goal no"
        ];
    }

    async verifyImage(imageUrl) {
        try {
            console.log(`ğŸ” Flexible verification for: ${imageUrl}`);
            
            // Ù…Ø­Ø§ÙƒØ§Ø© Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØ­Ù‚Ù‚
            await new Promise(resolve => setTimeout(resolve, 1500));
            
            // ÙØ­Øµ Ù…Ø±Ù† Ù„Ù„Ù…Ø­ØªÙˆÙ‰
            const verificationResult = this.flexibleContentCheck(imageUrl);
            
            return verificationResult;
            
        } catch (error) {
            console.error('Verification error:', error);
            return {
                decision: "ACCEPT", // ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„Ø®Ø·Ø£ØŒ Ù†Ù‚Ø¨Ù„ Ø§Ù„ØµÙˆØ±Ø© Ù„ØªØ¬Ù†Ø¨ Ø±ÙØ¶ Ø§Ù„ØµØ§Ù„Ø­
                reason: `ØªÙ… Ù‚Ø¨ÙˆÙ„ Ø§Ù„ØµÙˆØ±Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹`,
                persons_count: 2,
                keywords_found: ["goal", "Ù‡Ø¯Ù"],
                text_sample: "ØªØ­Ù„ÙŠÙ„ ØªÙ„Ù‚Ø§Ø¦ÙŠ"
            };
        }
    }

    flexibleContentCheck(imageUrl) {
        // ÙØ­Øµ Ù…Ø±Ù† Ù„Ù„Ù…Ø­ØªÙˆÙ‰ - ÙŠØ±ÙƒØ² ÙÙ‚Ø· Ø¹Ù„Ù‰ Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…ÙØªØ§Ø­ÙŠØ©
        
        // 1. ÙØ­Øµ ÙˆØ¬ÙˆØ¯ Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©
        const foundKeywords = this.simulateKeywordDetection(imageUrl);
        
        // 2. ÙØ­Øµ ÙˆØ¬ÙˆØ¯ Ø§Ù„Ø£Ø´Ø®Ø§Øµ (Ù…Ø­Ø§ÙƒØ§Ø©)
        const personCount = this.simulatePersonDetection(imageUrl);

        // Ù‚Ø±Ø§Ø± Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„Ù…Ø±Ù†
        // Ù†Ù‚Ø¨Ù„ Ø§Ù„ØµÙˆØ±Ø© Ø¥Ø°Ø§ ÙˆØ¬Ø¯Ù†Ø§ ÙƒÙ„Ù…Ø© Ù…ÙØªØ§Ø­ÙŠØ© ÙˆØ§Ø­Ø¯Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„ ÙˆØ´Ø®Øµ ÙˆØ§Ø­Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„
        if (foundKeywords.length >= 1 && personCount >= 1) {
            return {
                decision: "ACCEPT",
                reason: "Ø§Ù„ØµÙˆØ±Ø© ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù„Ø¹Ø¨Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨",
                persons_count: personCount,
                keywords_found: foundKeywords,
                text_sample: "ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù†Øµ: " + foundKeywords.join(", ")
            };
        } else {
            const reasons = [];
            if (foundKeywords.length < 1) reasons.push(`Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„Ù…Ø§Øª Ù…ÙØªØ§Ø­ÙŠØ©`);
            if (personCount < 1) reasons.push(`Ù„Ù… ÙŠØªÙ… Ø§ÙƒØªØ´Ø§Ù Ø£Ø´Ø®Ø§Øµ`);
            
            return {
                decision: "REJECT",
                reason: reasons.join(" Ùˆ "),
                persons_count: personCount,
                keywords_found: foundKeywords,
                text_sample: "Ù„Ù… ÙŠØªÙ… Ø§Ø³ØªÙŠÙØ§Ø¡ Ø§Ù„Ø´Ø±ÙˆØ· Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©"
            };
        }
    }

    simulateKeywordDetection(imageUrl) {
        // Ù…Ø­Ø§ÙƒØ§Ø© Ø§ÙƒØªØ´Ø§Ù Ø§Ù„ÙƒÙ„Ù…Ø§Øª ÙÙŠ Ø§Ù„ØµÙˆØ±Ø©
        // Ù†Ø³ØªØ®Ø¯Ù… Ø±Ø§Ø¨Ø· Ø§Ù„ØµÙˆØ±Ø© Ù„Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ù„Ø§ÙƒØªØ´Ø§Ù (ÙÙŠ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ Ø³ÙŠÙƒÙˆÙ† Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… OCR)
        
        const urlLower = imageUrl.toLowerCase();
        const found = [];
        
        // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…ÙØªØ§Ø­ÙŠØ© ÙÙŠ Ø§Ù„Ø±Ø§Ø¨Ø· (Ù…Ø­Ø§ÙƒØ§Ø©)
        this.requiredKeywords.forEach(keyword => {
            if (urlLower.includes(keyword.toLowerCase())) {
                found.push(keyword);
            }
        });
        
        // Ø¥Ø°Ø§ Ù„Ù… Ù†Ø¬Ø¯ ÙƒÙ„Ù…Ø§Øª ÙÙŠ Ø§Ù„Ø±Ø§Ø¨Ø·ØŒ Ù†Ø³ØªØ®Ø¯Ù… Ø§ÙƒØªØ´Ø§Ù Ø¹Ø´ÙˆØ§Ø¦ÙŠ Ù…Ø­Ø³Ù†
        // Ø¨Ù†Ø³Ø¨Ø© Ù‚Ø¨ÙˆÙ„ Ø¹Ø§Ù„ÙŠØ© Ù„Ù„ØµÙˆØ± Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ©
        if (found.length === 0) {
            // 90% ÙØ±ØµØ© Ù„Ù„Ù‚Ø¨ÙˆÙ„ Ù…Ø¹ ÙƒÙ„Ù…Ø§Øª Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© (Ù„Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ù„ØµÙˆØ± Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ©)
            if (Math.random() < 0.9) {
                const randomKeywords = this.getRandomKeywords();
                return randomKeywords;
            }
        }
        
        return found;
    }

    simulatePersonDetection(imageUrl) {
        // Ù…Ø­Ø§ÙƒØ§Ø© Ø§ÙƒØªØ´Ø§Ù Ø§Ù„Ø£Ø´Ø®Ø§Øµ ÙÙŠ Ø§Ù„ØµÙˆØ±Ø©
        // 95% Ù…Ù† Ø§Ù„ØµÙˆØ± Ø³ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø´Ø®ØµÙŠÙ† Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„ (Ù„Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ù„ØµÙˆØ± Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ©)
        
        const hasPersons = Math.random() < 0.95;
        return hasPersons ? Math.floor(Math.random() * 3) + 1 : 0; // 1-3 Ø£Ø´Ø®Ø§Øµ
    }

    getRandomKeywords() {
        // Ø¥Ø±Ø¬Ø§Ø¹ ÙƒÙ„Ù…Ø§Øª Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©
        const count = Math.floor(Math.random() * 3) + 1; // 1-3 ÙƒÙ„Ù…Ø§Øª
        const shuffled = [...this.requiredKeywords].sort(() => 0.5 - Math.random());
        return shuffled.slice(0, count);
    }
}

// ğŸ”¥ FIREBASE INITIALIZATION
let db = null;
let admin = null;

try {
    admin = require('firebase-admin');
    
    const serviceAccount = {
        "type": "service_account",
        "project_id": process.env.FIREBASE_PROJECT_ID || "bot-tlegram-9f4b5",
        "private_key_id": process.env.FIREBASE_PRIVATE_KEY_ID,
        "private_key": process.env.FIREBASE_PRIVATE_KEY ? process.env.FIREBASE_PRIVATE_KEY.replace(/\\n/g, '\n') : null,
        "client_email": process.env.FIREBASE_CLIENT_EMAIL || "firebase-adminsdk@bot-tlegram-9f4b5.iam.gserviceaccount.com",
        "client_id": process.env.FIREBASE_CLIENT_ID,
        "auth_uri": "https://accounts.google.com/o/oauth2/auth",
        "token_uri": "https://oauth2.googleapis.com/token",
        "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
        "client_x509_cert_url": process.env.FIREBASE_CERT_URL
    };

    if (!admin.apps.length) {
        admin.initializeApp({
            credential: admin.credential.cert(serviceAccount),
            databaseURL: "https://bot-tlegram-9f4b5-default-rtdb.firebaseio.com"
        });
    }
    
    db = admin.firestore();
    console.log('âœ… Firebase initialized successfully');
    
} catch (error) {
    console.log('âš ï¸ Firebase initialization failed:', error.message);
    console.log('ğŸ”„ Using local storage instead');
}

// ğŸ—„ï¸ LOCAL STORAGE FALLBACK
const userDatabase = new Map();
const paymentDatabase = new Map();
const settingsDatabase = new Map();

// ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
settingsDatabase.set('config', {
    prices: { ...CONFIG.SUBSCRIPTION_PRICES },
    payment_links: { ...CONFIG.PAYMENT_LINKS },
    maintenance_mode: false,
    updated_at: new Date().toISOString()
});

// ğŸ“Š FAKE STATISTICS SYSTEM
class FakeStatistics {
    constructor() {
        this.totalUsers = 78542;
        this.activeUsers = 287;
    }

    getStats() {
        return {
            totalUsers: this.totalUsers,
            activeUsers: this.activeUsers
        };
    }
}

// ğŸ§  SMART GOAL PREDICTION ENGINE
class GoalPredictionAI {
    constructor() {
        this.algorithmVersion = "10.4";
    }

    generateSmartPrediction(userId) {
        const isGoal = Math.random() > 0.5;
        const probability = Math.floor(Math.random() * 30) + 60;
        
        const prediction = {
            type: isGoal ? 'âš½ Ù‡Ø¯Ù Ù…Ø¤ÙƒØ¯' : 'ğŸ›¡ï¸ Ø¯ÙØ§Ø¹ Ù‚ÙˆÙŠ',
            probability: probability,
            confidence: 100,
            reasoning: isGoal ? 
                `ğŸ”¥ Ø§Ù„Ø¶ØºØ· Ø§Ù„Ù‡Ø¬ÙˆÙ…ÙŠ Ø§Ù„Ù…Ø³ØªÙ…Ø± ÙŠØ´ÙŠØ± Ù„Ù‡Ø¯Ù Ù‚Ø±ÙŠØ¨ Ø¨Ù†Ø³Ø¨Ø© ${probability}%` :
                `ğŸ›¡ï¸ Ø§Ù„Ø¯ÙØ§Ø¹ Ø§Ù„Ù…Ù†Ø¸Ù… ÙŠØ­Ø¯ Ù…Ù† Ø§Ù„ÙØ±Øµ Ø¨Ù†Ø³Ø¨Ø© ${probability}%`,
            timestamp: new Date().toISOString(),
            algorithm: this.algorithmVersion
        };

        return prediction;
    }

    async analyzeImageWithAI(imageUrl) {
        try {
            await new Promise(resolve => setTimeout(resolve, 2000));
            return this.generateSmartPrediction('image_analysis');
        } catch (error) {
            return this.generateSmartPrediction('fallback');
        }
    }

    generateNextPrediction(userId) {
        return this.generateSmartPrediction(userId);
    }
}

// ğŸ“¤ IMGBB UPLOADER
class ImgBBUploader {
    constructor(apiKey) {
        this.apiKey = apiKey;
    }

    async uploadImage(imageUrl) {
        try {
            await new Promise(resolve => setTimeout(resolve, 1000));
            return {
                success: true,
                url: imageUrl,
                delete_url: imageUrl
            };
        } catch (error) {
            return {
                success: false,
                error: error.message
            };
        }
    }
}

// ğŸ’¾ DATABASE MANAGER
class DatabaseManager {
    constructor() {
        this.maintenanceMode = false;
    }

    async getUser(userId) {
        try {
            if (db) {
                const userDoc = await db.collection('users').doc(userId.toString()).get();
                return userDoc.exists ? userDoc.data() : null;
            }
            return userDatabase.get(userId) || null;
        } catch (error) {
            return userDatabase.get(userId) || null;
        }
    }

    async saveUser(userId, userData) {
        try {
            if (db) {
                await db.collection('users').doc(userId.toString()).set(userData, { merge: true });
            }
            userDatabase.set(userId, userData);
            return true;
        } catch (error) {
            userDatabase.set(userId, userData);
            return true;
        }
    }

    async addPayment(paymentData) {
        const paymentId = Date.now().toString();
        try {
            const fullPaymentData = {
                ...paymentData,
                id: paymentId,
                status: 'pending',
                timestamp: new Date().toISOString()
            };

            if (db) {
                await db.collection('payments').doc(paymentId).set(fullPaymentData);
            }
            paymentDatabase.set(paymentId, fullPaymentData);
            return paymentId;
        } catch (error) {
            const fullPaymentData = {
                ...paymentData,
                id: paymentId,
                status: 'pending',
                timestamp: new Date().toISOString()
            };
            paymentDatabase.set(paymentId, fullPaymentData);
            return paymentId;
        }
    }

    async getPendingPayments() {
        try {
            if (db) {
                const paymentsSnapshot = await db.collection('payments').where('status', '==', 'pending').get();
                return paymentsSnapshot.docs.map(doc => doc.data());
            }
            return Array.from(paymentDatabase.values()).filter(p => p.status === 'pending');
        } catch (error) {
            return Array.from(paymentDatabase.values()).filter(p => p.status === 'pending');
        }
    }

    async updatePayment(paymentId, updates) {
        try {
            if (db) {
                await db.collection('payments').doc(paymentId).update(updates);
            }
            const payment = paymentDatabase.get(paymentId);
            if (payment) {
                paymentDatabase.set(paymentId, { ...payment, ...updates });
            }
            return true;
        } catch (error) {
            const payment = paymentDatabase.get(paymentId);
            if (payment) {
                paymentDatabase.set(paymentId, { ...payment, ...updates });
            }
            return true;
        }
    }

    async getAllUsers() {
        try {
            if (db) {
                const usersSnapshot = await db.collection('users').get();
                return usersSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            }
            return Array.from(userDatabase.entries()).map(([id, data]) => ({ id, ...data }));
        } catch (error) {
            return Array.from(userDatabase.entries()).map(([id, data]) => ({ id, ...data }));
        }
    }

    async getSettings() {
        try {
            if (db) {
                const settingsDoc = await db.collection('settings').doc('config').get();
                if (settingsDoc.exists) {
                    return settingsDoc.data();
                }
            }
            return settingsDatabase.get('config');
        } catch (error) {
            return settingsDatabase.get('config');
        }
    }

    async updateSettings(newSettings) {
        try {
            const updatedSettings = {
                ...newSettings,
                updated_at: new Date().toISOString()
            };

            if (db) {
                await db.collection('settings').doc('config').set(updatedSettings, { merge: true });
            }
            settingsDatabase.set('config', updatedSettings);
            return updatedSettings;
        } catch (error) {
            const updatedSettings = {
                ...newSettings,
                updated_at: new Date().toISOString()
            };
            settingsDatabase.set('config', updatedSettings);
            return updatedSettings;
        }
    }

    async getPayment(paymentId) {
        try {
            if (db) {
                const paymentDoc = await db.collection('payments').doc(paymentId).get();
                return paymentDoc.exists ? paymentDoc.data() : null;
            }
            return paymentDatabase.get(paymentId) || null;
        } catch (error) {
            return paymentDatabase.get(paymentId) || null;
        }
    }

    async getAllPayments() {
        try {
            if (db) {
                const paymentsSnapshot = await db.collection('payments').get();
                return paymentsSnapshot.docs.map(doc => doc.data());
            }
            return Array.from(paymentDatabase.values());
        } catch (error) {
            return Array.from(paymentDatabase.values());
        }
    }

    isMaintenanceMode() {
        return this.maintenanceMode;
    }

    async setMaintenanceMode(enabled) {
        try {
            const settings = await this.getSettings();
            settings.maintenance_mode = enabled;
            await this.updateSettings(settings);
            this.maintenanceMode = enabled;
            return true;
        } catch (error) {
            this.maintenanceMode = enabled;
            return true;
        }
    }

    async searchUsers(query) {
        try {
            const users = await this.getAllUsers();
            const lowerQuery = query.toLowerCase();
            
            return users.filter(user => 
                (user.user_id && user.user_id.toString().includes(query)) ||
                (user.username && user.username.toLowerCase().includes(lowerQuery)) ||
                (user.onexbet && user.onexbet.includes(query))
            );
        } catch (error) {
            console.error('Search users error:', error);
            return [];
        }
    }
}

// INITIALIZE SYSTEMS
const goalAI = new GoalPredictionAI();
const dbManager = new DatabaseManager();
const fakeStats = new FakeStatistics();
const imgbbUploader = new ImgBBUploader(CONFIG.IMGBB_API_KEY);
const imageVerification = new FlexibleImageVerification();

// ğŸ¯ BOT SETUP
bot.use(session({ 
    defaultSession: () => ({ 
        step: 'start',
        userData: {},
        verificationCode: null,
        accountId: null,
        paymentType: null,
        adminMode: false,
        adminStep: null,
        awaitingPaymentAccount: false,
        paymentAccount: null,
        currentBet: 0,
        originalBet: 0,
        totalProfit: 0,
        awaitingBetAmount: false,
        lastImageUrl: null,
        searchQuery: null,
        broadcastMessage: null
    })
}));

// ğŸ¯ Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ø«Ø§Ø¨ØªØ©
const getMainKeyboard = () => {
    return Markup.keyboard([
        ['ğŸ¯ Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„ØªØ§Ù„ÙŠ', 'ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§ØªÙŠ'],
        ['ğŸ“¸ Ø¥Ø±Ø³Ø§Ù„ ØµÙˆØ±Ø©', 'ğŸ’³ Ø§Ù„Ø§Ø´ØªØ±Ø§ÙƒØ§Øª'],
        ['ğŸ‘¥ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØª', 'ğŸ‘¤ Ø­Ø§Ù„Ø© Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ'],
        ['ğŸ†˜ Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ']
    ]).resize();
};

const getLoginKeyboard = () => {
    return Markup.keyboard([
        ['ğŸ” Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨']
    ]).resize();
};

const getSubscriptionKeyboard = () => {
    return Markup.keyboard([
        ['ğŸ’° Ø£Ø³Ø¨ÙˆØ¹ÙŠ', 'ğŸ’° Ø´Ù‡Ø±ÙŠ'],
        ['ğŸ’° 3 Ø£Ø´Ù‡Ø±', 'ğŸ’° Ø³Ù†ÙˆÙŠ'],
        ['ğŸ”™ Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø©']
    ]).resize();
};

const getAdminMainKeyboard = () => {
    return Markup.keyboard([
        ['ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù†Ø¸Ø§Ù…', 'ğŸ‘¥ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†'],
        ['ğŸ’° Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ø¯ÙØ¹', 'âš™ï¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª'],
        ['ğŸ“¢ Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø±', 'ğŸ” Ø¨Ø­Ø« Ø¹Ù† Ù…Ø³ØªØ®Ø¯Ù…'],
        ['ğŸ”§ Ù‚ÙÙ„/ÙØªØ­ Ø§Ù„Ø¨ÙˆØª', 'ğŸ”™ Ø§Ù„Ø®Ø±ÙˆØ¬ Ù…Ù† Ø§Ù„Ø¥Ø¯Ù…Ù†']
    ]).resize();
};

const getAdminUsersKeyboard = () => {
    return Markup.keyboard([
        ['ğŸ“‹ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†', 'âœ… Ø§Ù„Ù…Ø´ØªØ±ÙƒÙŠÙ† Ø§Ù„Ù†Ø´Ø·ÙŠÙ†'],
        ['ğŸ†“ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠÙ†', 'ğŸ“ˆ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†'],
        ['ğŸ”™ Ø±Ø¬ÙˆØ¹']
    ]).resize();
};

const getAdminPaymentsKeyboard = () => {
    return Markup.keyboard([
        ['ğŸ“¥ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…Ø¹Ù„Ù‚Ø©', 'âœ… Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…Ù‚Ø¨ÙˆÙ„Ø©'],
        ['âŒ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…Ø±ÙÙˆØ¶Ø©', 'ğŸ“‹ ÙƒÙ„ Ø§Ù„Ø·Ù„Ø¨Ø§Øª'],
        ['ğŸ”™ Ø±Ø¬ÙˆØ¹']
    ]).resize();
};

const getAdminSettingsKeyboard = () => {
    return Markup.keyboard([
        ['ğŸ’° ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø£Ø³Ø¹Ø§Ø±', 'ğŸ”— ØªØ¹Ø¯ÙŠÙ„ Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ø¯ÙØ¹'],
        ['ğŸ–¼ï¸ ØªØ¹Ø¯ÙŠÙ„ ØµÙˆØ±Ø© QR', 'âš™ï¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø©'],
        ['ğŸ”„ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ¹ÙŠÙŠÙ†', 'ğŸ”™ Ø±Ø¬ÙˆØ¹']
    ]).resize();
};

// ğŸ› ï¸ UTILITY FUNCTIONS
function calculateRemainingDays(endDate) {
    try {
        const end = new Date(endDate);
        const now = new Date();
        const diffTime = end - now;
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
        return diffDays > 0 ? diffDays : 0;
    } catch (error) {
        return 0;
    }
}

function addSubscriptionDays(startDate, type) {
    try {
        const start = new Date(startDate);
        const types = {
            week: 7,
            month: 30,
            three_months: 90,
            year: 365
        };
        start.setDate(start.getDate() + types[type]);
        return start.toISOString();
    } catch (error) {
        const newDate = new Date();
        newDate.setDate(newDate.getDate() + 30);
        return newDate.toISOString();
    }
}

// ğŸ¯ BOT COMMANDS

bot.start(async (ctx) => {
    try {
        const settings = await dbManager.getSettings();
        if (settings.maintenance_mode && ctx.from.id.toString() !== CONFIG.ADMIN_ID) {
            await ctx.replyWithMarkdown('ğŸ”§ *Ø§Ù„Ø¨ÙˆØª ØªØ­Øª Ø§Ù„ØµÙŠØ§Ù†Ø©*\n\nâ° Ù†Ø¹Ù…Ù„ Ø¹Ù„Ù‰ ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø®Ø¯Ù…Ø© Ù„ÙƒÙ…\nğŸ”„ Ø³Ù†Ø¹ÙˆØ¯ Ù‚Ø±ÙŠØ¨Ø§Ù‹ Ø¨Ø£ÙØ¶Ù„ Ù…Ù…Ø§ ÙƒØ§Ù†\n\nğŸ“ Ù„Ù„Ø§Ø³ØªÙØ³Ø§Ø±: ' + CONFIG.DEVELOPER);
            return;
        }

        const userId = ctx.from.id.toString();
        const userName = ctx.from.first_name;

        // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±Ø© Ø£ÙˆÙ„Ø§Ù‹
        try {
            await ctx.replyWithPhoto(CONFIG.START_IMAGE, {
                caption: `ğŸ‰ *Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ù†Ø¸Ø§Ù… GOAL Predictor Pro v${CONFIG.VERSION}* ğŸš€\n\n` +
                        `ğŸ¤– *Ø£Ù‚ÙˆÙ‰ Ù†Ø¸Ø§Ù… Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„Ø£Ù‡Ø¯Ø§Ù Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ*\n` +
                        `ğŸ’ *Ø§Ù„Ù…Ø·ÙˆØ±:* ${CONFIG.DEVELOPER}\n` +
                        `ğŸ“¢ *Ø§Ù„Ù‚Ù†Ø§Ø©:* ${CONFIG.CHANNEL}`
            });
        } catch (photoError) {
            await ctx.replyWithMarkdown(`ğŸ‰ *Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ù†Ø¸Ø§Ù… GOAL Predictor Pro v${CONFIG.VERSION}* ğŸš€`);
        }

        const existingUser = await dbManager.getUser(userId);
        
        if (existingUser) {
            ctx.session.step = 'verified';
            ctx.session.userData = existingUser;

            const remainingDays = calculateRemainingDays(existingUser.subscription_end_date);
            
            let statusMessage = '';
            if (existingUser.subscription_status === 'active' && remainingDays > 0) {
                statusMessage = `âœ… *Ø§Ø´ØªØ±Ø§ÙƒÙƒ Ù†Ø´Ø·*\n\n` +
                               `ğŸ” Ø§Ù„Ø­Ø³Ø§Ø¨: \`${existingUser.onexbet}\`\n` +
                               `ğŸ“¦ Ø§Ù„Ù†ÙˆØ¹: ${existingUser.subscription_type}\n` +
                               `ğŸ“… Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡: ${new Date(existingUser.subscription_end_date).toLocaleDateString('ar-EG')}\n` +
                               `â³ Ù…ØªØ¨Ù‚ÙŠ: ${remainingDays} ÙŠÙˆÙ…`;
            } else if (existingUser.free_attempts > 0) {
                statusMessage = `ğŸ¯ *Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ù…Ø¬Ø§Ù†ÙŠØ© Ù…ØªØ§Ø­Ø©*\n\n` +
                               `ğŸ” Ø§Ù„Ø­Ø³Ø§Ø¨: \`${existingUser.onexbet}\`\n` +
                               `ğŸ†“ Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ù…Ø¬Ø§Ù†ÙŠØ©: ${existingUser.free_attempts}`;
            } else {
                statusMessage = `ğŸš« *Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª*\n\n` +
                               `ğŸ” Ø§Ù„Ø­Ø³Ø§Ø¨: \`${existingUser.onexbet}\`\n` +
                               `ğŸ’³ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ù„Ù„Ù…ØªØ§Ø¨Ø¹Ø©`;
            }

            await ctx.replyWithMarkdown(statusMessage, getMainKeyboard());
            
        } else {
            ctx.session.step = 'start';
            ctx.session.userData = { userId, userName };

            const welcomeMessage = `
ğŸ” *Ù…Ø±Ø­Ø¨Ø§Ù‹ ${userName} ÙÙŠ Ù†Ø¸Ø§Ù… GOAL Predictor Pro v${CONFIG.VERSION}*

ğŸ¯ *Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ØªÙ‚Ø¯Ù… Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„Ø£Ù‡Ø¯Ø§Ù ÙÙŠ Ø§Ù„Ù…Ø¨Ø§Ø±ÙŠØ§Øª*
ğŸ¤– *Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ø°ÙƒÙŠØ© Ù…Ø®ÙÙŠØ© ØªØ­Ù„Ù„ Ø§Ù„Ù…Ø¨Ø§Ø±ÙŠØ§Øª Ø¨Ø¯Ù‚Ø© Ø¹Ø§Ù„ÙŠØ©*

ğŸ“‹ *Ø®Ø·ÙˆØ§Øª Ø§Ù„Ø¯Ø®ÙˆÙ„:*
1ï¸âƒ£ Ø£Ø¯Ø®Ù„ Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet (10 Ø£Ø±Ù‚Ø§Ù…)
2ï¸âƒ£ Ø§Ø³ØªÙ„Ù… ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚ (6 Ø£Ø±Ù‚Ø§Ù…)  
3ï¸âƒ£ Ø£Ø¯Ø®Ù„ ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚
4ï¸âƒ£ Ø§Ø¨Ø¯Ø£ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠØ©

ğŸ’ *Ø§Ù„Ù…Ø·ÙˆØ±:* ${CONFIG.DEVELOPER}
ğŸ“¢ *Ø§Ù„Ù‚Ù†Ø§Ø©:* ${CONFIG.CHANNEL}

ğŸ”¢ *Ø§Ù„Ø¢Ù† Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ "ğŸ” Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨" Ù„Ø¨Ø¯Ø¡ Ø§Ù„ØªØ³Ø¬ÙŠÙ„*
            `;

            await ctx.replyWithMarkdown(welcomeMessage, getLoginKeyboard());
        }

    } catch (error) {
        console.error('Start command error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù…ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù„Ø§Ø­Ù‚Ø§Ù‹');
    }
});

// ğŸ“ HANDLE TEXT MESSAGES
bot.on('text', async (ctx) => {
    try {
        const settings = await dbManager.getSettings();
        if (settings.maintenance_mode && ctx.from.id.toString() !== CONFIG.ADMIN_ID) {
            await ctx.replyWithMarkdown('ğŸ”§ *Ø§Ù„Ø¨ÙˆØª ØªØ­Øª Ø§Ù„ØµÙŠØ§Ù†Ø©*\n\nâ° Ù†Ø¹Ù…Ù„ Ø¹Ù„Ù‰ ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø®Ø¯Ù…Ø© Ù„ÙƒÙ…\nğŸ”„ Ø³Ù†Ø¹ÙˆØ¯ Ù‚Ø±ÙŠØ¨Ø§Ù‹ Ø¨Ø£ÙØ¶Ù„ Ù…Ù…Ø§ ÙƒØ§Ù†\n\nğŸ“ Ù„Ù„Ø§Ø³ØªÙØ³Ø§Ø±: ' + CONFIG.DEVELOPER);
            return;
        }

        const text = ctx.message.text;
        const session = ctx.session;
        const userId = ctx.from.id.toString();

        // ğŸ” ADMIN COMMANDS - Ù„Ù„Ø¥Ø¯Ù…Ù† ÙÙ‚Ø·
        if (userId === CONFIG.ADMIN_ID) {
            if (text === '/admin' || text === 'ğŸ” Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…') {
                ctx.session.adminMode = true;
                ctx.session.adminStep = 'main';
                await ctx.replyWithMarkdown('ğŸ”§ *Ù…Ø±Ø­Ø¨Ø§Ù‹ ÙÙŠ Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…*', getAdminMainKeyboard());
                return;
            }

            if (session.adminMode) {
                await handleAdminCommands(ctx, text);
                return;
            }
        }

        // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù…Ø³ØªØ®Ø¯Ù…
        if (session.adminStep === 'search_user') {
            await handleAdminSearchUser(ctx, text);
            return;
        }

        // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¥Ø´Ø¹Ø§Ø± Ø§Ù„Ø¬Ù…Ø§Ø¹ÙŠ
        if (session.adminStep === 'broadcast') {
            await handleAdminBroadcast(ctx, text);
            return;
        }

        // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¥Ø¯Ø®Ø§Ù„ Ù…Ø¨Ù„Øº Ø§Ù„Ø±Ù‡Ø§Ù†
        if (session.awaitingBetAmount) {
            const betAmount = parseFloat(text);
            if (isNaN(betAmount) || betAmount <= 0) {
                await ctx.replyWithMarkdown('âŒ *Ù…Ø¨Ù„Øº ØºÙŠØ± ØµØ­ÙŠØ­!*\n\nğŸ’° ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ù…Ø¨Ù„Øº ØµØ­ÙŠØ­ Ù„Ù„Ø±Ù‡Ø§Ù†');
                return;
            }

            ctx.session.currentBet = betAmount;
            ctx.session.originalBet = betAmount;
            ctx.session.awaitingBetAmount = false;

            await ctx.replyWithMarkdown(
                `âœ… *ØªÙ… ØªØ­Ø¯ÙŠØ¯ Ù…Ø¨Ù„Øº Ø§Ù„Ø±Ù‡Ø§Ù†:* ${betAmount}$\n\n` +
                `ğŸ“¸ *Ø§Ù„Ø¢Ù† ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ ØµÙˆØ±Ø© Ø§Ù„Ù…Ø¨Ø§Ø±Ø§Ø© Ù„Ù„ØªØ­Ù„ÙŠÙ„*`,
                getMainKeyboard()
            );
            return;
        }

        // ğŸ” Ø²Ø± Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨
        if (text === 'ğŸ” Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨' && session.step === 'start') {
            ctx.session.step = 'awaiting_account_id';
            await ctx.replyWithMarkdown(
                'ğŸ”¢ *Ø§Ù„Ø®Ø·ÙˆØ© 1:* Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ (10 Ø£Ø±Ù‚Ø§Ù…)\n\n' +
                'ğŸ’¡ *Ù…Ù„Ø§Ø­Ø¸Ø©:* ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø§Ù„Ø±Ù‚Ù… Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ'
            );
            return;
        }

        // ğŸ” STEP 1: Validate 1xBet Account
        if (session.step === 'awaiting_account_id' && /^\d{10}$/.test(text)) {
            
            ctx.session.accountId = text;
            ctx.session.step = 'awaiting_verification';
            ctx.session.verificationCode = Math.floor(100000 + Math.random() * 900000);

            await ctx.replyWithMarkdown(
                `âœ… *ØªÙ… Ø¥Ø±Ø³Ø§Ù„ ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚*\n\n` +
                `ğŸ” *Ø§Ù„Ø­Ø³Ø§Ø¨:* \`${text}\`\n` +
                `ğŸ“§ *Ø§Ù„ÙƒÙˆØ¯:* \`${ctx.session.verificationCode}\`\n\n` +
                `ğŸ”¢ *Ø§Ù„Ø®Ø·ÙˆØ© 2:* Ø£Ø±Ø³Ù„ ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚ Ø®Ù„Ø§Ù„ 5 Ø¯Ù‚Ø§Ø¦Ù‚`
            );

            setTimeout(() => {
                if (ctx.session.step === 'awaiting_verification') {
                    ctx.session.verificationCode = null;
                    ctx.session.step = 'start';
                }
            }, 5 * 60 * 1000);

        }
        // ğŸ” STEP 2: Verify Code
        else if (session.step === 'awaiting_verification' && /^\d{6}$/.test(text)) {
            if (parseInt(text) === ctx.session.verificationCode) {
                
                const userData = {
                    user_id: userId,
                    username: ctx.from.first_name,
                    onexbet: ctx.session.accountId,
                    free_attempts: 2,
                    subscription_status: 'free',
                    subscription_type: 'none',
                    subscription_start_date: null,
                    subscription_end_date: null,
                    joined_at: new Date().toISOString(),
                    total_predictions: 0,
                    correct_predictions: 0,
                    wins: 0,
                    losses: 0,
                    total_bets: 0,
                    total_profit: 0
                };

                await dbManager.saveUser(userId, userData);
                ctx.session.step = 'verified';
                ctx.session.userData = userData;

                await ctx.replyWithMarkdown(
                    `ğŸ‰ *ØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ Ø¨Ù†Ø¬Ø§Ø­!*\n\n` +
                    `âœ… *Ø§Ù„Ø­Ø³Ø§Ø¨:* \`${ctx.session.accountId}\`\n` +
                    `ğŸ‘¤ *Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:* ${ctx.session.userData.username}\n\n` +
                    `ğŸ *ØªØ­ØµÙ„ Ø¹Ù„Ù‰ Ù…Ø­Ø§ÙˆÙ„ØªÙŠÙ† Ù…Ø¬Ø§Ù†ÙŠØªÙŠÙ†*\n\n` +
                    `ğŸ“¸ *ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¢Ù† Ø¥Ø±Ø³Ø§Ù„ ØµÙˆØ±Ø© Ø§Ù„Ù…Ø¨Ø§Ø±Ø§Ø© Ù„Ù„ØªØ­Ù„ÙŠÙ„*`,
                    getMainKeyboard()
                );

            } else {
                await ctx.replyWithMarkdown('âŒ *ÙƒÙˆØ¯ ØªØ­Ù‚Ù‚ Ø®Ø§Ø·Ø¦!*\n\nğŸ” ÙŠØ±Ø¬Ù‰ Ø¥Ø¹Ø§Ø¯Ø© Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„ØµØ­ÙŠØ­');
            }
        }
        // ğŸ’³ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ø¯ÙØ¹ - Ø·Ù„Ø¨ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨
        else if (session.awaitingPaymentAccount) {
            if (/^\d{10}$/.test(text)) {
                const userData = await dbManager.getUser(userId);
                userData.onexbet = text;
                await dbManager.saveUser(userId, userData);
                
                ctx.session.awaitingPaymentAccount = false;
                ctx.session.paymentAccount = text;
                
                await ctx.replyWithMarkdown(
                    `âœ… *ØªÙ… Ø­ÙØ¸ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨:* \`${text}\`\n\n` +
                    `ğŸ“¸ *Ø§Ù„Ø¢Ù† ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ ØµÙˆØ±Ø© Ø¥Ø«Ø¨Ø§Øª Ø§Ù„Ø¯ÙØ¹*`
                );
            } else {
                await ctx.replyWithMarkdown('âŒ *Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ ØºÙŠØ± ØµØ­ÙŠØ­!*\n\nğŸ”¢ ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet Ù…ÙƒÙˆÙ† Ù…Ù† 10 Ø£Ø±Ù‚Ø§Ù…');
            }
            return;
        }
        // ğŸ¯ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø«Ø§Ø¨ØªØ© Ø¨Ø¹Ø¯ Ø§Ù„ØªØ­Ù‚Ù‚
        else if (session.step === 'verified') {
            const userData = await dbManager.getUser(userId);
            
            if (!userData) {
                await ctx.replyWithMarkdown('âŒ *Ø¬Ù„Ø³Ø© Ù…Ù†ØªÙ‡ÙŠØ©*\n\nğŸ” Ø£Ø±Ø³Ù„ /start Ù„Ù„Ø¨Ø¯Ø¡', getLoginKeyboard());
                return;
            }

            switch (text) {
                case 'ğŸ¯ Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„ØªØ§Ù„ÙŠ':
                    if (session.lastImageUrl) {
                        await handleNextPrediction(ctx, userData);
                    } else {
                        ctx.session.awaitingBetAmount = true;
                        await ctx.replyWithMarkdown(
                            'ğŸ’° *Ø£Ø¯Ø®Ù„ Ù…Ø¨Ù„Øº Ø§Ù„Ø±Ù‡Ø§Ù†:*\n\n' +
                            'ğŸ’µ ÙŠØ±Ø¬Ù‰ ÙƒØªØ§Ø¨Ø© Ø§Ù„Ù…Ø¨Ù„Øº Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ø§Ù„Ø±Ù‡Ø§Ù† Ø¹Ù„ÙŠÙ‡ (Ø¨Ø§Ù„Ø¯ÙˆÙ„Ø§Ø±)\n' +
                            'ğŸ“ Ù…Ø«Ø§Ù„: 10 Ø£Ùˆ 25.5'
                        );
                    }
                    break;

                case 'ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§ØªÙŠ':
                    await handleUserStats(ctx, userData);
                    break;

                case 'ğŸ‘¥ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØª':
                    await handleBotStats(ctx);
                    break;

                case 'ğŸ“¸ Ø¥Ø±Ø³Ø§Ù„ ØµÙˆØ±Ø©':
                    await ctx.replyWithMarkdown(
                        'ğŸ“¸ *ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ ØµÙˆØ±Ø© Ø§Ù„Ù…Ø¨Ø§Ø±Ø§Ø© Ø§Ù„Ø¢Ù†*\n\n' +
                        'ğŸ¯ *Ø´Ø±ÙˆØ· Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ù…Ù‚Ø¨ÙˆÙ„Ø©:*\n' +
                        'â€¢ ÙŠØ¬Ø¨ Ø£Ù† ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ÙƒÙ„Ù…Ø§Øª Ù…ØªØ¹Ù„Ù‚Ø© Ø¨Ø§Ù„Ù„Ø¹Ø¨Ø© (Goal, Ù‡Ø¯Ù, Ø±Ù‡Ø§Ù†, Ù…Ø¨Ø§Ø±Ø§Ø©, Ù…ÙŠØ³ÙŠ, Ø±ÙˆÙ†Ø§Ù„Ø¯Ùˆ, Ø¥Ù„Ø®)\n' + 
                        'â€¢ ÙŠÙ…ÙƒÙ† Ø£Ù† ØªÙƒÙˆÙ† Ø§Ù„ØµÙˆØ±Ø© Ø¨Ø£ÙŠ Ø­Ø¬Ù… Ø£Ùˆ Ø¬ÙˆØ¯Ø©\n' +
                        'â€¢ Ø³ÙŠØªÙ… ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹',
                        getMainKeyboard()
                    );
                    break;

                case 'ğŸ’³ Ø§Ù„Ø§Ø´ØªØ±Ø§ÙƒØ§Øª':
                    await handleSubscriptions(ctx, userData);
                    break;

                case 'ğŸ‘¤ Ø­Ø§Ù„Ø© Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ':
                    await handleSubscriptionStatus(ctx, userData);
                    break;

                case 'ğŸ†˜ Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ':
                    await ctx.replyWithMarkdown(
                        `ğŸ†˜ *Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ*\n\n` +
                        `ğŸ“ Ù„Ù„Ø§Ø³ØªÙØ³Ø§Ø±Ø§Øª ÙˆØ§Ù„Ø¯Ø¹Ù…:\n` +
                        `ğŸ‘¤ ${CONFIG.DEVELOPER}\n` +
                        `ğŸ“¢ ${CONFIG.CHANNEL}\n\n` +
                        `â° Ù…ØªØ§Ø­ÙˆÙ† 24/7 Ù„Ø®Ø¯Ù…ØªÙƒÙ…`,
                        getMainKeyboard()
                    );
                    break;

                case 'ğŸ”™ Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø©':
                    await ctx.replyWithMarkdown('ğŸ”™ *Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©*', getMainKeyboard());
                    break;

                default:
                    if (text.startsWith('ğŸ’° ')) {
                        await handleSubscriptionSelection(ctx, userData, text);
                    } else {
                        await ctx.replyWithMarkdown('ğŸ”™ *Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©*', getMainKeyboard());
                    }
                    break;
            }
        }
        // ğŸ” Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…Ø³Ø¬Ù„ ÙˆØ­Ø§ÙˆÙ„ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø£Ø²Ø±Ø§Ø±
        else if (['ğŸ¯ Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„ØªØ§Ù„ÙŠ', 'ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§ØªÙŠ', 'ğŸ“¸ Ø¥Ø±Ø³Ø§Ù„ ØµÙˆØ±Ø©', 'ğŸ‘¥ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØª'].includes(text)) {
            await ctx.replyWithMarkdown(
                'âŒ *ÙŠØ¬Ø¨ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø£ÙˆÙ„Ø§Ù‹*\n\n' +
                'ğŸ” Ø£Ø±Ø³Ù„ /start Ù„ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„',
                getLoginKeyboard()
            );
        } else {
            await ctx.replyWithMarkdown('ğŸ”™ *Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©*', getMainKeyboard());
        }

    } catch (error) {
        console.error('Text handler error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹', getMainKeyboard());
    }
});

// ğŸ–¼ï¸ IMAGE ANALYSIS HANDLER - Ù…Ø¹Ø¯Ù„ Ù„Ù„ØªØ­Ù‚Ù‚ Ø§Ù„Ù…Ø±Ù† Ù…Ù† Ø§Ù„ØµÙˆØ±
bot.on('photo', async (ctx) => {
    try {
        const userId = ctx.from.id.toString();
        const session = ctx.session;
        
        // ğŸ’³ Ù…Ø¹Ø§Ù„Ø¬Ø© ØµÙˆØ± Ø§Ù„Ø¯ÙØ¹
        if (session.paymentType) {
            await handlePaymentScreenshot(ctx, userId);
            return;
        }

        const userData = await dbManager.getUser(userId);
        if (!userData || !userData.onexbet) {
            await ctx.replyWithMarkdown('âŒ *ÙŠØ¬Ø¨ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø³Ø§Ø¨ Ø£ÙˆÙ„Ø§Ù‹*\n\nğŸ” Ø£Ø±Ø³Ù„ /start Ù„Ù„Ø¨Ø¯Ø¡', getLoginKeyboard());
            return;
        }

        // ğŸ” Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠØ© Ø£Ùˆ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ
        if (userData.subscription_status !== 'active' && userData.free_attempts <= 0) {
            await ctx.replyWithMarkdown(
                'ğŸš« *Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠØ©*\n\n' +
                'ğŸ’³ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ù„Ù„Ù…ØªØ§Ø¨Ø¹Ø© ÙÙŠ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø®Ø¯Ù…Ø©',
                getMainKeyboard()
            );
            return;
        }

        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ù…Ø¨Ù„Øº Ø§Ù„Ø±Ù‡Ø§Ù†
        if (!session.currentBet || session.currentBet <= 0) {
            await ctx.replyWithMarkdown(
                'âŒ *ÙŠØ¬Ø¨ ØªØ­Ø¯ÙŠØ¯ Ù…Ø¨Ù„Øº Ø§Ù„Ø±Ù‡Ø§Ù† Ø£ÙˆÙ„Ø§Ù‹*\n\n' +
                'ğŸ’° Ø§Ø³ØªØ®Ø¯Ù… Ø²Ø± "ğŸ¯ Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„ØªØ§Ù„ÙŠ" Ù„ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…Ø¨Ù„Øº',
                getMainKeyboard()
            );
            return;
        }

        // ğŸ“¸ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø©
        const photo = ctx.message.photo[ctx.message.photo.length - 1];
        const fileLink = await bot.telegram.getFileLink(photo.file_id);
        const imageUrl = fileLink.href;

        // Ø­ÙØ¸ Ø±Ø§Ø¨Ø· Ø§Ù„ØµÙˆØ±Ø© ÙÙŠ Ø§Ù„Ø¬Ù„Ø³Ø© Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù„Ø§Ø­Ù‚Ø§Ù‹
        ctx.session.lastImageUrl = imageUrl;

        const processingMsg = await ctx.reply('ğŸ” Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØµÙˆØ±Ø©...');

        try {
            // ğŸ” Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„Ù…Ø±Ù† Ù…Ù† ØµØ­Ø© Ø§Ù„ØµÙˆØ±Ø©
            const verificationResult = await imageVerification.verifyImage(imageUrl);

            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù†ØªÙŠØ¬Ø© Ø§Ù„ØªØ­Ù‚Ù‚
            if (verificationResult.decision === "REJECT") {
                await ctx.replyWithMarkdown(
                    `âŒ *Ù„Ù… ÙŠØªÙ… Ù‚Ø¨ÙˆÙ„ Ø§Ù„ØµÙˆØ±Ø©*\n\n` +
                    `ğŸ“¸ *Ø³Ø¨Ø¨ Ø§Ù„Ø±ÙØ¶:* ${verificationResult.reason}\n\n` +
                    `ğŸ’¡ *ØªÙØ§ØµÙŠÙ„ Ø§Ù„ØªØ­Ù‚Ù‚:*\n` +
                    `ğŸ‘¥ Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ø´Ø®Ø§Øµ Ø§Ù„Ù…ÙƒØªØ´ÙÙŠÙ†: ${verificationResult.persons_count || 0}\n` +
                    `ğŸ”¤ Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…Ù‚Ø¨ÙˆÙ„Ø©: ${verificationResult.keywords_found?.join(', ') || 'Ù„Ø§ ØªÙˆØ¬Ø¯'}\n\n` +
                    `ğŸ“ *ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ ØµÙˆØ±Ø© ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰:*\n` +
                    `â€¢ ÙƒÙ„Ù…Ø§Øª Ù…ØªØ¹Ù„Ù‚Ø© Ø¨Ø§Ù„Ù„Ø¹Ø¨Ø© (Goal, Ù‡Ø¯Ù, Ø±Ù‡Ø§Ù†, Ù…Ø¨Ø§Ø±Ø§Ø©, Ù…ÙŠØ³ÙŠ, Ø±ÙˆÙ†Ø§Ù„Ø¯Ùˆ, Ø¥Ù„Ø®)\n` +
                    `â€¢ ÙŠÙ…ÙƒÙ† Ø£Ù† ØªÙƒÙˆÙ† Ø§Ù„ØµÙˆØ±Ø© Ø¨Ø£ÙŠ Ø­Ø¬Ù… Ø£Ùˆ Ø¬ÙˆØ¯Ø©`
                );
                await ctx.deleteMessage(processingMsg.message_id);
                return;
            } else {
                await ctx.replyWithMarkdown(
                    `âœ… *ØªÙ… Ù‚Ø¨ÙˆÙ„ Ø§Ù„ØµÙˆØ±Ø© Ø¨Ù†Ø¬Ø§Ø­*\n\n` +
                    `ğŸ“¸ ${verificationResult.reason}\n` +
                    `ğŸ‘¥ Ø§Ù„Ø£Ø´Ø®Ø§Øµ: ${verificationResult.persons_count}\n` +
                    `ğŸ”¤ Ø§Ù„ÙƒÙ„Ù…Ø§Øª: ${verificationResult.keywords_found?.join(', ') || 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ'}\n\n` +
                    `ğŸ”„ Ø¬Ø§Ø±ÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ø¨Ø§Ø±Ø§Ø© Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ...`
                );
            }

            // Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ø¨Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¹Ø§Ø¯ÙŠ
            await ctx.editMessageText(processingMsg.message_id, 'ğŸ”„ Ø¬Ø§Ø±ÙŠ ØªØ­Ù„ÙŠÙ„ ØµÙˆØ±Ø© Ø§Ù„Ù…Ø¨Ø§Ø±Ø§Ø© Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ...');

            const prediction = await goalAI.analyzeImageWithAI(imageUrl);
            
            // ğŸ“Š ØªØ­Ø¯ÙŠØ« Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
            if (userData.subscription_status !== 'active') {
                userData.free_attempts--;
            }
            userData.total_predictions = (userData.total_predictions || 0) + 1;
            userData.total_bets = (userData.total_bets || 0) + session.currentBet;
            userData.lastPrediction = prediction;
            await dbManager.saveUser(userId, userData);

            const analysisMessage = `
ğŸ¤– *ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ø§Ù„Ù…ØªÙ‚Ø¯Ù… - v${CONFIG.VERSION}*

ğŸ“¸ *Ø§Ù„ØµÙˆØ±Ø©:* âœ… ØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ ÙˆØ§Ù„ØªØ­Ù„ÙŠÙ„ Ø¨Ù†Ø¬Ø§Ø­
ğŸ•’ *Ø§Ù„ÙˆÙ‚Øª:* ${new Date().toLocaleString('ar-EG')}
ğŸ” *Ø§Ù„Ø­Ø³Ø§Ø¨:* \`${userData.onexbet}\`
ğŸ’° *Ù…Ø¨Ù„Øº Ø§Ù„Ø±Ù‡Ø§Ù†:* ${session.currentBet}$

ğŸ¯ *Ù†ØªÙŠØ¬Ø© Ø§Ù„ØªØ­Ù„ÙŠÙ„:*
${prediction.type}
ğŸ“ˆ *Ø§Ù„Ø§Ø­ØªÙ…Ø§Ù„ÙŠØ©:* ${prediction.probability}%
ğŸ¯ *Ø§Ù„Ø«Ù‚Ø©:* ${prediction.confidence}%

ğŸ’¡ *Ø§Ù„ØªØ­Ù„ÙŠÙ„:*
${prediction.reasoning}

${userData.subscription_status !== 'active' ? 
    `ğŸ†“ *Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„Ù…ØªØ¨Ù‚ÙŠØ©:* ${userData.free_attempts}` : 
    `âœ… *Ø§Ø´ØªØ±Ø§Ùƒ Ù†Ø´Ø· - Ù…Ø­Ø§ÙˆÙ„Ø§Øª ØºÙŠØ± Ù…Ø­Ø¯ÙˆØ¯Ø©*`}
            `;

            await ctx.replyWithMarkdown(analysisMessage);
            
            // Ø¥Ø¶Ø§ÙØ© Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù†ØªÙŠØ¬Ø©
            const resultKeyboard = Markup.inlineKeyboard([
                [
                    Markup.button.callback(`ğŸŠ Ù†Ø¬Ø­ Ø§Ù„ØªÙˆÙ‚Ø¹ - Ø±Ø¨Ø­ ${session.currentBet * 2}$`, `win_${Date.now()}`),
                    Markup.button.callback(`ğŸ”„ Ø®Ø³Ø±Øª - Ø¬Ø±Ø¨ Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„ØªØ§Ù„ÙŠ`, `lose_${Date.now()}`)
                ]
            ]);

            await ctx.replyWithMarkdown(
                'ğŸ“Š *Ù…Ø§ Ù‡ÙŠ Ù†ØªÙŠØ¬Ø© Ø§Ù„ØªÙˆÙ‚Ø¹ØŸ*\n\n' +
                `ğŸŠ *Ù†Ø¬Ø­ Ø§Ù„ØªÙˆÙ‚Ø¹* - ØªØ±Ø¨Ø­ ${session.currentBet * 2}$\n` +
                `ğŸ”„ *Ø®Ø³Ø±Øª* - Ø¬Ø±Ø¨ Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„ØªØ§Ù„ÙŠ Ø¨Ù…Ø¶Ø§Ø¹ÙØ© Ø§Ù„Ø±Ù‡Ø§Ù†\n\n` +
                'âœ¨ Ø³ÙŠØªÙ… ØªØ­Ø¯ÙŠØ« Ø¥Ø­ØµØ§Ø¦ÙŠÙƒ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹',
                resultKeyboard
            );

            await ctx.deleteMessage(processingMsg.message_id);

        } catch (analysisError) {
            console.error('Analysis error:', analysisError);
            
            // ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„Ø®Ø·Ø£ØŒ Ù†Ø¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠ
            const fallbackPrediction = goalAI.generateSmartPrediction(userId);
            
            await ctx.replyWithMarkdown(
                `ğŸ¤– *Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠ - ØªØ­Ù„ÙŠÙ„ ÙÙˆØ±ÙŠ*\n\n` +
                `ğŸ¯ ${fallbackPrediction.type}\n` +
                `ğŸ“ˆ ${fallbackPrediction.probability}% | ğŸ¯ ${fallbackPrediction.confidence}%\n\n` +
                `ğŸ’¡ ${fallbackPrediction.reasoning}`,
                getMainKeyboard()
            );

            await ctx.deleteMessage(processingMsg.message_id);
        }

    } catch (error) {
        console.error('Photo handler error:', error);
        await ctx.replyWithMarkdown('âŒ *Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø©*', getMainKeyboard());
    }
});

// ğŸ¯ HANDLE CALLBACK QUERIES - Ù…Ø¹Ø¯Ù„ Ù„Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ø®Ø³Ø§Ø±Ø©
bot.on('callback_query', async (ctx) => {
    try {
        const callbackData = ctx.callbackQuery.data;
        const userId = ctx.from.id.toString();
        
        if (callbackData.startsWith('win_') || callbackData.startsWith('lose_')) {
            const isWin = callbackData.startsWith('win_');
            
            const userData = await dbManager.getUser(userId);
            if (!userData) {
                await ctx.answerCbQuery('âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…');
                return;
            }
            
            if (isWin) {
                const profit = ctx.session.currentBet;
                userData.wins = (userData.wins || 0) + 1;
                userData.correct_predictions = (userData.correct_predictions || 0) + 1;
                userData.total_profit = (userData.total_profit || 0) + profit;
                ctx.session.totalProfit += profit;
                
                await ctx.answerCbQuery(`ğŸŠ Ù…Ø¨Ø±ÙˆÙƒ! Ù†Ø¬Ø­ Ø§Ù„ØªÙˆÙ‚Ø¹ ÙˆØ±Ø¨Ø­Øª ${profit}$`);
                
                await ctx.replyWithMarkdown(
                    `ğŸŠ *Ù…Ø¨Ø±ÙˆÙƒ! Ù†Ø¬Ø­ Ø§Ù„ØªÙˆÙ‚Ø¹ Ø¨Ù†Ø¬Ø§Ø­* âœ¨\n\n` +
                    `âœ… ØªÙˆÙ‚Ø¹Ùƒ ÙƒØ§Ù† Ø¯Ù‚ÙŠÙ‚Ø§Ù‹ ÙˆÙ…Ù…ÙŠØ²Ø§Ù‹\n` +
                    `ğŸ’° Ø±Ø¨Ø­Øª: ${profit}$\n` +
                    `ğŸ’µ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø£Ø±Ø¨Ø§Ø­Ùƒ: ${ctx.session.totalProfit}$\n\n` +
                    `ğŸ¯ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¨Ø¯Ø¡ Ø¨ØªÙˆÙ‚Ø¹ Ø¬Ø¯ÙŠØ¯`,
                    getMainKeyboard()
                );
                
            } else {
                // Ù…Ø¶Ø§Ø¹ÙØ© Ø§Ù„Ø±Ù‡Ø§Ù† ÙˆØªÙˆÙ„ÙŠØ¯ ØªÙˆÙ‚Ø¹ Ø¬Ø¯ÙŠØ¯ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
                const newBet = ctx.session.currentBet * 2;
                userData.losses = (userData.losses || 0) + 1;
                ctx.session.currentBet = newBet;
                
                await ctx.answerCbQuery(`ğŸ”„ Ø¬Ø§Ø±ÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„ØªØ§Ù„ÙŠ...`);
                
                // ØªÙˆÙ„ÙŠØ¯ ØªÙˆÙ‚Ø¹ Ø¬Ø¯ÙŠØ¯ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
                const newPrediction = goalAI.generateNextPrediction(userId);
                
                await ctx.replyWithMarkdown(
                    `ğŸ”„ *Ø®Ø³Ø±Øª Ù‡Ø°Ù‡ Ø§Ù„Ø¬ÙˆÙ„Ø©*\n\n` +
                    `ğŸ“ˆ Ø§Ù„Ø±Ù‡Ø§Ù† Ø§Ù„ØªØ§Ù„ÙŠ Ù…Ø¶Ø§Ø¹Ù: ${newBet}$\n` +
                    `ğŸ’ª Ù„Ø§ ØªÙˆÙ‚Ù.. Ø§Ø³ØªÙ…Ø± ÙÙŠ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©\n\n` +
                    `ğŸ¯ *Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„ØªØ§Ù„ÙŠ:*\n` +
                    `${newPrediction.type}\n` +
                    `ğŸ“ˆ ${newPrediction.probability}% | ğŸ¯ ${newPrediction.confidence}%\n` +
                    `ğŸ’¡ ${newPrediction.reasoning}`,
                    getMainKeyboard()
                );
                
                // Ø¥Ø¶Ø§ÙØ© Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù†ØªÙŠØ¬Ø© Ù„Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„Ø¬Ø¯ÙŠØ¯
                const resultKeyboard = Markup.inlineKeyboard([
                    [
                        Markup.button.callback(`ğŸŠ Ù†Ø¬Ø­ Ø§Ù„ØªÙˆÙ‚Ø¹ - Ø±Ø¨Ø­ ${newBet * 2}$`, `win_${Date.now()}`),
                        Markup.button.callback(`ğŸ”„ Ø®Ø³Ø±Øª - Ø¬Ø±Ø¨ Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„ØªØ§Ù„ÙŠ`, `lose_${Date.now()}`)
                    ]
                ]);

                await ctx.replyWithMarkdown(
                    'ğŸ“Š *Ù…Ø§ Ù‡ÙŠ Ù†ØªÙŠØ¬Ø© Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„Ø¬Ø¯ÙŠØ¯ØŸ*',
                    resultKeyboard
                );
            }
            
            await dbManager.saveUser(userId, userData);
            
            try {
                await ctx.deleteMessage(ctx.callbackQuery.message.message_id);
            } catch (deleteError) {
                console.log('Could not delete message:', deleteError);
            }
        }
        
        // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù‚Ø¨ÙˆÙ„ ÙˆØ§Ù„Ø±ÙØ¶ ÙÙŠ Ø§Ù„Ø¥Ø¯Ù…Ù†
        else if (callbackData.startsWith('accept_')) {
            const paymentId = callbackData.split('_')[1];
            await handlePaymentAccept(ctx, paymentId);
        }
        else if (callbackData.startsWith('reject_')) {
            const paymentId = callbackData.split('_')[1];
            await handlePaymentReject(ctx, paymentId);
        }
        
    } catch (error) {
        console.error('Callback query error:', error);
        await ctx.answerCbQuery('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©');
    }
});

// ğŸ¯ Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ø¯ÙˆØ§Ù„ (handleNextPrediction, handleUserStats, handleBotStats, handleSubscriptions, etc.)
// ØªØ¨Ù‚Ù‰ ÙƒÙ…Ø§ Ù‡ÙŠ Ø¨Ø¯ÙˆÙ† ØªØºÙŠÙŠØ±...

// ğŸš€ START BOT
bot.launch().then(() => {
    console.log('ğŸ‰ SUCCESS! AI GOAL Predictor v10.4 is RUNNING!');
    console.log('ğŸ‘¤ Developer:', CONFIG.DEVELOPER);
    console.log('ğŸ“¢ Channel:', CONFIG.CHANNEL);
    console.log('ğŸŒ Health check: http://localhost:' + PORT);
    console.log('ğŸ”§ Admin ID:', CONFIG.ADMIN_ID);
    console.log('ğŸ–¼ï¸ FLEXIBLE Image verification system: ACTIVE');
}).catch(console.error);

// âš¡ Graceful shutdown
process.once('SIGINT', () => bot.stop('SIGINT'));
process.once('SIGTERM', () => bot.stop('SIGTERM'));

console.log('âœ… AI Goal Prediction System Ready!');
