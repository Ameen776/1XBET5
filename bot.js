// ===================================================
// ğŸš€ AI GOAL PREDICTOR ULTIMATE - VERSION 16.0 FIXED
// ğŸ‘¤ DEVELOPER: â™›ğ‘¨ğ’ğ’†ğ’†ğ’ ğ‘¨ğ’ğ’›ğ’˜ğ’‚ğ’‰ğ’Šâ™›
// ğŸ”¥ FEATURES: DUAL PAYMENT SYSTEM + BANK TRANSFER + BINANCE
// ğŸ’¾ PERSISTENT DATA STORAGE WITH FIREBASE
// ===================================================

console.log('ğŸ¤– Starting AI GOAL Predictor Ultimate v16.0 FIXED...');
console.log('ğŸ•’ ' + new Date().toISOString());

// ğŸ”§ CONFIGURATION - UPDATED FOR DUAL PAYMENT
const CONFIG = {
    BOT_TOKEN: process.env.BOT_TOKEN || "8125363786:AAFZaOGSAvq_p8Sc8cq2bIKZlpe4ej7tmdU",
    ADMIN_ID: process.env.ADMIN_ID || "6565594143",
    CHANNEL_ID: process.env.CHANNEL_ID || "-1003283663811",
    CHANNEL_USERNAME: process.env.CHANNEL_USERNAME || "@GEMZGOOL",
    
    // ğŸ§  AI APIS
    AI_APIS: {
        GEMINI: process.env.GEMINI_API_KEY || "AIzaSyCtjtT98-M5v6t8qICPSDw-1TLwPneyaQc",
        OPENAI: process.env.OPENAI_API_KEY || "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"
    },

    // ğŸ’° DEFAULT PRICING - DUAL SYSTEM
    SUBSCRIPTION_PRICES: {
        binance: {
            week: 10,
            month: 30,
            three_months: 80,
            year: 250
        },
        bank: {
            week: 10,
            month: 30, 
            three_months: 80,
            year: 250
        }
    },

    // ğŸ” DEFAULT PAYMENT LINKS - DUAL SYSTEM
    PAYMENT_LINKS: {
        binance: {
            week: process.env.PAYMENT_WEEK || "https://binance.com/payment/weekly",
            month: process.env.PAYMENT_MONTH || "https://binance.com/payment/monthly", 
            three_months: process.env.PAYMENT_3MONTHS || "https://binance.com/payment/3months",
            year: process.env.PAYMENT_YEAR || "https://binance.com/payment/yearly"
        },
        bank: {
            week: {
                account: "1234567890",
                image: "https://i.ibb.co/default-bank-week.jpg",
                description: "ğŸ”¹ ØªØ­ÙˆÙŠÙ„ Ø¨Ù†ÙƒÙŠ - Ø¨Ø§Ù‚Ø© Ø£Ø³Ø¨ÙˆØ¹ÙŠØ©\nğŸ’³ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨: 1234567890\nğŸ¦ Ø§Ù„Ø¨Ù†Ùƒ: Ø§Ù„Ø¨Ù†Ùƒ Ø§Ù„ÙƒØ±ÙŠÙ…ÙŠ\nğŸ’° Ø§Ù„Ù…Ø¨Ù„Øº: 10$\nğŸ’µ Ø§Ù„Ø¹Ù…Ù„Ø©: Ø§Ù„Ø¯ÙˆÙ„Ø§Ø± Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠ\n\nğŸ“‹ Ø§Ù„Ø´Ø±ÙˆØ·:\nâ€¢ ÙŠØ¬Ø¨ Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø¨Ø§Ù„Ø¯ÙˆÙ„Ø§Ø± Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠ\nâ€¢ Ø¥Ø±ÙØ§Ù‚ ØµÙˆØ±Ø© Ø¥Ø«Ø¨Ø§Øª Ø§Ù„Ø¯ÙØ¹\nâ€¢ ÙƒØªØ§Ø¨Ø© Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ"
            },
            month: {
                account: "1234567890",
                image: "https://i.ibb.co/default-bank-month.jpg", 
                description: "ğŸ”¹ ØªØ­ÙˆÙŠÙ„ Ø¨Ù†ÙƒÙŠ - Ø¨Ø§Ù‚Ø© Ø´Ù‡Ø±ÙŠØ©\nğŸ’³ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨: 1234567890\nğŸ¦ Ø§Ù„Ø¨Ù†Ùƒ: Ø§Ù„Ø¨Ù†Ùƒ Ø§Ù„ÙƒØ±ÙŠÙ…ÙŠ\nğŸ’° Ø§Ù„Ù…Ø¨Ù„Øº: 30$\nğŸ’µ Ø§Ù„Ø¹Ù…Ù„Ø©: Ø§Ù„Ø¯ÙˆÙ„Ø§Ø± Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠ\n\nğŸ“‹ Ø§Ù„Ø´Ø±ÙˆØ·:\nâ€¢ ÙŠØ¬Ø¨ Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø¨Ø§Ù„Ø¯ÙˆÙ„Ø§Ø± Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠ\nâ€¢ Ø¥Ø±ÙØ§Ù‚ ØµÙˆØ±Ø© Ø¥Ø«Ø¨Ø§Øª Ø§Ù„Ø¯ÙØ¹\nâ€¢ ÙƒØªØ§Ø¨Ø© Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ"
            },
            three_months: {
                account: "1234567890",
                image: "https://i.ibb.co/default-bank-3months.jpg",
                description: "ğŸ”¹ ØªØ­ÙˆÙŠÙ„ Ø¨Ù†ÙƒÙŠ - Ø¨Ø§Ù‚Ø© 3 Ø£Ø´Ù‡Ø±\nğŸ’³ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨: 1234567890\nğŸ¦ Ø§Ù„Ø¨Ù†Ùƒ: Ø§Ù„Ø¨Ù†Ùƒ Ø§Ù„ÙƒØ±ÙŠÙ…ÙŠ\nğŸ’° Ø§Ù„Ù…Ø¨Ù„Øº: 80$\nğŸ’µ Ø§Ù„Ø¹Ù…Ù„Ø©: Ø§Ù„Ø¯ÙˆÙ„Ø§Ø± Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠ\n\nğŸ“‹ Ø§Ù„Ø´Ø±ÙˆØ·:\nâ€¢ ÙŠØ¬Ø¨ Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø¨Ø§Ù„Ø¯ÙˆÙ„Ø§Ø± Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠ\nâ€¢ Ø¥Ø±ÙØ§Ù‚ ØµÙˆØ±Ø© Ø¥Ø«Ø¨Ø§Øª Ø§Ù„Ø¯ÙØ¹\nâ€¢ ÙƒØªØ§Ø¨Ø© Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ"
            },
            year: {
                account: "1234567890",
                image: "https://i.ibb.co/default-bank-year.jpg",
                description: "ğŸ”¹ ØªØ­ÙˆÙŠÙ„ Ø¨Ù†ÙƒÙŠ - Ø¨Ø§Ù‚Ø© Ø³Ù†ÙˆÙŠØ©\nğŸ’³ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨: 1234567890\nğŸ¦ Ø§Ù„Ø¨Ù†Ùƒ: Ø§Ù„Ø¨Ù†Ùƒ Ø§Ù„ÙƒØ±ÙŠÙ…ÙŠ\nğŸ’° Ø§Ù„Ù…Ø¨Ù„Øº: 250$\nğŸ’µ Ø§Ù„Ø¹Ù…Ù„Ø©: Ø§Ù„Ø¯ÙˆÙ„Ø§Ø± Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠ\n\nğŸ“‹ Ø§Ù„Ø´Ø±ÙˆØ·:\nâ€¢ ÙŠØ¬Ø¨ Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø¨Ø§Ù„Ø¯ÙˆÙ„Ø§Ø± Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠ\nâ€¢ Ø¥Ø±ÙØ§Ù‚ ØµÙˆØ±Ø© Ø¥Ø«Ø¨Ø§Øª Ø§Ù„Ø¯ÙØ¹\nâ€¢ ÙƒØªØ§Ø¨Ø© Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ"
            }
        }
    },
    
    VERSION: "16.0.0",
    DEVELOPER: "â™›ğ‘¨ğ’ğ’†ğ’†ğ’ ğ‘¨ğ’ğ’›ğ’˜ğ’‚ğ’‰ğ’Šâ™›",
    CHANNEL: "@GEMZGOOL",
    START_IMAGE: "https://i.ibb.co/tpy70Bd1/IMG-20251104-074214-065.jpg",
    ANALYSIS_IMAGE: "https://i.ibb.co/VYjf05S0/Screenshot.png",
    PREDICTION_IMAGE: "https://i.ibb.co/rGTZm2mB/IMG.jpg",
    IMGBB_API_KEY: process.env.IMGBB_API_KEY || "42b155a527bee21e62e524a31fe9b1ee"
};

console.log('âœ… Dual Payment Configuration loaded successfully');

// ğŸš€ INITIALIZE BOT
const { Telegraf, Markup, session } = require('telegraf');
const axios = require('axios');
const express = require('express');

const bot = new Telegraf(CONFIG.BOT_TOKEN);

// ğŸŒ HEALTH CHECK SERVER FOR RENDER
const app = express();
const PORT = process.env.PORT || 3000;

app.use(express.json());

app.get('/', (req, res) => {
    res.json({ 
        status: 'OK', 
        version: CONFIG.VERSION,
        timestamp: new Date().toISOString(),
        message: 'AI Goal Predictor Bot is running...',
        developer: CONFIG.DEVELOPER
    });
});

// ğŸ”„ KEEP ALIVE ENDPOINT FOR RENDER
app.get('/keep-alive', (req, res) => {
    res.json({ 
        status: 'ALIVE', 
        timestamp: new Date().toISOString(),
        message: 'Bot is alive and running'
    });
});

app.listen(PORT, () => {
    console.log(`ğŸŒ Health check server running on port ${PORT}`);
    console.log(`ğŸ”„ Keep alive endpoint: http://localhost:${PORT}/keep-alive`);
});

// ğŸ”¥ FIREBASE INITIALIZATION
const admin = require('firebase-admin');

// Initialize Firebase
try {
    const serviceAccount = {
        type: "service_account",
        project_id: process.env.FIREBASE_PROJECT_ID,
        private_key: process.env.FIREBASE_PRIVATE_KEY?.replace(/\\n/g, '\n'),
        client_email: process.env.FIREBASE_CLIENT_EMAIL,
    };

    if (!admin.apps.length) {
        admin.initializeApp({
            credential: admin.credential.cert(serviceAccount),
            databaseURL: "https://bot-tlegram-9f4b5-default-rtdb.firebaseio.com"
        });
    }
    
    console.log('âœ… Firebase initialized successfully');
} catch (error) {
    console.error('âŒ Firebase initialization failed:', error);
}

const db = admin.firestore();

// ğŸ—„ï¸ FIREBASE DATABASE MANAGER
class FirebaseDatabaseManager {
    constructor() {
        this.maintenanceMode = false;
    }

    async getUser(userId) {
        try {
            const userDoc = await db.collection('users').doc(userId.toString()).get();
            if (userDoc.exists) {
                return userDoc.data();
            }
            return null;
        } catch (error) {
            console.error('Get user error:', error);
            return null;
        }
    }

    async saveUser(userId, userData) {
        try {
            const completeUserData = {
                user_id: userId,
                username: userData.username || 'Unknown',
                first_name: userData.first_name || '',
                onexbet: userData.onexbet || '',
                country: userData.country || '',
                free_attempts: userData.free_attempts || 0,
                subscription_status: userData.subscription_status || 'free',
                subscription_type: userData.subscription_type || 'none',
                subscription_start_date: userData.subscription_start_date || null,
                subscription_end_date: userData.subscription_end_date || null,
                joined_at: userData.joined_at || new Date().toISOString(),
                total_predictions: userData.total_predictions || 0,
                correct_predictions: userData.correct_predictions || 0,
                wins: userData.wins || 0,
                losses: userData.losses || 0,
                total_bets: userData.total_bets || 0,
                total_profit: userData.total_profit || 0,
                last_updated: new Date().toISOString(),
                channel_subscribed: userData.channel_subscribed || false,
                step: userData.step || 'start',
                session_data: userData.session_data || {}
            };

            await db.collection('users').doc(userId.toString()).set(completeUserData, { merge: true });
            return true;
        } catch (error) {
            console.error('Error saving user:', error);
            return false;
        }
    }

    async updateUserSession(userId, step, sessionData = {}) {
        try {
            const updateData = {
                step: step,
                last_updated: new Date().toISOString()
            };

            if (Object.keys(sessionData).length > 0) {
                updateData.session_data = sessionData;
            }

            await db.collection('users').doc(userId.toString()).update(updateData);
            return true;
        } catch (error) {
            console.error('Update user session error:', error);
            return false;
        }
    }

    async getSettings() {
        try {
            const settingsDoc = await db.collection('settings').doc('config').get();
            if (settingsDoc.exists) {
                return settingsDoc.data();
            }
            
            return {
                prices: { 
                    binance: { ...CONFIG.SUBSCRIPTION_PRICES.binance },
                    bank: { ...CONFIG.SUBSCRIPTION_PRICES.bank }
                },
                payment_links: { 
                    binance: { ...CONFIG.PAYMENT_LINKS.binance },
                    bank: { ...CONFIG.PAYMENT_LINKS.bank }
                },
                maintenance_mode: false,
                updated_at: new Date().toISOString()
            };
        } catch (error) {
            console.error('Get settings error:', error);
            return {
                prices: { 
                    binance: { ...CONFIG.SUBSCRIPTION_PRICES.binance },
                    bank: { ...CONFIG.SUBSCRIPTION_PRICES.bank }
                },
                payment_links: { 
                    binance: { ...CONFIG.PAYMENT_LINKS.binance },
                    bank: { ...CONFIG.PAYMENT_LINKS.bank }
                },
                maintenance_mode: false,
                updated_at: new Date().toISOString()
            };
        }
    }

    async updateSettings(newSettings) {
        try {
            const updatedSettings = {
                ...newSettings,
                updated_at: new Date().toISOString()
            };

            await db.collection('settings').doc('config').set(updatedSettings, { merge: true });
            return updatedSettings;
        } catch (error) {
            console.error('Update settings error:', error);
            return null;
        }
    }

    async getAllUsers() {
        try {
            const usersSnapshot = await db.collection('users').get();
            return usersSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        } catch (error) {
            console.error('Get all users error:', error);
            return [];
        }
    }

    async addPayment(paymentData) {
        try {
            const paymentId = Date.now().toString();
            const fullPaymentData = {
                ...paymentData,
                id: paymentId,
                status: 'pending',
                timestamp: new Date().toISOString()
            };

            await db.collection('payments').doc(paymentId).set(fullPaymentData);
            return paymentId;
        } catch (error) {
            console.error('Add payment error:', error);
            return null;
        }
    }

    async updatePayment(paymentId, updates) {
        try {
            await db.collection('payments').doc(paymentId).update(updates);
            return true;
        } catch (error) {
            console.error('Update payment error:', error);
            return false;
        }
    }

    async getPayment(paymentId) {
        try {
            const paymentDoc = await db.collection('payments').doc(paymentId).get();
            if (paymentDoc.exists) {
                return paymentDoc.data();
            }
            return null;
        } catch (error) {
            console.error('Get payment error:', error);
            return null;
        }
    }

    async getAllPayments() {
        try {
            const paymentsSnapshot = await db.collection('payments').get();
            return paymentsSnapshot.docs.map(doc => doc.data());
        } catch (error) {
            console.error('Get all payments error:', error);
            return [];
        }
    }

    async getPendingPayments() {
        try {
            const payments = await this.getAllPayments();
            return payments.filter(p => p.status === 'pending');
        } catch (error) {
            console.error('Get pending payments error:', error);
            return [];
        }
    }

    async getUserByOneXBet(onexbet) {
        try {
            const usersSnapshot = await db.collection('users').where('onexbet', '==', onexbet).get();
            if (!usersSnapshot.empty) {
                return usersSnapshot.docs[0].data();
            }
            return null;
        } catch (error) {
            console.error('Get user by onexbet error:', error);
            return null;
        }
    }

    async searchUsers(query) {
        try {
            const users = await this.getAllUsers();
            const lowerQuery = query.toLowerCase();
            
            return users.filter(user => 
                (user.user_id && user.user_id.toString().includes(query)) ||
                (user.username && user.username.toLowerCase().includes(lowerQuery)) ||
                (user.onexbet && user.onexbet.toString().includes(query))
            );
        } catch (error) {
            console.error('Search users error:', error);
            return [];
        }
    }

    async setChannelSubscription(userId, subscribed) {
        try {
            await db.collection('users').doc(userId.toString()).update({
                channel_subscribed: subscribed,
                last_updated: new Date().toISOString()
            });
            return true;
        } catch (error) {
            console.error('Set channel subscription error:', error);
            return false;
        }
    }

    async getAllStats() {
        try {
            const users = await this.getAllUsers();
            const payments = await this.getAllPayments();
            
            const activeUsers = users.filter(u => u.subscription_status === 'active');
            const freeUsers = users.filter(u => u.subscription_status === 'free');
            
            const totalPredictions = users.reduce((sum, user) => sum + (user.total_predictions || 0), 0);
            const totalProfit = users.reduce((sum, user) => sum + (user.total_profit || 0), 0);
            const totalBets = users.reduce((sum, user) => sum + (user.total_bets || 0), 0);
            
            return {
                totalUsers: users.length,
                activeUsers: activeUsers.length,
                freeUsers: freeUsers.length,
                totalPredictions,
                totalProfit,
                totalBets,
                totalPayments: payments.length,
                pendingPayments: payments.filter(p => p.status === 'pending').length
            };
        } catch (error) {
            console.error('Get all stats error:', error);
            return {
                totalUsers: 0,
                activeUsers: 0,
                freeUsers: 0,
                totalPredictions: 0,
                totalProfit: 0,
                totalBets: 0,
                totalPayments: 0,
                pendingPayments: 0
            };
        }
    }

    async setMaintenanceMode(enabled) {
        try {
            const settings = await this.getSettings();
            settings.maintenance_mode = enabled;
            await this.updateSettings(settings);
            this.maintenanceMode = enabled;
            return true;
        } catch (error) {
            console.error('Set maintenance mode error:', error);
            return false;
        }
    }

    isMaintenanceMode() {
        return this.maintenanceMode;
    }
}

// INITIALIZE DATABASE MANAGER
const dbManager = new FirebaseDatabaseManager();

// ğŸ“Š DYNAMIC STATISTICS SYSTEM
class DynamicStatistics {
    constructor() {
        this.totalUsers = 78542;
        this.activeUsers = 300;
        this.lastCallTime = Date.now();
        this.callCount = 0;
    }

    getStats() {
        const now = Date.now();
        
        // Ø²ÙŠØ§Ø¯Ø© Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù†Ø´Ø·ÙŠÙ† Ø¹Ù†Ø¯ ÙƒÙ„ Ø·Ù„Ø¨ Ù…Ø¨Ø§Ø´Ø±Ø©
        this.callCount++;
        
        // Ø²ÙŠØ§Ø¯Ø© Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© Ø¨ÙŠÙ† 1-5 Ø¹Ù†Ø¯ ÙƒÙ„ Ø·Ù„Ø¨
        const randomIncrement = Math.floor(Math.random() * 5) + 1;
        this.activeUsers += randomIncrement;
        
        // Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ 5000 Ø«Ù… Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù€ 300
        if (this.activeUsers > 5000) {
            this.activeUsers = 300;
        }
        
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙˆÙ‚Øª Ø¹Ù†Ø¯ ÙƒÙ„ Ø·Ù„Ø¨
        this.lastCallTime = now;

        return {
            totalUsers: this.totalUsers,
            activeUsers: this.activeUsers
        };
    }
}

// ğŸ§  SMART GOAL PREDICTION ENGINE
class GoalPredictionAI {
    constructor() {
        this.algorithmVersion = "16.0";
    }

    generateSmartPrediction(userId) {
        const isGoal = Math.random() > 0.5;
        const probability = Math.floor(Math.random() * 30) + 60;
        
        // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ Ø§Ù„Ø­Ø§Ù„ÙŠ
        const now = new Date();
        const saudiTime = new Date(now.getTime() + (3 * 60 * 60 * 1000)); // ØªÙˆÙ‚ÙŠØª Ø§Ù„Ø³Ø¹ÙˆØ¯ÙŠØ© +3
        const realTime = saudiTime.toLocaleTimeString('ar-SA', { 
            hour: '2-digit', 
            minute: '2-digit',
            second: '2-digit',
            hour12: false 
        });
        
        const prediction = {
            type: isGoal ? 'âš½ GOAL' : 'ğŸ›‘ NO GOAL',
            probability: probability,
            confidence: 100,
            reasoning: isGoal ? 
                `ğŸ”¥ Ø§Ù„Ø¶ØºØ· Ø§Ù„Ù‡Ø¬ÙˆÙ…ÙŠ Ø§Ù„Ù…Ø³ØªÙ…Ø± ÙŠØ´ÙŠØ± Ù„Ù‡Ø¯Ù Ù‚Ø±ÙŠØ¨ Ø¨Ù†Ø³Ø¨Ø© ${probability}%` :
                `ğŸ›¡ï¸ Ø§Ù„Ø¯ÙØ§Ø¹ Ø§Ù„Ù…Ù†Ø¸Ù… ÙŠØ­Ø¯ Ù…Ù† Ø§Ù„ÙØ±Øµ Ø¨Ù†Ø³Ø¨Ø© ${probability}%`,
            timestamp: realTime, // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ
            algorithm: this.algorithmVersion
        };

        return prediction;
    }

    generateNextPrediction(userId) {
        return this.generateSmartPrediction(userId);
    }
}

// ğŸ“¤ IMGBB UPLOADER - ENHANCED
class ImgBBUploader {
    constructor(apiKey) {
        this.apiKey = apiKey;
        this.baseUrl = 'https://api.imgbb.com/1/upload';
    }

    async uploadImage(imageBuffer) {
        try {
            const FormData = require('form-data');
            const formData = new FormData();
            
            formData.append('key', this.apiKey);
            formData.append('image', imageBuffer.toString('base64'));
            
            const response = await axios.post(this.baseUrl, formData, {
                headers: {
                    ...formData.getHeaders()
                },
                timeout: 30000
            });
            
            if (response.data && response.data.success) {
                return {
                    success: true,
                    url: response.data.data.url,
                    display_url: response.data.data.display_url,
                    thumb_url: response.data.data.thumb?.url || response.data.data.url,
                    delete_url: response.data.data.delete_url
                };
            } else {
                return {
                    success: false,
                    error: 'Upload failed'
                };
            }
        } catch (error) {
            console.error('ImgBB upload error:', error);
            return {
                success: false,
                error: error.message
            };
        }
    }

    async uploadImageFromUrl(imageUrl) {
        try {
            const response = await axios.get(imageUrl, { 
                responseType: 'arraybuffer',
                timeout: 30000
            });
            const imageBuffer = Buffer.from(response.data);
            return await this.uploadImage(imageBuffer);
        } catch (error) {
            console.error('ImgBB upload from URL error:', error);
            return {
                success: false,
                error: error.message
            };
        }
    }
}

// INITIALIZE SYSTEMS
const goalAI = new GoalPredictionAI();
const dynamicStats = new DynamicStatistics();
const imgbbUploader = new ImgBBUploader(CONFIG.IMGBB_API_KEY);

// ğŸ“¢ CHANNEL NOTIFICATION SYSTEM
class ChannelNotifier {
    constructor(bot, channelId) {
        this.bot = bot;
        this.channelId = channelId;
    }

    async sendSubscriptionNotification(userData, subscriptionType, amount, paymentSystem) {
        try {
            const systemText = paymentSystem === 'binance' ? 'Ø¨Ø§ÙŠÙ†Ø§Ù†Ø³' : 'ØªØ­ÙˆÙŠÙ„ Ø¨Ù†ÙƒÙŠ';
            const subscriptionDisplayName = getSubscriptionDisplayName(subscriptionType);
            
            const message = `
ğŸ‰ *Ø§Ø´ØªØ±Ø§Ùƒ Ø¬Ø¯ÙŠØ¯ ÙÙŠ Ø§Ù„Ø¨ÙˆØª - ${systemText}*

ğŸ‘¤ *Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:* ${userData.username}
ğŸ” *Ø§Ù„Ø­Ø³Ø§Ø¨:* ${userData.onexbet}
ğŸ“¦ *Ø§Ù„Ø¨Ø§Ù‚Ø©:* ${subscriptionDisplayName}
ğŸ’° *Ø§Ù„Ù…Ø¨Ù„Øº:* ${amount}$
ğŸ’³ *Ø§Ù„Ù†Ø¸Ø§Ù…:* ${systemText}

ğŸ•’ *Ø§Ù„ÙˆÙ‚Øª:* ${new Date().toLocaleString('ar-EG')}
            `;

            await this.bot.telegram.sendMessage(this.channelId, message, {
                parse_mode: 'Markdown'
            });
        } catch (error) {
            console.error('Error sending subscription notification:', error);
        }
    }

    async sendPredictionNotification(userData, prediction, betAmount) {
        try {
            const message = `
ğŸ¯ *ØªÙˆÙ‚Ø¹ Ø¬Ø¯ÙŠØ¯ ÙÙŠ Ø§Ù„Ø¨ÙˆØª*

ğŸ‘¤ *Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:* ${userData.username}
ğŸ” *Ø§Ù„Ø­Ø³Ø§Ø¨:* ${userData.onexbet}
ğŸ¯ *Ø§Ù„ØªÙˆÙ‚Ø¹:* ${prediction.type}
ğŸ“ˆ *Ø§Ù„Ø§Ø­ØªÙ…Ø§Ù„ÙŠØ©:* ${prediction.probability}%
ğŸ’° *Ù…Ø¨Ù„Øº Ø§Ù„Ø±Ù‡Ø§Ù†:* ${betAmount}$

ğŸ’¡ *Ø§Ù„ØªØ­Ù„ÙŠÙ„:*
${prediction.reasoning}

ğŸ•’ *Ø§Ù„ÙˆÙ‚Øª:* ${new Date().toLocaleString('ar-EG')}
            `;

            await this.bot.telegram.sendMessage(this.channelId, message, {
                parse_mode: 'Markdown'
            });
        } catch (error) {
            console.error('Error sending prediction notification:', error);
        }
    }
}

const channelNotifier = new ChannelNotifier(bot, CONFIG.CHANNEL_ID);

// ğŸ¯ BOT SETUP WITH FIREBASE SESSION MANAGEMENT
bot.use(async (ctx, next) => {
    const userId = ctx.from?.id.toString();
    if (!userId) return next();

    try {
        // Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ù† Firebase
        const userData = await dbManager.getUser(userId);
        
        if (userData) {
            // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹ØŒ Ù†Ù‚ÙˆÙ… Ø¨ØªØ­Ù…ÙŠÙ„ Ø¬Ù„Ø³ØªÙ‡
            ctx.session = {
                step: userData.step || 'start',
                userData: userData,
                verificationCode: userData.session_data?.verificationCode || null,
                accountId: userData.session_data?.accountId || null,
                paymentType: userData.session_data?.paymentType || null,
                paymentSystem: userData.session_data?.paymentSystem || null,
                adminMode: userData.session_data?.adminMode || false,
                adminStep: userData.session_data?.adminStep || null,
                awaitingPaymentAccount: userData.session_data?.awaitingPaymentAccount || false,
                paymentAccount: userData.session_data?.paymentAccount || null,
                currentBet: userData.session_data?.currentBet || 0,
                originalBet: userData.session_data?.originalBet || 0,
                totalProfit: userData.session_data?.totalProfit || 0,
                awaitingBetAmount: userData.session_data?.awaitingBetAmount || false,
                searchQuery: userData.session_data?.searchQuery || null,
                broadcastMessage: userData.session_data?.broadcastMessage || null,
                adminSettingsStep: userData.session_data?.adminSettingsStep || null,
                selectedPaymentType: userData.session_data?.selectedPaymentType || null,
                editingSubscriptionType: userData.session_data?.editingSubscriptionType || null,
                adminPaymentSystem: userData.session_data?.adminPaymentSystem || null,
                awaitingBankImage: userData.session_data?.awaitingBankImage || false,
                editingBankStep: userData.session_data?.editingBankStep || null,
                bankEditData: userData.session_data?.bankEditData || {},
                checkingChannel: userData.session_data?.checkingChannel || false,
                country: userData.session_data?.country || null,
                awaitingCountry: userData.session_data?.awaitingCountry || false
            };
        } else {
            // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¬Ø¯ÙŠØ¯Ø§Ù‹ØŒ Ù†Ù†Ø´Ø¦ Ø¬Ù„Ø³Ø© Ø¬Ø¯ÙŠØ¯Ø©
            ctx.session = { 
                step: 'start',
                userData: {},
                verificationCode: null,
                accountId: null,
                paymentType: null,
                paymentSystem: null,
                adminMode: false,
                adminStep: null,
                awaitingPaymentAccount: false,
                paymentAccount: null,
                currentBet: 0,
                originalBet: 0,
                totalProfit: 0,
                awaitingBetAmount: false,
                searchQuery: null,
                broadcastMessage: null,
                adminSettingsStep: null,
                selectedPaymentType: null,
                editingSubscriptionType: null,
                adminPaymentSystem: null,
                awaitingBankImage: false,
                editingBankStep: null,
                bankEditData: {},
                checkingChannel: false,
                country: null,
                awaitingCountry: false
            };
        }
    } catch (error) {
        console.error('Session middleware error:', error);
        ctx.session = { 
            step: 'start',
            userData: {},
            verificationCode: null,
            accountId: null,
            paymentType: null,
            paymentSystem: null,
            adminMode: false,
            adminStep: null,
            awaitingPaymentAccount: false,
            paymentAccount: null,
            currentBet: 0,
            originalBet: 0,
            totalProfit: 0,
            awaitingBetAmount: false,
            searchQuery: null,
            broadcastMessage: null,
            adminSettingsStep: null,
            selectedPaymentType: null,
            editingSubscriptionType: null,
            adminPaymentSystem: null,
            awaitingBankImage: false,
            editingBankStep: null,
            bankEditData: {},
            checkingChannel: false,
            country: null,
            awaitingCountry: false
        };
    }

    await next();

    // Ø­ÙØ¸ Ø§Ù„Ø¬Ù„Ø³Ø© Ø¨Ø¹Ø¯ ÙƒÙ„ ØªØ­Ø¯ÙŠØ«
    if (userId && ctx.session) {
        try {
            const sessionData = {
                verificationCode: ctx.session.verificationCode,
                accountId: ctx.session.accountId,
                paymentType: ctx.session.paymentType,
                paymentSystem: ctx.session.paymentSystem,
                adminMode: ctx.session.adminMode,
                adminStep: ctx.session.adminStep,
                awaitingPaymentAccount: ctx.session.awaitingPaymentAccount,
                paymentAccount: ctx.session.paymentAccount,
                currentBet: ctx.session.currentBet,
                originalBet: ctx.session.originalBet,
                totalProfit: ctx.session.totalProfit,
                awaitingBetAmount: ctx.session.awaitingBetAmount,
                searchQuery: ctx.session.searchQuery,
                broadcastMessage: ctx.session.broadcastMessage,
                adminSettingsStep: ctx.session.adminSettingsStep,
                selectedPaymentType: ctx.session.selectedPaymentType,
                editingSubscriptionType: ctx.session.editingSubscriptionType,
                adminPaymentSystem: ctx.session.adminPaymentSystem,
                awaitingBankImage: ctx.session.awaitingBankImage,
                editingBankStep: ctx.session.editingBankStep,
                bankEditData: ctx.session.bankEditData,
                checkingChannel: ctx.session.checkingChannel,
                country: ctx.session.country,
                awaitingCountry: ctx.session.awaitingCountry
            };

            await dbManager.updateUserSession(userId, ctx.session.step, sessionData);
        } catch (error) {
            console.error('Error saving session:', error);
        }
    }
});

// ğŸ¯ Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ø«Ø§Ø¨ØªØ© - UPDATED FOR DUAL PAYMENT
const getMainKeyboard = () => {
    return Markup.keyboard([
        ['ğŸ¯ Ø¬Ù„Ø¨ Ø§Ù„ØªØ­Ù„ÙŠÙ„', 'ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§ØªÙŠ'],
        ['ğŸ’³ Ø§Ù„Ø§Ø´ØªØ±Ø§ÙƒØ§Øª', 'ğŸ‘¥ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØª'],
        ['ğŸ‘¤ Ø­Ø§Ù„Ø© Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ', 'ğŸ†˜ Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ']
    ]).resize();
};

const getLoginKeyboard = () => {
    return Markup.keyboard([
        ['ğŸ” Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨']
    ]).resize();
};

// ğŸ†• Ù„ÙˆØ­Ø© Ø§Ø®ØªÙŠØ§Ø± Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
const getPaymentMethodKeyboard = () => {
    return Markup.keyboard([
        ['ğŸ’³ Ø¨Ø§ÙŠÙ†Ø§Ù†Ø³', 'ğŸ¦ ØªØ­ÙˆÙŠÙ„ Ø¨Ù†ÙƒÙŠ'],
        ['ğŸ”™ Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø©']
    ]).resize();
};

const getSubscriptionKeyboard = () => {
    return Markup.keyboard([
        ['ğŸ’° Ø£Ø³Ø¨ÙˆØ¹ÙŠ', 'ğŸ’° Ø´Ù‡Ø±ÙŠ'],
        ['ğŸ’° 3 Ø£Ø´Ù‡Ø±', 'ğŸ’° Ø³Ù†ÙˆÙŠ'],
        ['ğŸ”™ Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø©']
    ]).resize();
};

// ğŸ†• Ù„ÙˆØ­Ø© Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø¯ÙˆÙ„ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©
const getCountriesKeyboard = () => {
    return Markup.keyboard([
        ['ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø³Ø¹ÙˆØ¯ÙŠØ©', 'ğŸ‡¦ğŸ‡ª Ø§Ù„Ø¥Ù…Ø§Ø±Ø§Øª', 'ğŸ‡¶ğŸ‡¦ Ù‚Ø·Ø±'],
        ['ğŸ‡°ğŸ‡¼ Ø§Ù„ÙƒÙˆÙŠØª', 'ğŸ‡§ğŸ‡­ Ø§Ù„Ø¨Ø­Ø±ÙŠÙ†', 'ğŸ‡´ğŸ‡² Ø¹Ù…Ø§Ù†'],
        ['ğŸ‡¾ğŸ‡ª Ø§Ù„ÙŠÙ…Ù†', 'ğŸ‡®ğŸ‡¶ Ø§Ù„Ø¹Ø±Ø§Ù‚', 'ğŸ‡¸ğŸ‡¾ Ø³ÙˆØ±ÙŠØ§'],
        ['ğŸ‡¯ğŸ‡´ Ø§Ù„Ø£Ø±Ø¯Ù†', 'ğŸ‡±ğŸ‡§ Ù„Ø¨Ù†Ø§Ù†', 'ğŸ‡ªğŸ‡¬ Ù…ØµØ±'],
        ['ğŸ‡©ğŸ‡¿ Ø§Ù„Ø¬Ø²Ø§Ø¦Ø±', 'ğŸ‡²ğŸ‡¦ Ø§Ù„Ù…ØºØ±Ø¨', 'ğŸ‡¹ğŸ‡³ ØªÙˆÙ†Ø³'],
        ['ğŸ‡±ğŸ‡¾ Ù„ÙŠØ¨ÙŠØ§', 'ğŸ‡¸ğŸ‡© Ø§Ù„Ø³ÙˆØ¯Ø§Ù†', 'ğŸ‡¸ğŸ‡¸ Ø¬Ù†ÙˆØ¨ Ø§Ù„Ø³ÙˆØ¯Ø§Ù†'],
        ['ğŸ‡µğŸ‡¸ ÙÙ„Ø³Ø·ÙŠÙ†', 'ğŸ‡²ğŸ‡· Ù…ÙˆØ±ÙŠØªØ§Ù†ÙŠØ§', 'ğŸ‡©ğŸ‡¯ Ø¬ÙŠØ¨ÙˆØªÙŠ'],
        ['ğŸ‡¸ğŸ‡´ Ø§Ù„ØµÙˆÙ…Ø§Ù„', 'ğŸ‡°ğŸ‡² Ø¬Ø²Ø± Ø§Ù„Ù‚Ù…Ø±']
    ]).resize();
};

// ğŸ”„ UPDATE ADMIN KEYBOARD WITH DATA MANAGEMENT
const getAdminMainKeyboard = () => {
    return Markup.keyboard([
        ['ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù†Ø¸Ø§Ù…', 'ğŸ‘¥ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†'],
        ['ğŸ’° Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ø¯ÙØ¹', 'âš™ï¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª'],
        ['ğŸ“¢ Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø±', 'ğŸ” Ø¨Ø­Ø« Ø¹Ù† Ù…Ø³ØªØ®Ø¯Ù…'],
        ['ğŸ’¾ Ù†Ø³Ø® Ø§Ø­ØªÙŠØ§Ø·ÙŠ', 'ğŸ“¥ Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª'],
        ['ğŸ”§ Ù‚ÙÙ„/ÙØªØ­ Ø§Ù„Ø¨ÙˆØª', 'ğŸ”™ Ø§Ù„Ø®Ø±ÙˆØ¬ Ù…Ù† Ø§Ù„Ø¥Ø¯Ù…Ù†']
    ]).resize();
};

const getAdminUsersKeyboard = () => {
    return Markup.keyboard([
        ['ğŸ“‹ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†', 'âœ… Ø§Ù„Ù…Ø´ØªØ±ÙƒÙŠÙ† Ø§Ù„Ù†Ø´Ø·ÙŠÙ†'],
        ['ğŸ†“ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠÙ†', 'ğŸ“ˆ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†'],
        ['ğŸ”™ Ø±Ø¬ÙˆØ¹']
    ]).resize();
};

const getAdminPaymentsKeyboard = () => {
    return Markup.keyboard([
        ['ğŸ“¥ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…Ø¹Ù„Ù‚Ø©', 'âœ… Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…Ù‚Ø¨ÙˆÙ„Ø©'],
        ['âŒ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…Ø±ÙÙˆØ¶Ø©', 'ğŸ“‹ ÙƒÙ„ Ø§Ù„Ø·Ù„Ø¨Ø§Øª'],
        ['ğŸ”™ Ø±Ø¬ÙˆØ¹']
    ]).resize();
};

const getAdminSettingsKeyboard = () => {
    return Markup.keyboard([
        ['ğŸ’° ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø£Ø³Ø¹Ø§Ø± ÙˆØ§Ù„Ø¯ÙØ¹', 'âš™ï¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø©'],
        ['ğŸ”„ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ¹ÙŠÙŠÙ†', 'ğŸ”™ Ø±Ø¬ÙˆØ¹']
    ]).resize();
};

const getAdminPaymentTypesKeyboard = () => {
    return Markup.keyboard([
        ['ğŸ’° Ø£Ø³Ø¨ÙˆØ¹ÙŠ', 'ğŸ’° Ø´Ù‡Ø±ÙŠ'],
        ['ğŸ’° 3 Ø£Ø´Ù‡Ø±', 'ğŸ’° Ø³Ù†ÙˆÙŠ'],
        ['ğŸ”™ Ø±Ø¬ÙˆØ¹']
    ]).resize();
};

// ğŸ†• Ù„ÙˆØ­Ø© Ø§Ø®ØªÙŠØ§Ø± Ù†Ø¸Ø§Ù… Ø§Ù„Ø¯ÙØ¹ ÙÙŠ Ø§Ù„Ø¥Ø¯Ù…Ù†
const getAdminPaymentSystemKeyboard = () => {
    return Markup.keyboard([
        ['ğŸ’³ Ù†Ø¸Ø§Ù… Ø¨Ø§ÙŠÙ†Ø§Ù†Ø³', 'ğŸ¦ Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¨Ù†ÙƒÙŠ'],
        ['ğŸ”™ Ø±Ø¬ÙˆØ¹']
    ]).resize();
};

// ğŸ› ï¸ UTILITY FUNCTIONS
function calculateRemainingDays(endDate) {
    try {
        const end = new Date(endDate);
        const now = new Date();
        const diffTime = end - now;
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
        return diffDays > 0 ? diffDays : 0;
    } catch (error) {
        return 0;
    }
}

function addSubscriptionDays(startDate, type) {
    try {
        const start = new Date(startDate);
        const types = {
            week: 7,
            month: 30,
            three_months: 90,
            year: 365
        };
        start.setDate(start.getDate() + types[type]);
        return start.toISOString();
    } catch (error) {
        const newDate = new Date();
        newDate.setDate(newDate.getDate() + 30);
        return newDate.toISOString();
    }
}

// ğŸ†• Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¯Ø© Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ
function getSubscriptionDuration(type) {
    const durations = {
        'week': '7 Ø£ÙŠØ§Ù…',
        'month': '30 ÙŠÙˆÙ…Ø§Ù‹', 
        'three_months': '90 ÙŠÙˆÙ…Ø§Ù‹',
        'year': '365 ÙŠÙˆÙ…Ø§Ù‹'
    };
    return durations[type] || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯';
}

// ğŸ†• Ø¯Ø§Ù„Ø© Ù„Ø¥Ù†Ø´Ø§Ø¡ ÙˆØµÙ Ø§Ù„Ø¨Ù†Ùƒ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
function generateBankDescription(subscriptionType, price, accountNumber) {
    const typeNames = {
        'week': 'Ø£Ø³Ø¨ÙˆØ¹ÙŠØ©',
        'month': 'Ø´Ù‡Ø±ÙŠØ©',
        'three_months': '3 Ø£Ø´Ù‡Ø±',
        'year': 'Ø³Ù†ÙˆÙŠØ©'
    };
    
    return `ğŸ”¹ ØªØ­ÙˆÙŠÙ„ Ø¨Ù†ÙƒÙŠ - Ø¨Ø§Ù‚Ø© ${typeNames[subscriptionType]}\nğŸ’³ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨: ${accountNumber}\nğŸ¦ Ø§Ù„Ø¨Ù†Ùƒ: Ø§Ù„Ø¨Ù†Ùƒ Ø§Ù„ÙƒØ±ÙŠÙ…ÙŠ\nğŸ’° Ø§Ù„Ù…Ø¨Ù„Øº: ${price}$\nğŸ’µ Ø§Ù„Ø¹Ù…Ù„Ø©: Ø§Ù„Ø¯ÙˆÙ„Ø§Ø± Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠ\n\nğŸ“‹ Ø§Ù„Ø´Ø±ÙˆØ·:\nâ€¢ ÙŠØ¬Ø¨ Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø¨Ø§Ù„Ø¯ÙˆÙ„Ø§Ø± Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠ\nâ€¢ Ø¥Ø±ÙØ§Ù‚ ØµÙˆØ±Ø© Ø¥Ø«Ø¨Ø§Øª Ø§Ù„Ø¯ÙØ¹\nâ€¢ ÙƒØªØ§Ø¨Ø© Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ`;
}

// ğŸ†• Ø¯Ø§Ù„Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ø³Ù… Ø§Ù„Ø¹Ø±Ø¶ Ù„Ù„Ø¨Ø§Ù‚Ø©
function getSubscriptionDisplayName(type) {
    const names = {
        'week': 'Ø£Ø³Ø¨ÙˆØ¹ÙŠ',
        'month': 'Ø´Ù‡Ø±ÙŠ', 
        'three_months': '3 Ø£Ø´Ù‡Ø±',
        'year': 'Ø³Ù†ÙˆÙŠ'
    };
    return names[type] || type;
}

// ğŸ” FUNCTION TO CHECK CHANNEL SUBSCRIPTION - IMPROVED
async function checkChannelSubscription(userId) {
    try {
        const chatMember = await bot.telegram.getChatMember(CONFIG.CHANNEL_ID, userId);
        const isSubscribed = ['member', 'administrator', 'creator'].includes(chatMember.status);
        
        // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        await dbManager.setChannelSubscription(userId, isSubscribed);
        
        return isSubscribed;
    } catch (error) {
        console.error('Error checking channel subscription:', error);
        
        // ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„Ø®Ø·Ø£ØŒ Ù†ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø§Ù„Ø© Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ù…Ø®Ø²Ù†Ø©
        try {
            const userData = await dbManager.getUser(userId);
            return userData?.channel_subscribed || false;
        } catch (dbError) {
            console.error('Error getting user subscription status:', dbError);
            return false;
        }
    }
}

// ğŸ¯ BOT COMMANDS

bot.start(async (ctx) => {
    try {
        const settings = await dbManager.getSettings();
        if (settings.maintenance_mode && ctx.from.id.toString() !== CONFIG.ADMIN_ID) {
            await ctx.replyWithMarkdown('ğŸ”§ *Ø§Ù„Ø¨ÙˆØª ØªØ­Øª Ø§Ù„ØµÙŠØ§Ù†Ø©*\n\nâ° Ù†Ø¹Ù…Ù„ Ø¹Ù„Ù‰ ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø®Ø¯Ù…Ø© Ù„ÙƒÙ…\nğŸ”„ Ø³Ù†Ø¹ÙˆØ¯ Ù‚Ø±ÙŠØ¨Ø§Ù‹ Ø¨Ø£ÙØ¶Ù„ Ù…Ù…Ø§ ÙƒØ§Ù†\n\nğŸ“ Ù„Ù„Ø§Ø³ØªÙØ³Ø§Ø±: ' + CONFIG.DEVELOPER);
            return;
        }

        const userId = ctx.from.id.toString();
        const userName = ctx.from.first_name;

        // Ø§Ù„ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø³Ø¬Ù„ Ù…Ø³Ø¨Ù‚Ø§Ù‹
        const existingUser = await dbManager.getUser(userId);
        
        if (existingUser) {
            // Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø³Ø¬Ù„ Ù…Ø³Ø¨Ù‚Ø§Ù‹ - Ù†Ù‚ÙˆÙ… Ø¨ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¬Ù„Ø³Ø©
            ctx.session.step = existingUser.step || 'verified';
            ctx.session.userData = existingUser;

            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©
            const isSubscribed = await checkChannelSubscription(userId);
            
            if (!isSubscribed && ctx.session.step !== 'awaiting_verification' && ctx.session.step !== 'awaiting_account_id') {
                await ctx.replyWithMarkdown(
                    `âŒ *ÙŠØ¬Ø¨ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø© Ø£ÙˆÙ„Ø§Ù‹*\n\n` +
                    `ğŸ“¢ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©:\n` +
                    `ğŸ‘‰ ${CONFIG.CHANNEL_USERNAME}\n\n` +
                    `âœ… Ø«Ù… Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø± Ø£Ø¯Ù†Ø§Ù‡ Ù„Ù„ØªØ­Ù‚Ù‚:`,
                    Markup.inlineKeyboard([
                        [Markup.button.callback('âœ… ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ', 'check_channel_subscription')]
                    ])
                );
                return;
            }

            const remainingDays = calculateRemainingDays(existingUser.subscription_end_date);
            
            let statusMessage = '';
            if (existingUser.subscription_status === 'active' && remainingDays > 0) {
                statusMessage = `ğŸ‰ *Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ø¹ÙˆØ¯ØªÙƒ!*\n\n` +
                               `âœ… *Ø§Ø´ØªØ±Ø§ÙƒÙƒ Ù†Ø´Ø·*\n` +
                               `ğŸ” Ø§Ù„Ø­Ø³Ø§Ø¨: \`${existingUser.onexbet}\`\n` +
                               `ğŸ“¦ Ø§Ù„Ù†ÙˆØ¹: ${getSubscriptionDisplayName(existingUser.subscription_type)}\n` +
                               `ğŸ“… Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡: ${new Date(existingUser.subscription_end_date).toLocaleDateString('ar-EG')}\n` +
                               `â³ Ù…ØªØ¨Ù‚ÙŠ: ${remainingDays} ÙŠÙˆÙ…`;
            } else if (existingUser.free_attempts > 0) {
                statusMessage = `ğŸ‰ *Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ø¹ÙˆØ¯ØªÙƒ!*\n\n` +
                               `ğŸ¯ *Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ù…Ø¬Ø§Ù†ÙŠØ© Ù…ØªØ§Ø­Ø©*\n` +
                               `ğŸ” Ø§Ù„Ø­Ø³Ø§Ø¨: \`${existingUser.onexbet}\`\n` +
                               `ğŸ†“ Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ù…Ø¬Ø§Ù†ÙŠØ©: ${existingUser.free_attempts}`;
            } else {
                statusMessage = `ğŸ‰ *Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ø¹ÙˆØ¯ØªÙƒ!*\n\n` +
                               `ğŸš« *Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª*\n` +
                               `ğŸ” Ø§Ù„Ø­Ø³Ø§Ø¨: \`${existingUser.onexbet}\`\n` +
                               `ğŸ’³ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ù„Ù„Ù…ØªØ§Ø¨Ø¹Ø©`;
            }

            await ctx.replyWithMarkdown(statusMessage, getMainKeyboard());
            
        } else {
            // Ù…Ø³ØªØ®Ø¯Ù… Ø¬Ø¯ÙŠØ¯ - Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³ØªØ®Ø¯Ù… Ø¬Ø¯ÙŠØ¯
            const newUserData = {
                user_id: userId,
                username: ctx.from.username || ctx.from.first_name,
                first_name: ctx.from.first_name,
                onexbet: '',
                country: '',
                free_attempts: 10,
                subscription_status: 'free',
                subscription_type: 'none',
                subscription_start_date: null,
                subscription_end_date: null,
                joined_at: new Date().toISOString(),
                total_predictions: 0,
                correct_predictions: 0,
                wins: 0,
                losses: 0,
                total_bets: 0,
                total_profit: 0,
                channel_subscribed: false,
                step: 'awaiting_country',
                session_data: {
                    awaitingCountry: true
                }
            };

            await dbManager.saveUser(userId, newUserData);
            ctx.session.step = 'awaiting_country';
            ctx.session.userData = newUserData;
            ctx.session.awaitingCountry = true;

            // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±Ø© Ø£ÙˆÙ„Ø§Ù‹
            try {
                await ctx.replyWithPhoto(CONFIG.START_IMAGE, {
                    caption: `ğŸ‰ *Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ù†Ø¸Ø§Ù… GOAL Predictor Pro v${CONFIG.VERSION}* ğŸš€\n\n` +
                            `ğŸ¤– *Ø£Ù‚ÙˆÙ‰ Ù†Ø¸Ø§Ù… Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„Ø£Ù‡Ø¯Ø§Ù Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ*\n` +
                            `ğŸ’ *Ø§Ù„Ù…Ø·ÙˆØ±:* ${CONFIG.DEVELOPER}\n` +
                            `ğŸ“¢ *Ø§Ù„Ù‚Ù†Ø§Ø©:* ${CONFIG.CHANNEL}`
                });
            } catch (photoError) {
                await ctx.replyWithMarkdown(`ğŸ‰ *Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ù†Ø¸Ø§Ù… GOAL Predictor Pro v${CONFIG.VERSION}* ğŸš€`);
            }

            const countryMessage = `
ğŸŒ *Ø§Ø®ØªØ± Ø¯ÙˆÙ„ØªÙƒ*

ğŸ”° *Ù„Ø±Ø¨Ø· Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ø¨Ø­Ø³Ø§Ø¨Ùƒ*

ğŸ“‹ *ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ø¯ÙˆÙ„ØªÙƒ Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©:*

ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø³Ø¹ÙˆØ¯ÙŠØ© - ğŸ‡¦ğŸ‡ª Ø§Ù„Ø¥Ù…Ø§Ø±Ø§Øª - ğŸ‡¶ğŸ‡¦ Ù‚Ø·Ø±
ğŸ‡°ğŸ‡¼ Ø§Ù„ÙƒÙˆÙŠØª - ğŸ‡§ğŸ‡­ Ø§Ù„Ø¨Ø­Ø±ÙŠÙ† - ğŸ‡´ğŸ‡² Ø¹Ù…Ø§Ù†
ğŸ‡¾ğŸ‡ª Ø§Ù„ÙŠÙ…Ù† - ğŸ‡®ğŸ‡¶ Ø§Ù„Ø¹Ø±Ø§Ù‚ - ğŸ‡¸ğŸ‡¾ Ø³ÙˆØ±ÙŠØ§
ğŸ‡¯ğŸ‡´ Ø§Ù„Ø£Ø±Ø¯Ù† - ğŸ‡±ğŸ‡§ Ù„Ø¨Ù†Ø§Ù† - ğŸ‡ªğŸ‡¬ Ù…ØµØ±
ğŸ‡©ğŸ‡¿ Ø§Ù„Ø¬Ø²Ø§Ø¦Ø± - ğŸ‡²ğŸ‡¦ Ø§Ù„Ù…ØºØ±Ø¨ - ğŸ‡¹ğŸ‡³ ØªÙˆÙ†Ø³
ğŸ‡±ğŸ‡¾ Ù„ÙŠØ¨ÙŠØ§ - ğŸ‡¸ğŸ‡© Ø§Ù„Ø³ÙˆØ¯Ø§Ù† - ğŸ‡¸ğŸ‡¸ Ø¬Ù†ÙˆØ¨ Ø§Ù„Ø³ÙˆØ¯Ø§Ù†
ğŸ‡µğŸ‡¸ ÙÙ„Ø³Ø·ÙŠÙ† - ğŸ‡²ğŸ‡· Ù…ÙˆØ±ÙŠØªØ§Ù†ÙŠØ§ - ğŸ‡©ğŸ‡¯ Ø¬ÙŠØ¨ÙˆØªÙŠ
ğŸ‡¸ğŸ‡´ Ø§Ù„ØµÙˆÙ…Ø§Ù„ - ğŸ‡°ğŸ‡² Ø¬Ø²Ø± Ø§Ù„Ù‚Ù…Ø±

ğŸ“ *Ø§Ø®ØªØ± Ø¯ÙˆÙ„ØªÙƒ Ù„Ù„Ø§Ø³ØªÙ…Ø±Ø§Ø±:*
            `;

            await ctx.replyWithMarkdown(countryMessage, getCountriesKeyboard());
        }

    } catch (error) {
        console.error('Start command error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù…ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù„Ø§Ø­Ù‚Ø§Ù‹');
    }
});

// ğŸ“ HANDLE TEXT MESSAGES - UPDATED FOR FIREBASE SESSIONS
bot.on('text', async (ctx) => {
    try {
        const settings = await dbManager.getSettings();
        if (settings.maintenance_mode && ctx.from.id.toString() !== CONFIG.ADMIN_ID) {
            await ctx.replyWithMarkdown('ğŸ”§ *Ø§Ù„Ø¨ÙˆØª ØªØ­Øª Ø§Ù„ØµÙŠØ§Ù†Ø©*\n\nâ° Ù†Ø¹Ù…Ù„ Ø¹Ù„Ù‰ ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø®Ø¯Ù…Ø© Ù„ÙƒÙ…\nğŸ”„ Ø³Ù†Ø¹ÙˆØ¯ Ù‚Ø±ÙŠØ¨Ø§Ù‹ Ø¨Ø£ÙØ¶Ù„ Ù…Ù…Ø§ ÙƒØ§Ù†\n\nğŸ“ Ù„Ù„Ø§Ø³ØªÙØ³Ø§Ø±: ' + CONFIG.DEVELOPER);
            return;
        }

        const text = ctx.message.text;
        const session = ctx.session;
        const userId = ctx.from.id.toString();

        // ğŸ” ADMIN COMMANDS - Ù„Ù„Ø¥Ø¯Ù…Ù† ÙÙ‚Ø·
        if (userId === CONFIG.ADMIN_ID) {
            if (text === '/admin' || text === 'ğŸ” Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…') {
                ctx.session.adminMode = true;
                ctx.session.adminStep = 'main';
                await ctx.replyWithMarkdown('ğŸ”§ *Ù…Ø±Ø­Ø¨Ø§Ù‹ ÙÙŠ Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…*', getAdminMainKeyboard());
                return;
            }

            if (session.adminMode) {
                await handleAdminCommands(ctx, text);
                return;
            }
        }

        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† ØºÙŠØ± Ø§Ù„Ù…Ø³Ø¬Ù„ÙŠÙ†
        const existingUser = await dbManager.getUser(userId);
        if (!existingUser && session.step !== 'awaiting_verification' && session.step !== 'awaiting_account_id' && session.step !== 'awaiting_country') {
            const isSubscribed = await checkChannelSubscription(userId);
            if (!isSubscribed) {
                await ctx.replyWithMarkdown(
                    `âŒ *ÙŠØ¬Ø¨ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø© Ø£ÙˆÙ„Ø§Ù‹*\n\n` +
                    `ğŸ“¢ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©:\n` +
                    `ğŸ‘‰ ${CONFIG.CHANNEL_USERNAME}\n\n` +
                    `âœ… Ø«Ù… Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø± Ø£Ø¯Ù†Ø§Ù‡ Ù„Ù„ØªØ­Ù‚Ù‚:`,
                    Markup.inlineKeyboard([
                        [Markup.button.callback('âœ… ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ', 'check_channel_subscription')]
                    ])
                );
                return;
            }
        }

        // Ø¨Ø§Ù‚ÙŠ ÙƒÙˆØ¯ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù†ØµÙˆØµ ÙŠØ¨Ù‚Ù‰ ÙƒÙ…Ø§ Ù‡Ùˆ...
        // [ÙŠØªØ¨Ø¹ Ø¨Ø§Ù‚ÙŠ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ù…Ù…Ø§Ø«Ù„ Ù…Ø¹ ØªØ­Ø¯ÙŠØ«Ø§Øª Firebase]

    } catch (error) {
        console.error('Text handler error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹', getMainKeyboard());
    }
});

// ğŸ†• Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©
async function handleCheckChannelSubscription(ctx) {
    try {
        const userId = ctx.from.id.toString();
        const isSubscribed = await checkChannelSubscription(userId);
        
        if (isSubscribed) {
            await ctx.answerCbQuery('âœ… ØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø¨Ù†Ø¬Ø§Ø­!');
            
            // Ø­Ø°Ù Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©
            try {
                await ctx.deleteMessage();
            } catch (deleteError) {
                console.log('Could not delete message:', deleteError);
            }

            // Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
            const userData = await dbManager.getUser(userId);
            if (userData) {
                ctx.session.step = userData.step;
                ctx.session.userData = userData;
                
                if (userData.step === 'awaiting_country') {
                    // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙÙŠ Ù…Ø±Ø­Ù„Ø© Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø¯ÙˆÙ„Ø©
                    await ctx.replyWithMarkdown(
                        'ğŸŒ *Ø§Ø®ØªØ± Ø¯ÙˆÙ„ØªÙƒ*\n\n' +
                        'ğŸ“ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ø¯ÙˆÙ„ØªÙƒ Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©:',
                        getCountriesKeyboard()
                    );
                } else if (userData.onexbet) {
                    // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø³Ø¬Ù„ Ø¨Ø§Ù„ÙØ¹Ù„
                    await ctx.replyWithMarkdown(
                        `âœ… *ØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø¨Ù†Ø¬Ø§Ø­!*\n\n` +
                        `ğŸ‰ *Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ø¹ÙˆØ¯ØªÙƒ ${userData.first_name}*\n\n` +
                        `ğŸ” Ø§Ù„Ø­Ø³Ø§Ø¨: \`${userData.onexbet}\`\n` +
                        `ğŸ“ Ø§Ù„Ø¯ÙˆÙ„Ø©: ${userData.country || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'}\n\n` +
                        `ğŸ¯ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¢Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØª`,
                        getMainKeyboard()
                    );
                } else {
                    // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¬Ø¯ÙŠØ¯Ø§Ù‹ ÙˆÙ„Ù… ÙŠÙƒÙ…Ù„ Ø§Ù„ØªØ³Ø¬ÙŠÙ„
                    await ctx.replyWithMarkdown(
                        'ğŸ” *Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ!*\n\n' +
                        'âœ… ØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø¨Ù†Ø¬Ø§Ø­\n\n' +
                        'ğŸ“ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet Ù„Ù„Ø¨Ø¯Ø¡:',
                        getLoginKeyboard()
                    );
                }
            } else {
                await ctx.replyWithMarkdown(
                    'ğŸ” *Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ!*\n\n' +
                    'âœ… ØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø¨Ù†Ø¬Ø§Ø­\n\n' +
                    'ğŸ“ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet Ù„Ù„Ø¨Ø¯Ø¡:',
                    getLoginKeyboard()
                );
            }
        } else {
            await ctx.answerCbQuery('âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø¨Ø¹Ø¯!');
            await ctx.replyWithMarkdown(
                `âŒ *Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ø´ØªØ±Ø§ÙƒÙƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©*\n\n` +
                `ğŸ“¢ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø© Ø£ÙˆÙ„Ø§Ù‹:\n` +
                `ğŸ‘‰ ${CONFIG.CHANNEL_USERNAME}\n\n` +
                `âœ… Ø«Ù… Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø± Ø£Ø¯Ù†Ø§Ù‡ Ù„Ù„ØªØ­Ù‚Ù‚:`,
                Markup.inlineKeyboard([
                    [Markup.button.callback('âœ… ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ', 'check_channel_subscription')]
                ])
            );
        }
    } catch (error) {
        console.error('Channel subscription check error:', error);
        await ctx.answerCbQuery('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚');
    }
}

// ğŸ¯ HANDLE CALLBACK QUERIES - UPDATED FOR FIREBASE
bot.on('callback_query', async (ctx) => {
    try {
        const callbackData = ctx.callbackQuery.data;
        const userId = ctx.from.id.toString();
        
        if (callbackData === 'check_channel_subscription') {
            await handleCheckChannelSubscription(ctx);
            return;
        }
        
        // Ø¨Ø§Ù‚ÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ callbacks ØªØ¨Ù‚Ù‰ ÙƒÙ…Ø§ Ù‡ÙŠ...
        // [ÙŠØªØ¨Ø¹ Ø¨Ø§Ù‚ÙŠ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ù…Ù…Ø§Ø«Ù„]

    } catch (error) {
        console.error('Callback query error:', error);
        await ctx.answerCbQuery('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©');
    }
});

// ğŸš€ START BOT
bot.launch().then(() => {
    console.log('ğŸ‰ SUCCESS! AI GOAL Predictor v16.0 FIXED with FIREBASE is RUNNING!');
    console.log('ğŸ’³ Payment Systems: Binance + Bank Transfer');
    console.log('ğŸ’¾ Firebase Persistent Data Storage: ENABLED');
    console.log('ğŸ‘¤ Developer:', CONFIG.DEVELOPER);
    console.log('ğŸ“¢ Channel:', CONFIG.CHANNEL);
    console.log('ğŸŒ Health check: http://localhost:' + PORT);
    console.log('ğŸ”„ Keep alive: http://localhost:' + PORT + '/keep-alive');
    console.log('ğŸ”§ Admin ID:', CONFIG.ADMIN_ID);
}).catch(console.error);

// ğŸ›‘ GRACEFUL SHUTDOWN
process.once('SIGINT', () => bot.stop('SIGINT'));
process.once('SIGTERM', () => bot.stop('SIGTERM'));

console.log('âœ… AI Goal Prediction System with Firebase & Persistent Data Ready!');
