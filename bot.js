// ===================================================
// ðŸš€ AI GOAL PREDICTOR ULTIMATE - VERSION 16.0 FIXED
// ðŸ‘¤ DEVELOPER: â™›ð‘¨ð’Žð’†ð’†ð’ ð‘¨ð’ð’›ð’˜ð’‚ð’‰ð’Šâ™›
// ðŸ”¥ FEATURES: DUAL PAYMENT SYSTEM + BANK TRANSFER + BINANCE
// ðŸ’¾ PERSISTENT DATA STORAGE - FIREBASE INTEGRATION
// ðŸ” ALL KEYS FROM ENVIRONMENT VARIABLES
// ðŸ”„ ENHANCED BACKUP SYSTEM - FIXED
// ===================================================

console.log('ðŸ¤– Starting AI GOAL Predictor Ultimate v16.0 FIXED...');
console.log('ðŸ•’ ' + new Date().toISOString());

// ðŸ”§ CONFIGURATION - ALL FROM ENVIRONMENT VARIABLES
const CONFIG = {
    BOT_TOKEN: process.env.BOT_TOKEN,
    ADMIN_ID: process.env.ADMIN_ID,
    CHANNEL_ID: process.env.CHANNEL_ID,
    CHANNEL_USERNAME: process.env.CHANNEL_USERNAME,
    
    // ðŸ§  AI APIS
    AI_APIS: {
        GEMINI: process.env.GEMINI_API_KEY,
        OPENAI: process.env.OPENAI_API_KEY
    },

    // ðŸ’° DEFAULT PRICING - DUAL SYSTEM
    SUBSCRIPTION_PRICES: {
        binance: {
            week: parseInt(process.env.PRICE_WEEK_BINANCE) || 10,
            month: parseInt(process.env.PRICE_MONTH_BINANCE) || 30,
            three_months: parseInt(process.env.PRICE_3MONTHS_BINANCE) || 80,
            year: parseInt(process.env.PRICE_YEAR_BINANCE) || 250
        },
        bank: {
            week: parseInt(process.env.PRICE_WEEK_BANK) || 10,
            month: parseInt(process.env.PRICE_MONTH_BANK) || 30, 
            three_months: parseInt(process.env.PRICE_3MONTHS_BANK) || 80,
            year: parseInt(process.env.PRICE_YEAR_BANK) || 250
        }
    },

    // ðŸ” DEFAULT PAYMENT LINKS - DUAL SYSTEM
    PAYMENT_LINKS: {
        binance: {
            week: process.env.PAYMENT_WEEK_BINANCE,
            month: process.env.PAYMENT_MONTH_BINANCE, 
            three_months: process.env.PAYMENT_3MONTHS_BINANCE,
            year: process.env.PAYMENT_YEAR_BINANCE
        },
        bank: {
            week: {
                account: process.env.BANK_ACCOUNT_WEEK || "1234567890",
                image: process.env.BANK_IMAGE_WEEK || "https://i.ibb.co/default-bank-week.jpg",
                description: process.env.BANK_DESCRIPTION_WEEK || "ðŸ”¹ ØªØ­ÙˆÙŠÙ„ Ø¨Ù†ÙƒÙŠ - Ø¨Ø§Ù‚Ø© Ø£Ø³Ø¨ÙˆØ¹ÙŠØ©\nðŸ’³ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨: 1234567890\nðŸ¦ Ø§Ù„Ø¨Ù†Ùƒ: Ø§Ù„Ø¨Ù†Ùƒ Ø§Ù„ÙƒØ±ÙŠÙ…ÙŠ\nðŸ’° Ø§Ù„Ù…Ø¨Ù„Øº: 10$\nðŸ’µ Ø§Ù„Ø¹Ù…Ù„Ø©: Ø§Ù„Ø¯ÙˆÙ„Ø§Ø± Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠ\n\nðŸ“‹ Ø§Ù„Ø´Ø±ÙˆØ·:\nâ€¢ ÙŠØ¬Ø¨ Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø¨Ø§Ù„Ø¯ÙˆÙ„Ø§Ø± Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠ\nâ€¢ Ø¥Ø±ÙØ§Ù‚ ØµÙˆØ±Ø© Ø¥Ø«Ø¨Ø§Øª Ø§Ù„Ø¯ÙØ¹\nâ€¢ ÙƒØªØ§Ø¨Ø© Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ"
            },
            month: {
                account: process.env.BANK_ACCOUNT_MONTH || "1234567890",
                image: process.env.BANK_IMAGE_MONTH || "https://i.ibb.co/default-bank-month.jpg", 
                description: process.env.BANK_DESCRIPTION_MONTH || "ðŸ”¹ ØªØ­ÙˆÙŠÙ„ Ø¨Ù†ÙƒÙŠ - Ø¨Ø§Ù‚Ø© Ø´Ù‡Ø±ÙŠØ©\nðŸ’³ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨: 1234567890\nðŸ¦ Ø§Ù„Ø¨Ù†Ùƒ: Ø§Ù„Ø¨Ù†Ùƒ Ø§Ù„ÙƒØ±ÙŠÙ…ÙŠ\nðŸ’° Ø§Ù„Ù…Ø¨Ù„Øº: 30$\nðŸ’µ Ø§Ù„Ø¹Ù…Ù„Ø©: Ø§Ù„Ø¯ÙˆÙ„Ø§Ø± Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠ\n\nðŸ“‹ Ø§Ù„Ø´Ø±ÙˆØ·:\nâ€¢ ÙŠØ¬Ø¨ Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø¨Ø§Ù„Ø¯ÙˆÙ„Ø§Ø± Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠ\nâ€¢ Ø¥Ø±ÙØ§Ù‚ ØµÙˆØ±Ø© Ø¥Ø«Ø¨Ø§Øª Ø§Ù„Ø¯ÙØ¹\nâ€¢ ÙƒØªØ§Ø¨Ø© Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ"
            },
            three_months: {
                account: process.env.BANK_ACCOUNT_3MONTHS || "1234567890",
                image: process.env.BANK_IMAGE_3MONTHS || "https://i.ibb.co/default-bank-3months.jpg",
                description: process.env.BANK_DESCRIPTION_3MONTHS || "ðŸ”¹ ØªØ­ÙˆÙŠÙ„ Ø¨Ù†ÙƒÙŠ - Ø¨Ø§Ù‚Ø© 3 Ø£Ø´Ù‡Ø±\nðŸ’³ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨: 1234567890\nðŸ¦ Ø§Ù„Ø¨Ù†Ùƒ: Ø§Ù„Ø¨Ù†Ùƒ Ø§Ù„ÙƒØ±ÙŠÙ…ÙŠ\nðŸ’° Ø§Ù„Ù…Ø¨Ù„Øº: 80$\nðŸ’µ Ø§Ù„Ø¹Ù…Ù„Ø©: Ø§Ù„Ø¯ÙˆÙ„Ø§Ø± Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠ\n\nðŸ“‹ Ø§Ù„Ø´Ø±ÙˆØ·:\nâ€¢ ÙŠØ¬Ø¨ Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø¨Ø§Ù„Ø¯ÙˆÙ„Ø§Ø± Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠ\nâ€¢ Ø¥Ø±ÙØ§Ù‚ ØµÙˆØ±Ø© Ø¥Ø«Ø¨Ø§Øª Ø§Ù„Ø¯ÙØ¹\nâ€¢ ÙƒØªØ§Ø¨Ø© Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ"
            },
            year: {
                account: process.env.BANK_ACCOUNT_YEAR || "1234567890",
                image: process.env.BANK_IMAGE_YEAR || "https://i.ibb.co/default-bank-year.jpg",
                description: process.env.BANK_DESCRIPTION_YEAR || "ðŸ”¹ ØªØ­ÙˆÙŠÙ„ Ø¨Ù†ÙƒÙŠ - Ø¨Ø§Ù‚Ø© Ø³Ù†ÙˆÙŠØ©\nðŸ’³ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨: 1234567890\nðŸ¦ Ø§Ù„Ø¨Ù†Ùƒ: Ø§Ù„Ø¨Ù†Ùƒ Ø§Ù„ÙƒØ±ÙŠÙ…ÙŠ\nðŸ’° Ø§Ù„Ù…Ø¨Ù„Øº: 250$\nðŸ’µ Ø§Ù„Ø¹Ù…Ù„Ø©: Ø§Ù„Ø¯ÙˆÙ„Ø§Ø± Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠ\n\nðŸ“‹ Ø§Ù„Ø´Ø±ÙˆØ·:\nâ€¢ ÙŠØ¬Ø¨ Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø¨Ø§Ù„Ø¯ÙˆÙ„Ø§Ø± Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠ\nâ€¢ Ø¥Ø±ÙØ§Ù‚ ØµÙˆØ±Ø© Ø¥Ø«Ø¨Ø§Øª Ø§Ù„Ø¯ÙØ¹\nâ€¢ ÙƒØªØ§Ø¨Ø© Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ"
            }
        }
    },
    
    VERSION: "16.0.0",
    DEVELOPER: process.env.DEVELOPER_NAME || "â™›ð‘¨ð’Žð’†ð’†ð’ ð‘¨ð’ð’›ð’˜ð’‚ð’‰ð’Šâ™›",
    CHANNEL: process.env.CHANNEL_NAME || "@GEMZGOOL",
    START_IMAGE: process.env.START_IMAGE_URL || "https://i.ibb.co/tpy70Bd1/IMG-20251104-074214-065.jpg",
    ANALYSIS_IMAGE: process.env.ANALYSIS_IMAGE_URL || "https://i.ibb.co/VYjf05S0/Screenshot.png",
    PREDICTION_IMAGE: process.env.PREDICTION_IMAGE_URL || "https://i.ibb.co/rGTZm2mB/IMG.jpg",
    IMGBB_API_KEY: process.env.IMGBB_API_KEY
};

// âœ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
if (!CONFIG.BOT_TOKEN) {
    console.error('âŒ BOT_TOKEN is required in environment variables');
    process.exit(1);
}

if (!CONFIG.ADMIN_ID) {
    console.error('âŒ ADMIN_ID is required in environment variables');
    process.exit(1);
}

console.log('âœ… Configuration loaded from environment variables');

// ðŸš€ INITIALIZE BOT
const { Telegraf, Markup, session } = require('telegraf');
const axios = require('axios');
const express = require('express');

const bot = new Telegraf(CONFIG.BOT_TOKEN);

// ðŸŒ HEALTH CHECK SERVER FOR RENDER
const app = express();
const PORT = process.env.PORT || 3000;

app.use(express.json());

app.get('/', (req, res) => {
    res.json({ 
        status: 'OK', 
        version: CONFIG.VERSION,
        timestamp: new Date().toISOString(),
        message: 'AI Goal Predictor Bot is running...',
        developer: CONFIG.DEVELOPER
    });
});

// ðŸ”„ KEEP ALIVE ENDPOINT FOR RENDER
app.get('/keep-alive', (req, res) => {
    res.json({ 
        status: 'ALIVE', 
        timestamp: new Date().toISOString(),
        message: 'Bot is alive and running'
    });
});

app.listen(PORT, () => {
    console.log(`ðŸŒ Health check server running on port ${PORT}`);
    console.log(`ðŸ”„ Keep alive endpoint: http://localhost:${PORT}/keep-alive`);
});

// ðŸ”¥ ENHANCED FIREBASE INITIALIZATION - PERSISTENT DATA
let db = null;
let admin = null;

async function initializeFirebase() {
    try {
        admin = require('firebase-admin');
        
        // ðŸ” FIREBASE CONFIG FROM ENVIRONMENT VARIABLES
        const serviceAccount = {
            "type": "service_account",
            "project_id": process.env.FIREBASE_PROJECT_ID,
            "private_key_id": process.env.FIREBASE_PRIVATE_KEY_ID,
            "private_key": process.env.FIREBASE_PRIVATE_KEY ? process.env.FIREBASE_PRIVATE_KEY.replace(/\\n/g, '\n') : null,
            "client_email": process.env.FIREBASE_CLIENT_EMAIL,
            "client_id": process.env.FIREBASE_CLIENT_ID,
            "auth_uri": "https://accounts.google.com/o/oauth2/auth",
            "token_uri": "https://oauth2.googleapis.com/token",
            "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
            "client_x509_cert_url": process.env.FIREBASE_CLIENT_X509_CERT_URL,
            "universe_domain": "googleapis.com"
        };

        // âœ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ù…ÙØ§ØªÙŠØ­ Firebase
        if (!serviceAccount.project_id || !serviceAccount.private_key || !serviceAccount.client_email) {
            console.log('âŒ Firebase configuration is incomplete, using local storage only');
            return false;
        }

        if (!admin.apps.length) {
            admin.initializeApp({
                credential: admin.credential.cert(serviceAccount),
                databaseURL: process.env.FIREBASE_DATABASE_URL
            });
        }
        
        db = admin.firestore();
        
        // ðŸ”„ TEST FIREBASE CONNECTION
        const testDoc = db.collection('connection_test').doc('test');
        await testDoc.set({ 
            timestamp: new Date().toISOString(),
            status: 'connected',
            version: CONFIG.VERSION
        });
        
        console.log('âœ… Firebase initialized successfully with persistent connection');
        return true;
        
    } catch (error) {
        console.log('âŒ Firebase initialization failed:', error.message);
        console.log('ðŸ”„ Using enhanced local storage with backup system');
        return false;
    }
}

// INITIALIZE FIREBASE FIRST
initializeFirebase().then(success => {
    if (success) {
        console.log('âœ… Firebase connection established');
    } else {
        console.log('âŒ Firebase connection failed, using local storage');
    }
});

// ðŸ” Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø© Ø¹Ø¨Ø± Telegram API ÙÙ‚Ø·
async function checkChannelSubscription(userId) {
    try {
        const chatMember = await bot.telegram.getChatMember(CONFIG.CHANNEL_ID, userId);
        const isSubscribed = chatMember.status === 'member' || 
                           chatMember.status === 'administrator' || 
                           chatMember.status === 'creator';
        
        return isSubscribed;
    } catch (error) {
        console.error('Error checking channel subscription:', error);
        return false;
    }
}

// ðŸ”„ ENHANCED BACKUP SYSTEM - FIXED
class EnhancedBackupSystem {
    constructor() {
        this.backupInterval = null;
        this.lastBackupTime = null;
    }

    async createBackup() {
        try {
            console.log('ðŸ”„ Creating comprehensive backup...');
            
            if (!db) {
                console.log('âŒ Firebase not available for backup');
                return false;
            }

            const backupData = {
                users: await this.getAllUsersForBackup(),
                payments: await this.getAllPaymentsForBackup(),
                settings: await this.getSettingsForBackup(),
                system_info: {
                    version: CONFIG.VERSION,
                    timestamp: new Date().toISOString(),
                    total_users: (await this.getAllUsersForBackup()).length,
                    total_payments: (await this.getAllPaymentsForBackup()).length
                }
            };

            const backupId = `backup_${Date.now()}`;
            await db.collection('backups').doc(backupId).set(backupData);
            
            this.lastBackupTime = new Date().toISOString();
            console.log(`âœ… Backup created successfully: ${backupId}`);
            console.log(`ðŸ“Š Backup contains: ${backupData.users.length} users, ${backupData.payments.length} payments`);
            
            return true;
        } catch (error) {
            console.error('âŒ Backup creation failed:', error);
            return false;
        }
    }

    async getAllUsersForBackup() {
        try {
            if (db) {
                const usersSnapshot = await db.collection('users').get();
                return usersSnapshot.docs.map(doc => ({
                    id: doc.id,
                    ...doc.data()
                }));
            } else {
                // Fallback to local storage
                return Array.from(persistentStorage.userDatabase.entries()).map(([id, data]) => ({
                    id,
                    ...data
                }));
            }
        } catch (error) {
            console.error('Error getting users for backup:', error);
            return [];
        }
    }

    async getAllPaymentsForBackup() {
        try {
            if (db) {
                const paymentsSnapshot = await db.collection('payments').get();
                return paymentsSnapshot.docs.map(doc => doc.data());
            } else {
                return Array.from(persistentStorage.paymentDatabase.values());
            }
        } catch (error) {
            console.error('Error getting payments for backup:', error);
            return [];
        }
    }

    async getSettingsForBackup() {
        try {
            if (db) {
                const settingsDoc = await db.collection('settings').doc('config').get();
                return settingsDoc.exists ? settingsDoc.data() : {};
            } else {
                return persistentStorage.settingsDatabase.get('config') || {};
            }
        } catch (error) {
            console.error('Error getting settings for backup:', error);
            return {};
        }
    }

    async restoreFromBackup(backupId = null) {
        try {
            console.log('ðŸ“¥ Starting data restoration...');
            
            if (!db) {
                console.log('âŒ Firebase not available for restore');
                return { success: false, error: 'Firebase not available' };
            }

            let backupData;
            
            if (backupId) {
                // Restore from specific backup
                const backupDoc = await db.collection('backups').doc(backupId).get();
                if (!backupDoc.exists) {
                    return { success: false, error: 'Backup not found' };
                }
                backupData = backupDoc.data();
            } else {
                // Restore from latest backup
                const backupsSnapshot = await db.collection('backups')
                    .orderBy('system_info.timestamp', 'desc')
                    .limit(1)
                    .get();
                
                if (backupsSnapshot.empty) {
                    return { success: false, error: 'No backups found' };
                }
                
                backupData = backupsSnapshot.docs[0].data();
                backupId = backupsSnapshot.docs[0].id;
            }

            console.log(`ðŸ”„ Restoring from backup: ${backupId}`);
            console.log(`ðŸ“Š Backup contains: ${backupData.users?.length || 0} users, ${backupData.payments?.length || 0} payments`);

            let restoredCount = 0;
            let errorCount = 0;

            // Restore Users
            if (backupData.users && backupData.users.length > 0) {
                for (const user of backupData.users) {
                    try {
                        await db.collection('users').doc(user.id.toString()).set(user, { merge: true });
                        
                        // Update local storage
                        persistentStorage.userDatabase.set(user.id, user);
                        
                        restoredCount++;
                        
                        // Add delay to avoid rate limits
                        if (restoredCount % 50 === 0) {
                            await new Promise(resolve => setTimeout(resolve, 100));
                        }
                    } catch (userError) {
                        console.error(`Error restoring user ${user.id}:`, userError);
                        errorCount++;
                    }
                }
            }

            // Restore Payments
            if (backupData.payments && backupData.payments.length > 0) {
                for (const payment of backupData.payments) {
                    try {
                        await db.collection('payments').doc(payment.id).set(payment, { merge: true });
                        persistentStorage.paymentDatabase.set(payment.id, payment);
                    } catch (paymentError) {
                        console.error(`Error restoring payment ${payment.id}:`, paymentError);
                        errorCount++;
                    }
                }
            }

            // Restore Settings
            if (backupData.settings) {
                try {
                    await db.collection('settings').doc('config').set(backupData.settings, { merge: true });
                    persistentStorage.settingsDatabase.set('config', backupData.settings);
                } catch (settingsError) {
                    console.error('Error restoring settings:', settingsError);
                    errorCount++;
                }
            }

            console.log(`âœ… Restore completed: ${restoredCount} users restored, ${errorCount} errors`);
            
            return {
                success: true,
                restoredCount,
                errorCount,
                backupId,
                backupTime: backupData.system_info?.timestamp
            };

        } catch (error) {
            console.error('âŒ Restore failed:', error);
            return { success: false, error: error.message };
        }
    }

    async listBackups() {
        try {
            if (!db) {
                console.log('âŒ Firebase not available');
                return [];
            }

            const backupsSnapshot = await db.collection('backups')
                .orderBy('system_info.timestamp', 'desc')
                .limit(10)
                .get();

            return backupsSnapshot.docs.map(doc => ({
                id: doc.id,
                ...doc.data().system_info,
                userCount: doc.data().users?.length || 0,
                paymentCount: doc.data().payments?.length || 0
            }));
        } catch (error) {
            console.error('Error listing backups:', error);
            return [];
        }
    }

    async deleteOldBackups(keepCount = 5) {
        try {
            if (!db) {
                return { success: false, error: 'Firebase not available' };
            }

            const backupsSnapshot = await db.collection('backups')
                .orderBy('system_info.timestamp', 'desc')
                .get();

            const backups = backupsSnapshot.docs;
            
            if (backups.length <= keepCount) {
                return { success: true, deleted: 0, message: 'No old backups to delete' };
            }

            const backupsToDelete = backups.slice(keepCount);
            let deletedCount = 0;

            for (const backupDoc of backupsToDelete) {
                try {
                    await db.collection('backups').doc(backupDoc.id).delete();
                    deletedCount++;
                } catch (deleteError) {
                    console.error(`Error deleting backup ${backupDoc.id}:`, deleteError);
                }
            }

            console.log(`ðŸ—‘ï¸ Deleted ${deletedCount} old backups`);
            return { success: true, deleted: deletedCount };

        } catch (error) {
            console.error('Error deleting old backups:', error);
            return { success: false, error: error.message };
        }
    }

    startAutoBackup(intervalMinutes = 60) {
        if (this.backupInterval) {
            clearInterval(this.backupInterval);
        }

        this.backupInterval = setInterval(async () => {
            console.log('ðŸ”„ Auto-backup in progress...');
            const success = await this.createBackup();
            if (success) {
                // Delete old backups after successful backup
                await this.deleteOldBackups(10);
            }
        }, intervalMinutes * 60 * 1000);

        console.log(`âœ… Auto-backup started (every ${intervalMinutes} minutes)`);
    }

    stopAutoBackup() {
        if (this.backupInterval) {
            clearInterval(this.backupInterval);
            this.backupInterval = null;
            console.log('ðŸ›‘ Auto-backup stopped');
        }
    }
}

// INITIALIZE ENHANCED BACKUP SYSTEM
const backupSystem = new EnhancedBackupSystem();

// ðŸ’¾ ENHANCED LOCAL STORAGE WITH BACKUP SYSTEM
class PersistentStorage {
    constructor() {
        this.userDatabase = new Map();
        this.paymentDatabase = new Map();
        this.settingsDatabase = new Map();
        this.backupInterval = null;
        this.init();
    }

    async init() {
        // ðŸ—„ï¸ LOAD DATA FROM FIREBASE ON STARTUP
        await this.loadFromFirebase();
        
        // ðŸ”„ AUTO BACKUP EVERY 60 MINUTES
        backupSystem.startAutoBackup(60);
        
        console.log(`âœ… Persistent storage initialized: ${this.userDatabase.size} users loaded`);
    }

    async loadFromFirebase() {
        try {
            if (db) {
                console.log('ðŸ“¥ Loading data from Firebase...');
                
                // ðŸ“¥ LOAD USERS FROM FIREBASE
                const usersSnapshot = await db.collection('users').get();
                let userCount = 0;
                usersSnapshot.forEach(doc => {
                    this.userDatabase.set(doc.id, doc.data());
                    userCount++;
                });

                // ðŸ“¥ LOAD PAYMENTS FROM FIREBASE
                const paymentsSnapshot = await db.collection('payments').get();
                let paymentCount = 0;
                paymentsSnapshot.forEach(doc => {
                    this.paymentDatabase.set(doc.id, doc.data());
                    paymentCount++;
                });

                // ðŸ“¥ LOAD SETTINGS FROM FIREBASE
                const settingsDoc = await db.collection('settings').doc('config').get();
                if (settingsDoc.exists) {
                    this.settingsDatabase.set('config', settingsDoc.data());
                }

                console.log(`âœ… Loaded from Firebase: ${userCount} users, ${paymentCount} payments`);
                
            } else {
                console.log('âŒ Firebase not available, using local storage only');
            }
        } catch (error) {
            console.error('âŒ Error loading from Firebase:', error);
        }
    }

    async createBackup() {
        return await backupSystem.createBackup();
    }

    // ðŸ›‘ STOP BACKUP INTERVAL ON SHUTDOWN
    stop() {
        backupSystem.stopAutoBackup();
    }
}

// INITIALIZE PERSISTENT STORAGE
const persistentStorage = new PersistentStorage();

// ðŸ’¾ ENHANCED DATABASE MANAGER - PERSISTENT DATA
class EnhancedDatabaseManager {
    constructor() {
        this.maintenanceMode = false;
        this.storage = persistentStorage;
        this.firebaseEnabled = false;
        this.init();
    }

    async init() {
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø§Ù„Ø© Firebase
        try {
            if (db) {
                const testDoc = await db.collection('connection_test').doc('test').get();
                this.firebaseEnabled = testDoc.exists;
                console.log(`âœ… Firebase status: ${this.firebaseEnabled ? 'ENABLED' : 'DISABLED'}`);
            }
        } catch (error) {
            console.log('âŒ Firebase check failed:', error.message);
            this.firebaseEnabled = false;
        }
    }

    async getUser(userId) {
        try {
            // ðŸ”„ TRY FIREBASE FIRST
            if (this.firebaseEnabled && db) {
                const userDoc = await db.collection('users').doc(userId.toString()).get();
                if (userDoc.exists) {
                    const userData = userDoc.data();
                    // ðŸ—„ï¸ SYNC WITH LOCAL STORAGE
                    this.storage.userDatabase.set(userId, userData);
                    return userData;
                }
            }
            
            // ðŸ”„ FALLBACK TO LOCAL STORAGE
            return this.storage.userDatabase.get(userId) || null;
            
        } catch (error) {
            console.error('Get user error:', error);
            return this.storage.userDatabase.get(userId) || null;
        }
    }

    async saveUser(userId, userData) {
        try {
            const completeUserData = {
                user_id: userId,
                username: userData.username || 'Unknown',
                onexbet: userData.onexbet || '',
                country: userData.country || '',
                free_attempts: userData.free_attempts || 0,
                subscription_status: userData.subscription_status || 'free',
                subscription_type: userData.subscription_type || 'none',
                subscription_start_date: userData.subscription_start_date || null,
                subscription_end_date: userData.subscription_end_date || null,
                joined_at: userData.joined_at || new Date().toISOString(),
                total_predictions: userData.total_predictions || 0,
                correct_predictions: userData.correct_predictions || 0,
                wins: userData.wins || 0,
                losses: userData.losses || 0,
                total_bets: userData.total_bets || 0,
                total_profit: userData.total_profit || 0,
                last_updated: new Date().toISOString(),
                algorithm_linked: userData.algorithm_linked || true,
                last_algorithm_check: userData.last_algorithm_check || new Date().toISOString()
            };

            // ðŸ’¾ SAVE TO FIREBASE (PRIMARY)
            if (this.firebaseEnabled && db) {
                await db.collection('users').doc(userId.toString()).set(completeUserData, { merge: true });
            }
            
            // ðŸ’¾ SAVE TO LOCAL STORAGE (BACKUP)
            this.storage.userDatabase.set(userId, completeUserData);
            
            return true;
            
        } catch (error) {
            console.error('Error saving user:', error);
            // ðŸ†˜ EMERGENCY SAVE TO LOCAL STORAGE
            this.storage.userDatabase.set(userId, userData);
            return true;
        }
    }

    async getSettings() {
        try {
            // ðŸ”„ TRY FIREBASE FIRST
            if (this.firebaseEnabled && db) {
                const settingsDoc = await db.collection('settings').doc('config').get();
                if (settingsDoc.exists) {
                    const settingsData = settingsDoc.data();
                    // ðŸ—„ï¸ SYNC WITH LOCAL STORAGE
                    this.storage.settingsDatabase.set('config', settingsData);
                    return settingsData;
                }
            }
            
            // ðŸ”„ FALLBACK TO LOCAL STORAGE OR DEFAULT
            return this.storage.settingsDatabase.get('config') || {
                prices: { 
                    binance: { ...CONFIG.SUBSCRIPTION_PRICES.binance },
                    bank: { ...CONFIG.SUBSCRIPTION_PRICES.bank }
                },
                payment_links: { 
                    binance: { ...CONFIG.PAYMENT_LINKS.binance },
                    bank: { ...CONFIG.PAYMENT_LINKS.bank }
                },
                maintenance_mode: false,
                updated_at: new Date().toISOString()
            };
            
        } catch (error) {
            console.error('Get settings error:', error);
            return this.storage.settingsDatabase.get('config') || {
                prices: { 
                    binance: { ...CONFIG.SUBSCRIPTION_PRICES.binance },
                    bank: { ...CONFIG.SUBSCRIPTION_PRICES.bank }
                },
                payment_links: { 
                    binance: { ...CONFIG.PAYMENT_LINKS.binance },
                    bank: { ...CONFIG.PAYMENT_LINKS.bank }
                },
                maintenance_mode: false,
                updated_at: new Date().toISOString()
            };
        }
    }

    async updateSettings(newSettings) {
        try {
            const updatedSettings = {
                ...newSettings,
                updated_at: new Date().toISOString()
            };

            // ðŸ’¾ SAVE TO FIREBASE (PRIMARY)
            if (this.firebaseEnabled && db) {
                await db.collection('settings').doc('config').set(updatedSettings, { merge: true });
            }
            
            // ðŸ’¾ SAVE TO LOCAL STORAGE (BACKUP)
            this.storage.settingsDatabase.set('config', updatedSettings);
            
            return updatedSettings;
            
        } catch (error) {
            console.error('Update settings error:', error);
            const updatedSettings = {
                ...newSettings,
                updated_at: new Date().toISOString()
            };
            this.storage.settingsDatabase.set('config', updatedSettings);
            return updatedSettings;
        }
    }

    async getAllUsers() {
        try {
            // ðŸ”„ TRY FIREBASE FIRST
            if (this.firebaseEnabled && db) {
                const usersSnapshot = await db.collection('users').get();
                const users = usersSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                
                // ðŸ—„ï¸ SYNC WITH LOCAL STORAGE
                users.forEach(user => {
                    this.storage.userDatabase.set(user.user_id, user);
                });
                
                return users;
            }
            
            // ðŸ”„ FALLBACK TO LOCAL STORAGE
            return Array.from(this.storage.userDatabase.entries()).map(([id, data]) => ({ id, ...data }));
            
        } catch (error) {
            console.error('Get all users error:', error);
            return Array.from(this.storage.userDatabase.entries()).map(([id, data]) => ({ id, ...data }));
        }
    }

    async addPayment(paymentData) {
        const paymentId = Date.now().toString();
        try {
            const fullPaymentData = {
                ...paymentData,
                id: paymentId,
                status: 'pending',
                timestamp: new Date().toISOString()
            };

            // ðŸ’¾ SAVE TO FIREBASE (PRIMARY)
            if (this.firebaseEnabled && db) {
                await db.collection('payments').doc(paymentId).set(fullPaymentData);
            }
            
            // ðŸ’¾ SAVE TO LOCAL STORAGE (BACKUP)
            this.storage.paymentDatabase.set(paymentId, fullPaymentData);
            
            return paymentId;
            
        } catch (error) {
            console.error('Add payment error:', error);
            const fullPaymentData = {
                ...paymentData,
                id: paymentId,
                status: 'pending',
                timestamp: new Date().toISOString()
            };
            this.storage.paymentDatabase.set(paymentId, fullPaymentData);
            return paymentId;
        }
    }

    async updatePayment(paymentId, updates) {
        try {
            // ðŸ”„ UPDATE FIREBASE
            if (this.firebaseEnabled && db) {
                await db.collection('payments').doc(paymentId).update(updates);
            }
            
            // ðŸ”„ UPDATE LOCAL STORAGE
            const payment = this.storage.paymentDatabase.get(paymentId);
            if (payment) {
                this.storage.paymentDatabase.set(paymentId, { ...payment, ...updates });
            }
            
            return true;
            
        } catch (error) {
            console.error('Update payment error:', error);
            const payment = this.storage.paymentDatabase.get(paymentId);
            if (payment) {
                this.storage.paymentDatabase.set(paymentId, { ...payment, ...updates });
            }
            return true;
        }
    }

    async getPayment(paymentId) {
        try {
            // ðŸ”„ TRY FIREBASE FIRST
            if (this.firebaseEnabled && db) {
                const paymentDoc = await db.collection('payments').doc(paymentId).get();
                if (paymentDoc.exists) {
                    const paymentData = paymentDoc.data();
                    // ðŸ—„ï¸ SYNC WITH LOCAL STORAGE
                    this.storage.paymentDatabase.set(paymentId, paymentData);
                    return paymentData;
                }
            }
            
            // ðŸ”„ FALLBACK TO LOCAL STORAGE
            return this.storage.paymentDatabase.get(paymentId) || null;
            
        } catch (error) {
            console.error('Get payment error:', error);
            return this.storage.paymentDatabase.get(paymentId) || null;
        }
    }

    async getAllPayments() {
        try {
            // ðŸ”„ TRY FIREBASE FIRST
            if (this.firebaseEnabled && db) {
                const paymentsSnapshot = await db.collection('payments').get();
                const payments = paymentsSnapshot.docs.map(doc => doc.data());
                
                // ðŸ—„ï¸ SYNC WITH LOCAL STORAGE
                payments.forEach(payment => {
                    this.storage.paymentDatabase.set(payment.id, payment);
                });
                
                return payments;
            }
            
            // ðŸ”„ FALLBACK TO LOCAL STORAGE
            return Array.from(this.storage.paymentDatabase.values());
            
        } catch (error) {
            console.error('Get all payments error:', error);
            return Array.from(this.storage.paymentDatabase.values());
        }
    }

    async getPendingPayments() {
        try {
            const payments = await this.getAllPayments();
            return payments.filter(p => p.status === 'pending');
        } catch (error) {
            console.error('Get pending payments error:', error);
            return Array.from(this.storage.paymentDatabase.values()).filter(p => p.status === 'pending');
        }
    }

    // ðŸ”„ SYNC ALL DATA TO FIREBASE
    async syncAllDataToFirebase() {
        try {
            if (!this.firebaseEnabled || !db) {
                console.log('âŒ Firebase not available for sync');
                return false;
            }

            console.log('ðŸ”„ Starting data synchronization to Firebase...');

            // ðŸ“¤ SYNC USERS
            const users = Array.from(this.storage.userDatabase.entries());
            let userCount = 0;
            
            for (const [userId, userData] of users) {
                try {
                    await db.collection('users').doc(userId.toString()).set(userData, { merge: true });
                    userCount++;
                    
                    // ØªØ£Ø®ÙŠØ± Ø¨Ø³ÙŠØ· Ù„ØªØ¬Ù†Ø¨ ØªØ¬Ø§ÙˆØ² Ø­Ø¯ÙˆØ¯ Firebase
                    if (userCount % 50 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                } catch (userError) {
                    console.error(`Error syncing user ${userId}:`, userError);
                }
            }

            console.log(`âœ… Data sync completed: ${userCount} users`);
            return true;

        } catch (error) {
            console.error('Data sync error:', error);
            return false;
        }
    }

    // ðŸ“¥ RESTORE FROM FIREBASE
    async restoreFromFirebase() {
        try {
            if (!this.firebaseEnabled || !db) {
                console.log('âŒ Firebase not available for restore');
                return false;
            }

            console.log('ðŸ“¥ Restoring data from Firebase...');

            // CLEAR LOCAL STORAGE
            this.storage.userDatabase.clear();

            // ðŸ“¥ RESTORE USERS
            const usersSnapshot = await db.collection('users').get();
            let restoredCount = 0;
            
            usersSnapshot.forEach(doc => {
                const userData = doc.data();
                this.storage.userDatabase.set(doc.id, userData);
                restoredCount++;
            });

            console.log(`âœ… Restore completed: ${restoredCount} users`);
            return true;

        } catch (error) {
            console.error('Restore error:', error);
            return false;
        }
    }

    // ðŸ” NEW: Get user by 1xBet account number
    async getUserByOneXBet(onexbet) {
        try {
            // ðŸ”„ TRY FIREBASE FIRST
            if (this.firebaseEnabled && db) {
                const usersSnapshot = await db.collection('users').where('onexbet', '==', onexbet).get();
                if (!usersSnapshot.empty) {
                    const userData = usersSnapshot.docs[0].data();
                    // ðŸ—„ï¸ SYNC WITH LOCAL STORAGE
                    this.storage.userDatabase.set(userData.user_id, userData);
                    return userData;
                }
            }

            // ðŸ”„ CHECK LOCAL STORAGE
            for (let [userId, userData] of this.storage.userDatabase) {
                if (userData.onexbet === onexbet) {
                    return userData;
                }
            }
            return null;
            
        } catch (error) {
            console.error('Get user by onexbet error:', error);
            // ðŸ”„ FALLBACK TO LOCAL STORAGE
            for (let [userId, userData] of this.storage.userDatabase) {
                if (userData.onexbet === onexbet) {
                    return userData;
                }
            }
            return null;
        }
    }

    async searchUsers(query) {
        try {
            const users = await this.getAllUsers();
            const lowerQuery = query.toLowerCase();
            
            return users.filter(user => 
                (user.user_id && user.user_id.toString().includes(query)) ||
                (user.username && user.username.toLowerCase().includes(lowerQuery)) ||
                (user.onexbet && user.onexbet.toString().includes(query))
            );
        } catch (error) {
            console.error('Search users error:', error);
            return [];
        }
    }

    // ðŸ”„ BACKUP SYSTEM METHODS
    async createBackup() {
        try {
            const result = await backupSystem.createBackup();
            return result;
        } catch (error) {
            console.error('Backup creation error:', error);
            return false;
        }
    }

    async restoreFromBackup(backupId = null) {
        try {
            const result = await backupSystem.restoreFromBackup(backupId);
            return result;
        } catch (error) {
            console.error('Restore error:', error);
            return { success: false, error: error.message };
        }
    }

    async listBackups() {
        return await backupSystem.listBackups();
    }

    async deleteOldBackups(keepCount = 5) {
        return await backupSystem.deleteOldBackups(keepCount);
    }

    isMaintenanceMode() {
        return this.maintenanceMode;
    }

    async setMaintenanceMode(enabled) {
        try {
            const settings = await this.getSettings();
            settings.maintenance_mode = enabled;
            await this.updateSettings(settings);
            this.maintenanceMode = enabled;
            return true;
        } catch (error) {
            this.maintenanceMode = enabled;
            return true;
        }
    }
}

// INITIALIZE ENHANCED DATABASE MANAGER
const dbManager = new EnhancedDatabaseManager();

// ðŸš€ INITIAL DATA SYNC ON STARTUP
async function initializeDataSync() {
    try {
        console.log('ðŸ”„ Initializing data synchronization...');
        
        // ðŸ“¥ TRY TO RESTORE FROM FIREBASE FIRST
        const restoreSuccess = await dbManager.restoreFromFirebase();
        
        if (restoreSuccess) {
            console.log('âœ… Data restored successfully from Firebase');
        } else {
            console.log('ðŸ”„ No Firebase data found, checking local storage...');
            
            // ðŸ“Š CHECK IF WE HAVE LOCAL DATA
            const users = await dbManager.getAllUsers();
            
            console.log(`ðŸ“Š Local data found: ${users.length} users`);
            
            // ðŸ“¤ SYNC LOCAL DATA TO FIREBASE
            if (users.length > 0) {
                const syncSuccess = await dbManager.syncAllDataToFirebase();
                if (syncSuccess) {
                    console.log('âœ… Local data synced to Firebase');
                }
            }
        }
        
        console.log('âœ… Data initialization completed');
        
    } catch (error) {
        console.error('Data initialization error:', error);
    }
}

// ðŸ”„ CALL INITIALIZATION ON STARTUP - Ù…Ø¹ ØªØ£Ø®ÙŠØ± Ù„Ø¶Ù…Ø§Ù† Ø§ÙƒØªÙ…Ø§Ù„ ØªÙ‡ÙŠØ¦Ø© Firebase
setTimeout(() => {
    initializeDataSync();
}, 3000);

// ðŸ“Š DYNAMIC STATISTICS SYSTEM
class DynamicStatistics {
    constructor() {
        this.totalUsers = 78542;
        this.activeUsers = 300;
        this.lastCallTime = Date.now();
        this.callCount = 0;
    }

    getStats() {
        const now = Date.now();
        
        // Ø²ÙŠØ§Ø¯Ø© Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù†Ø´Ø·ÙŠÙ† Ø¹Ù†Ø¯ ÙƒÙ„ Ø·Ù„Ø¨ Ù…Ø¨Ø§Ø´Ø±Ø©
        this.callCount++;
        
        // Ø²ÙŠØ§Ø¯Ø© Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© Ø¨ÙŠÙ† 1-5 Ø¹Ù†Ø¯ ÙƒÙ„ Ø·Ù„Ø¨
        const randomIncrement = Math.floor(Math.random() * 5) + 1;
        this.activeUsers += randomIncrement;
        
        // Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ 5000 Ø«Ù… Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù€ 300
        if (this.activeUsers > 5000) {
            this.activeUsers = 300;
        }
        
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙˆÙ‚Øª Ø¹Ù†Ø¯ ÙƒÙ„ Ø·Ù„Ø¨
        this.lastCallTime = now;

        return {
            totalUsers: this.totalUsers,
            activeUsers: this.activeUsers
        };
    }
}

// ðŸ§  SMART GOAL PREDICTION ENGINE
class GoalPredictionAI {
    constructor() {
        this.algorithmVersion = "16.0";
    }

    generateSmartPrediction(userId) {
        const isGoal = Math.random() > 0.5;
        const probability = Math.floor(Math.random() * 30) + 60;
        
        // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ Ø§Ù„Ø­Ø§Ù„ÙŠ
        const now = new Date();
        const saudiTime = new Date(now.getTime() + (3 * 60 * 60 * 1000)); // ØªÙˆÙ‚ÙŠØª Ø§Ù„Ø³Ø¹ÙˆØ¯ÙŠØ© +3
        const realTime = saudiTime.toLocaleTimeString('ar-SA', { 
            hour: '2-digit', 
            minute: '2-digit',
            second: '2-digit',
            hour12: false 
        });
        
        const prediction = {
            type: isGoal ? 'âš½ GOAL' : 'ðŸ›‘ NO GOAL',
            probability: probability,
            confidence: 100,
            reasoning: isGoal ? 
                `ðŸ”¥ Ø§Ù„Ø¶ØºØ· Ø§Ù„Ù‡Ø¬ÙˆÙ…ÙŠ Ø§Ù„Ù…Ø³ØªÙ…Ø± ÙŠØ´ÙŠØ± Ù„Ù‡Ø¯Ù Ù‚Ø±ÙŠØ¨ Ø¨Ù†Ø³Ø¨Ø© ${probability}%` :
                `ðŸ›¡ï¸ Ø§Ù„Ø¯ÙØ§Ø¹ Ø§Ù„Ù…Ù†Ø¸Ù… ÙŠØ­Ø¯ Ù…Ù† Ø§Ù„ÙØ±Øµ Ø¨Ù†Ø³Ø¨Ø© ${probability}%`,
            timestamp: realTime,
            algorithm: this.algorithmVersion
        };

        return prediction;
    }

    generateNextPrediction(userId) {
        return this.generateSmartPrediction(userId);
    }
}

// ðŸ“¤ IMGBB UPLOADER - ENHANCED
class ImgBBUploader {
    constructor(apiKey) {
        this.apiKey = apiKey;
        this.baseUrl = 'https://api.imgbb.com/1/upload';
    }

    async uploadImage(imageBuffer) {
        try {
            const FormData = require('form-data');
            const formData = new FormData();
            
            formData.append('key', this.apiKey);
            formData.append('image', imageBuffer.toString('base64'));
            
            const response = await axios.post(this.baseUrl, formData, {
                headers: {
                    ...formData.getHeaders()
                },
                timeout: 30000
            });
            
            if (response.data && response.data.success) {
                return {
                    success: true,
                    url: response.data.data.url,
                    display_url: response.data.data.display_url,
                    thumb_url: response.data.data.thumb?.url || response.data.data.url,
                    delete_url: response.data.data.delete_url
                };
            } else {
                return {
                    success: false,
                    error: 'Upload failed'
                };
            }
        } catch (error) {
            console.error('ImgBB upload error:', error);
            return {
                success: false,
                error: error.message
            };
        }
    }

    async uploadImageFromUrl(imageUrl) {
        try {
            const response = await axios.get(imageUrl, { 
                responseType: 'arraybuffer',
                timeout: 30000
            });
            const imageBuffer = Buffer.from(response.data);
            return await this.uploadImage(imageBuffer);
        } catch (error) {
            console.error('ImgBB upload from URL error:', error);
            return {
                success: false,
                error: error.message
            };
        }
    }
}

// INITIALIZE SYSTEMS
const goalAI = new GoalPredictionAI();
const dynamicStats = new DynamicStatistics();
const imgbbUploader = new ImgBBUploader(CONFIG.IMGBB_API_KEY);

// ðŸ“¢ CHANNEL NOTIFICATION SYSTEM
class ChannelNotifier {
    constructor(bot, channelId) {
        this.bot = bot;
        this.channelId = channelId;
    }

    async sendSubscriptionNotification(userData, subscriptionType, amount, paymentSystem) {
        try {
            const systemText = paymentSystem === 'binance' ? 'Ø¨Ø§ÙŠÙ†Ø§Ù†Ø³' : 'ØªØ­ÙˆÙŠÙ„ Ø¨Ù†ÙƒÙŠ';
            const subscriptionDisplayName = getSubscriptionDisplayName(subscriptionType);
            
            const message = `
ðŸŽ‰ *Ø§Ø´ØªØ±Ø§Ùƒ Ø¬Ø¯ÙŠØ¯ ÙÙŠ Ø§Ù„Ø¨ÙˆØª - ${systemText}*

ðŸ‘¤ *Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:* ${userData.username}
ðŸ” *Ø§Ù„Ø­Ø³Ø§Ø¨:* ${userData.onexbet}
ðŸ“¦ *Ø§Ù„Ø¨Ø§Ù‚Ø©:* ${subscriptionDisplayName}
ðŸ’° *Ø§Ù„Ù…Ø¨Ù„Øº:* ${amount}$
ðŸ’³ *Ø§Ù„Ù†Ø¸Ø§Ù…:* ${systemText}

ðŸ•’ *Ø§Ù„ÙˆÙ‚Øª:* ${new Date().toLocaleString('ar-EG')}
            `;

            await this.bot.telegram.sendMessage(this.channelId, message, {
                parse_mode: 'Markdown'
            });
        } catch (error) {
            console.error('Error sending subscription notification:', error);
        }
    }

    async sendPredictionNotification(userData, prediction, betAmount) {
        try {
            const message = `
ðŸŽ¯ *ØªÙˆÙ‚Ø¹ Ø¬Ø¯ÙŠØ¯ ÙÙŠ Ø§Ù„Ø¨ÙˆØª*

ðŸ‘¤ *Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:* ${userData.username}
ðŸ” *Ø§Ù„Ø­Ø³Ø§Ø¨:* ${userData.onexbet}
ðŸŽ¯ *Ø§Ù„ØªÙˆÙ‚Ø¹:* ${prediction.type}
ðŸ“ˆ *Ø§Ù„Ø§Ø­ØªÙ…Ø§Ù„ÙŠØ©:* ${prediction.probability}%
ðŸ’° *Ù…Ø¨Ù„Øº Ø§Ù„Ø±Ù‡Ø§Ù†:* ${betAmount}$

ðŸ’¡ *Ø§Ù„ØªØ­Ù„ÙŠÙ„:*
${prediction.reasoning}

ðŸ•’ *Ø§Ù„ÙˆÙ‚Øª:* ${new Date().toLocaleString('ar-EG')}
            `;

            await this.bot.telegram.sendMessage(this.channelId, message, {
                parse_mode: 'Markdown'
            });
        } catch (error) {
            console.error('Error sending prediction notification:', error);
        }
    }
}

const channelNotifier = new ChannelNotifier(bot, CONFIG.CHANNEL_ID);

// ðŸŽ¯ BOT SETUP
bot.use(session({ 
    defaultSession: () => ({ 
        step: 'start',
        userData: {},
        verificationCode: null,
        accountId: null,
        paymentType: null,
        paymentSystem: null,
        adminMode: false,
        adminStep: null,
        awaitingPaymentAccount: false,
        paymentAccount: null,
        currentBet: 0,
        originalBet: 0,
        totalProfit: 0,
        awaitingBetAmount: false,
        searchQuery: null,
        broadcastMessage: null,
        adminSettingsStep: null,
        selectedPaymentType: null,
        editingSubscriptionType: null,
        adminPaymentSystem: null,
        awaitingBankImage: false,
        editingBankStep: null,
        bankEditData: {},
        checkingChannel: false,
        country: null,
        awaitingCountry: false,
        lastPredictionTime: null,
        predictionButtons: null
    })
}));

// ðŸŽ¯ Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ø«Ø§Ø¨ØªØ© - UPDATED FOR DUAL PAYMENT
const getMainKeyboard = () => {
    return Markup.keyboard([
        ['ðŸŽ¯ Ø¬Ù„Ø¨ Ø§Ù„ØªØ­Ù„ÙŠÙ„', 'ðŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§ØªÙŠ'],
        ['ðŸ’³ Ø§Ù„Ø§Ø´ØªØ±Ø§ÙƒØ§Øª', 'ðŸ‘¥ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØª'],
        ['ðŸ‘¤ Ø­Ø§Ù„Ø© Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ', 'ðŸ†˜ Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ']
    ]).resize();
};

const getLoginKeyboard = () => {
    return Markup.keyboard([
        ['ðŸ” Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨']
    ]).resize();
};

// ðŸ†• Ù„ÙˆØ­Ø© Ø§Ø®ØªÙŠØ§Ø± Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
const getPaymentMethodKeyboard = () => {
    return Markup.keyboard([
        ['ðŸ’³ Ø¨Ø§ÙŠÙ†Ø§Ù†Ø³', 'ðŸ¦ ØªØ­ÙˆÙŠÙ„ Ø¨Ù†ÙƒÙŠ'],
        ['ðŸ”™ Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø©']
    ]).resize();
};

const getSubscriptionKeyboard = () => {
    return Markup.keyboard([
        ['ðŸ’° Ø£Ø³Ø¨ÙˆØ¹ÙŠ', 'ðŸ’° Ø´Ù‡Ø±ÙŠ'],
        ['ðŸ’° 3 Ø£Ø´Ù‡Ø±', 'ðŸ’° Ø³Ù†ÙˆÙŠ'],
        ['ðŸ”™ Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø©']
    ]).resize();
};

// ðŸ†• Ù„ÙˆØ­Ø© Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø¯ÙˆÙ„ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©
const getCountriesKeyboard = () => {
    return Markup.keyboard([
        ['ðŸ‡¸ðŸ‡¦ Ø§Ù„Ø³Ø¹ÙˆØ¯ÙŠØ©', 'ðŸ‡¦ðŸ‡ª Ø§Ù„Ø¥Ù…Ø§Ø±Ø§Øª', 'ðŸ‡¶ðŸ‡¦ Ù‚Ø·Ø±'],
        ['ðŸ‡°ðŸ‡¼ Ø§Ù„ÙƒÙˆÙŠØª', 'ðŸ‡§ðŸ‡­ Ø§Ù„Ø¨Ø­Ø±ÙŠÙ†', 'ðŸ‡´ðŸ‡² Ø¹Ù…Ø§Ù†'],
        ['ðŸ‡¾ðŸ‡ª Ø§Ù„ÙŠÙ…Ù†', 'ðŸ‡®ðŸ‡¶ Ø§Ù„Ø¹Ø±Ø§Ù‚', 'ðŸ‡¸ðŸ‡¾ Ø³ÙˆØ±ÙŠØ§'],
        ['ðŸ‡¯ðŸ‡´ Ø§Ù„Ø£Ø±Ø¯Ù†', 'ðŸ‡±ðŸ‡§ Ù„Ø¨Ù†Ø§Ù†', 'ðŸ‡ªðŸ‡¬ Ù…ØµØ±'],
        ['ðŸ‡©ðŸ‡¿ Ø§Ù„Ø¬Ø²Ø§Ø¦Ø±', 'ðŸ‡²ðŸ‡¦ Ø§Ù„Ù…ØºØ±Ø¨', 'ðŸ‡¹ðŸ‡³ ØªÙˆÙ†Ø³'],
        ['ðŸ‡±ðŸ‡¾ Ù„ÙŠØ¨ÙŠØ§', 'ðŸ‡¸ðŸ‡© Ø§Ù„Ø³ÙˆØ¯Ø§Ù†', 'ðŸ‡¸ðŸ‡¸ Ø¬Ù†ÙˆØ¨ Ø§Ù„Ø³ÙˆØ¯Ø§Ù†'],
        ['ðŸ‡µðŸ‡¸ ÙÙ„Ø³Ø·ÙŠÙ†', 'ðŸ‡²ðŸ‡· Ù…ÙˆØ±ÙŠØªØ§Ù†ÙŠØ§', 'ðŸ‡©ðŸ‡¯ Ø¬ÙŠØ¨ÙˆØªÙŠ'],
        ['ðŸ‡¸ðŸ‡´ Ø§Ù„ØµÙˆÙ…Ø§Ù„', 'ðŸ‡°ðŸ‡² Ø¬Ø²Ø± Ø§Ù„Ù‚Ù…Ø±']
    ]).resize();
};

// ðŸ”„ UPDATE ADMIN KEYBOARD WITH DATA MANAGEMENT
const getAdminMainKeyboard = () => {
    return Markup.keyboard([
        ['ðŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù†Ø¸Ø§Ù…', 'ðŸ‘¥ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†'],
        ['ðŸ’° Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ø¯ÙØ¹', 'âš™ï¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª'],
        ['ðŸ“¢ Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø±', 'ðŸ” Ø¨Ø­Ø« Ø¹Ù† Ù…Ø³ØªØ®Ø¯Ù…'],
        ['ðŸ’¾ Ù†Ø³Ø® Ø§Ø­ØªÙŠØ§Ø·ÙŠ', 'ðŸ“¥ Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª'],
        ['ðŸ”§ Ù‚ÙÙ„/ÙØªØ­ Ø§Ù„Ø¨ÙˆØª', 'ðŸ”™ Ø§Ù„Ø®Ø±ÙˆØ¬ Ù…Ù† Ø§Ù„Ø¥Ø¯Ù…Ù†']
    ]).resize();
};

const getAdminUsersKeyboard = () => {
    return Markup.keyboard([
        ['ðŸ“‹ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†', 'âœ… Ø§Ù„Ù…Ø´ØªØ±ÙƒÙŠÙ† Ø§Ù„Ù†Ø´Ø·ÙŠÙ†'],
        ['ðŸ†“ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠÙ†', 'ðŸ“ˆ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†'],
        ['ðŸ”™ Ø±Ø¬ÙˆØ¹']
    ]).resize();
};

const getAdminPaymentsKeyboard = () => {
    return Markup.keyboard([
        ['ðŸ“¥ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…Ø¹Ù„Ù‚Ø©', 'âœ… Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…Ù‚Ø¨ÙˆÙ„Ø©'],
        ['âŒ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…Ø±ÙÙˆØ¶Ø©', 'ðŸ“‹ ÙƒÙ„ Ø§Ù„Ø·Ù„Ø¨Ø§Øª'],
        ['ðŸ”™ Ø±Ø¬ÙˆØ¹']
    ]).resize();
};

const getAdminSettingsKeyboard = () => {
    return Markup.keyboard([
        ['ðŸ’° ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø£Ø³Ø¹Ø§Ø± ÙˆØ§Ù„Ø¯ÙØ¹', 'âš™ï¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø©'],
        ['ðŸ”„ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ¹ÙŠÙŠÙ†', 'ðŸ”™ Ø±Ø¬ÙˆØ¹']
    ]).resize();
};

const getAdminPaymentTypesKeyboard = () => {
    return Markup.keyboard([
        ['ðŸ’° Ø£Ø³Ø¨ÙˆØ¹ÙŠ', 'ðŸ’° Ø´Ù‡Ø±ÙŠ'],
        ['ðŸ’° 3 Ø£Ø´Ù‡Ø±', 'ðŸ’° Ø³Ù†ÙˆÙŠ'],
        ['ðŸ”™ Ø±Ø¬ÙˆØ¹']
    ]).resize();
};

// ðŸ†• Ù„ÙˆØ­Ø© Ø§Ø®ØªÙŠØ§Ø± Ù†Ø¸Ø§Ù… Ø§Ù„Ø¯ÙØ¹ ÙÙŠ Ø§Ù„Ø¥Ø¯Ù…Ù†
const getAdminPaymentSystemKeyboard = () => {
    return Markup.keyboard([
        ['ðŸ’³ Ù†Ø¸Ø§Ù… Ø¨Ø§ÙŠÙ†Ø§Ù†Ø³', 'ðŸ¦ Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¨Ù†ÙƒÙŠ'],
        ['ðŸ”™ Ø±Ø¬ÙˆØ¹']
    ]).resize();
};

// ðŸ› ï¸ UTILITY FUNCTIONS
function calculateRemainingDays(endDate) {
    try {
        const end = new Date(endDate);
        const now = new Date();
        const diffTime = end - now;
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
        return diffDays > 0 ? diffDays : 0;
    } catch (error) {
        return 0;
    }
}

function addSubscriptionDays(startDate, type) {
    try {
        const start = new Date(startDate);
        const types = {
            week: 7,
            month: 30,
            three_months: 90,
            year: 365
        };
        start.setDate(start.getDate() + types[type]);
        return start.toISOString();
    } catch (error) {
        const newDate = new Date();
        newDate.setDate(newDate.getDate() + 30);
        return newDate.toISOString();
    }
}

// ðŸ†• Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¯Ø© Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ
function getSubscriptionDuration(type) {
    const durations = {
        'week': '7 Ø£ÙŠØ§Ù…',
        'month': '30 ÙŠÙˆÙ…Ø§Ù‹', 
        'three_months': '90 ÙŠÙˆÙ…Ø§Ù‹',
        'year': '365 ÙŠÙˆÙ…Ø§Ù‹'
    };
    return durations[type] || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯';
}

// ðŸ†• Ø¯Ø§Ù„Ø© Ù„Ø¥Ù†Ø´Ø§Ø¡ ÙˆØµÙ Ø§Ù„Ø¨Ù†Ùƒ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
function generateBankDescription(subscriptionType, price, accountNumber) {
    const typeNames = {
        'week': 'Ø£Ø³Ø¨ÙˆØ¹ÙŠØ©',
        'month': 'Ø´Ù‡Ø±ÙŠØ©',
        'three_months': '3 Ø£Ø´Ù‡Ø±',
        'year': 'Ø³Ù†ÙˆÙŠØ©'
    };
    
    return `ðŸ”¹ ØªØ­ÙˆÙŠÙ„ Ø¨Ù†ÙƒÙŠ - Ø¨Ø§Ù‚Ø© ${typeNames[subscriptionType]}\nðŸ’³ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨: ${accountNumber}\nðŸ¦ Ø§Ù„Ø¨Ù†Ùƒ: Ø§Ù„Ø¨Ù†Ùƒ Ø§Ù„ÙƒØ±ÙŠÙ…ÙŠ\nðŸ’° Ø§Ù„Ù…Ø¨Ù„Øº: ${price}$\nðŸ’µ Ø§Ù„Ø¹Ù…Ù„Ø©: Ø§Ù„Ø¯ÙˆÙ„Ø§Ø± Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠ\n\nðŸ“‹ Ø§Ù„Ø´Ø±ÙˆØ·:\nâ€¢ ÙŠØ¬Ø¨ Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø¨Ø§Ù„Ø¯ÙˆÙ„Ø§Ø± Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠ\nâ€¢ Ø¥Ø±ÙØ§Ù‚ ØµÙˆØ±Ø© Ø¥Ø«Ø¨Ø§Øª Ø§Ù„Ø¯ÙØ¹\nâ€¢ ÙƒØªØ§Ø¨Ø© Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ`;
}

// ðŸ†• Ø¯Ø§Ù„Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ø³Ù… Ø§Ù„Ø¹Ø±Ø¶ Ù„Ù„Ø¨Ø§Ù‚Ø© - Ø§Ù„Ø¥ØµÙ„Ø§Ø­ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ Ù‡Ù†Ø§
function getSubscriptionDisplayName(type) {
    const names = {
        'week': 'Ø£Ø³Ø¨ÙˆØ¹ÙŠ',
        'month': 'Ø´Ù‡Ø±ÙŠ', 
        'three_months': '3 Ø£Ø´Ù‡Ø±',
        'year': 'Ø³Ù†ÙˆÙŠ'
    };
    return names[type] || type;
}

// ðŸ†• Ø¯Ø§Ù„Ø© Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© (5 Ø¯Ù‚Ø§Ø¦Ù‚)
function isAlgorithmExpired(lastCheckTime) {
    if (!lastCheckTime) return true;
    const now = new Date();
    const lastCheck = new Date(lastCheckTime);
    const diffMinutes = (now - lastCheck) / (1000 * 60);
    return diffMinutes > 5; // 5 Ø¯Ù‚Ø§Ø¦Ù‚
}

// ðŸ†• Ø¯Ø§Ù„Ø© Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø±Ø¨Ø· Ø§Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ©
async function reconnectAlgorithm(ctx, userData) {
    const userId = ctx.from.id.toString();
    
    // ØªØ­Ø¯ÙŠØ« ÙˆÙ‚Øª Ø§Ù„Ø±Ø¨Ø·
    userData.algorithm_linked = true;
    userData.last_algorithm_check = new Date().toISOString();
    await dbManager.saveUser(userId, userData);
    
    // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø±Ø¨Ø· Ù…Ø¹ Ø¥ÙŠÙ…ÙˆØ¬ÙŠ Ù…ØªØ­Ø±Ùƒ
    const reconnectingMessage = await ctx.replyWithMarkdown(
        'ðŸ”„ *Ø¬Ø§Ø±ÙŠ Ø¥Ø¹Ø§Ø¯Ø© Ø±Ø¨Ø· Ø§Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ©...*\n\n' +
        'âš¡ Ø¬Ø§Ø±ÙŠ ØªÙØ¹ÙŠÙ„ Ù†Ø¸Ø§Ù… Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ...\n' +
        'ðŸ”— Ø¬Ø§Ø±ÙŠ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø³ÙŠØ±ÙØ±...\n' +
        'ðŸŽ¯ Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„...\n\n' +
        'â³ Ù‚Ø¯ ØªØ³ØªØºØ±Ù‚ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø¨Ø¶Ø¹ Ø«ÙˆØ§Ù†ÙŠ...'
    );

    // Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ù…Ø¹ Ø±Ø³Ø§Ø¦Ù„ Ù…ØªØ­Ø±ÙƒØ©
    const loadingEmojis = ['ðŸ”„', 'âš¡', 'ðŸ”—', 'ðŸŽ¯', 'ðŸ¤–'];
    for (let i = 0; i < 5; i++) {
        await new Promise(resolve => setTimeout(resolve, 1000));
        try {
            await ctx.telegram.editMessageText(
                ctx.chat.id,
                reconnectingMessage.message_id,
                null,
                `${loadingEmojis[i]} *Ø¬Ø§Ø±ÙŠ Ø¥Ø¹Ø§Ø¯Ø© Ø±Ø¨Ø· Ø§Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ©...*\n\n` +
                'âš¡ Ø¬Ø§Ø±ÙŠ ØªÙØ¹ÙŠÙ„ Ù†Ø¸Ø§Ù… Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ...\n' +
                'ðŸ”— Ø¬Ø§Ø±ÙŠ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø³ÙŠØ±ÙØ±...\n' +
                'ðŸŽ¯ Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„...\n\n' +
                `ðŸ“ *Ø§Ù„Ø¯ÙˆÙ„Ø©:* ${userData.country || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'}\n` +
                `ðŸ” *Ø§Ù„Ø­Ø³Ø§Ø¨:* \`${userData.onexbet}\``,
                { parse_mode: 'Markdown' }
            );
        } catch (editError) {
            console.log('Error editing reconnection message:', editError);
        }
    }

    // Ø­Ø°Ù Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±
    await ctx.deleteMessage(reconnectingMessage.message_id);
    
    // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªØ£ÙƒÙŠØ¯
    await ctx.replyWithMarkdown(
        'âœ… *ØªÙ… Ø¥Ø¹Ø§Ø¯Ø© Ø±Ø¨Ø· Ø§Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ø¨Ù†Ø¬Ø§Ø­!*\n\n' +
        `ðŸ“ *Ø§Ù„Ø¯ÙˆÙ„Ø©:* ${userData.country || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'}\n` +
        `ðŸ” *Ø§Ù„Ø­Ø³Ø§Ø¨:* \`${userData.onexbet}\`\n` +
        `ðŸ”„ *Ø¢Ø®Ø± ØªØ­Ø¯ÙŠØ«:* ${new Date().toLocaleTimeString('ar-SA')}\n\n` +
        'ðŸŽ¯ *ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¢Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø²Ø± "Ø¬Ù„Ø¨ Ø§Ù„ØªØ­Ù„ÙŠÙ„" Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„ØªÙˆÙ‚Ø¹Ø§Øª*',
        getMainKeyboard()
    );
}

// ðŸŽ¯ BOT COMMANDS

bot.start(async (ctx) => {
    try {
        const settings = await dbManager.getSettings();
        if (settings.maintenance_mode && ctx.from.id.toString() !== CONFIG.ADMIN_ID) {
            await ctx.replyWithMarkdown('ðŸ”§ *Ø§Ù„Ø¨ÙˆØª ØªØ­Øª Ø§Ù„ØµÙŠØ§Ù†Ø©*\n\nâ° Ù†Ø¹Ù…Ù„ Ø¹Ù„Ù‰ ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø®Ø¯Ù…Ø© Ù„ÙƒÙ…\nðŸ”„ Ø³Ù†Ø¹ÙˆØ¯ Ù‚Ø±ÙŠØ¨Ø§Ù‹ Ø¨Ø£ÙØ¶Ù„ Ù…Ù…Ø§ ÙƒØ§Ù†\n\nðŸ“ž Ù„Ù„Ø§Ø³ØªÙØ³Ø§Ø±: @GEMZGOOLBOT');
            return;
        }

        const userId = ctx.from.id.toString();
        const userName = ctx.from.first_name;

        // Ø§Ù„ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø³Ø¬Ù„ Ù…Ø³Ø¨Ù‚Ø§Ù‹
        const existingUser = await dbManager.getUser(userId);
        
        if (existingUser) {
            // Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø³Ø¬Ù„ Ù…Ø³Ø¨Ù‚Ø§Ù‹ - Ø¯Ø®ÙˆÙ„ Ù…Ø¨Ø§Ø´Ø±
            ctx.session.step = 'verified';
            ctx.session.userData = existingUser;

            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ©
            if (isAlgorithmExpired(existingUser.last_algorithm_check)) {
                await ctx.replyWithMarkdown(
                    'ðŸ” *Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ø¹ÙˆØ¯ØªÙƒ!*\n\n' +
                    'âš ï¸ *Ø§Ù†ØªÙ‡Øª Ø¬Ù„Ø³Ø© Ø§Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ©*\n\n' +
                    'ðŸ”„ ØªØ­ØªØ§Ø¬ Ø¥Ù„Ù‰ Ø¥Ø¹Ø§Ø¯Ø© Ø±Ø¨Ø· Ø§Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ø§Ù„ØªØ­Ù„ÙŠÙ„Ø§Øª\n' +
                    `ðŸ“ *Ø§Ù„Ø¯ÙˆÙ„Ø©:* ${existingUser.country || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'}\n` +
                    `ðŸ” *Ø§Ù„Ø­Ø³Ø§Ø¨:* \`${existingUser.onexbet}\`\n\n` +
                    'ðŸ’¡ Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø± Ø£Ø¯Ù†Ø§Ù‡ Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø±Ø¨Ø·:',
                    Markup.inlineKeyboard([
                        [Markup.button.callback('ðŸ”„ Ø¥Ø¹Ø§Ø¯Ø© Ø±Ø¨Ø· Ø§Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ©', 'reconnect_algorithm')]
                    ])
                );
                return;
            }

            const remainingDays = calculateRemainingDays(existingUser.subscription_end_date);
            
            let statusMessage = '';
            if (existingUser.subscription_status === 'active' && remainingDays > 0) {
                statusMessage = `ðŸŽ‰ *Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ø¹ÙˆØ¯ØªÙƒ!*\n\n` +
                               `âœ… *Ø§Ø´ØªØ±Ø§ÙƒÙƒ Ù†Ø´Ø·*\n` +
                               `ðŸ“ *Ø§Ù„Ø¯ÙˆÙ„Ø©:* ${existingUser.country || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'}\n` +
                               `ðŸ” Ø§Ù„Ø­Ø³Ø§Ø¨: \`${existingUser.onexbet}\`\n` +
                               `ðŸ“¦ Ø§Ù„Ù†ÙˆØ¹: ${getSubscriptionDisplayName(existingUser.subscription_type)}\n` +
                               `ðŸ“… Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡: ${new Date(existingUser.subscription_end_date).toLocaleDateString('ar-EG')}\n` +
                               `â³ Ù…ØªØ¨Ù‚ÙŠ: ${remainingDays} ÙŠÙˆÙ…\n` +
                               `ðŸ”„ *Ø¢Ø®Ø± ØªØ­Ø¯ÙŠØ« Ù„Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ©:* ${new Date(existingUser.last_algorithm_check).toLocaleTimeString('ar-SA')}`;
            } else if (existingUser.free_attempts > 0) {
                statusMessage = `ðŸŽ‰ *Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ø¹ÙˆØ¯ØªÙƒ!*\n\n` +
                               `ðŸŽ¯ *Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ù…Ø¬Ø§Ù†ÙŠØ© Ù…ØªØ§Ø­Ø©*\n` +
                               `ðŸ“ *Ø§Ù„Ø¯ÙˆÙ„Ø©:* ${existingUser.country || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'}\n` +
                               `ðŸ” Ø§Ù„Ø­Ø³Ø§Ø¨: \`${existingUser.onexbet}\`\n` +
                               `ðŸ†“ Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ù…Ø¬Ø§Ù†ÙŠØ©: ${existingUser.free_attempts}\n` +
                               `ðŸ”„ *Ø¢Ø®Ø± ØªØ­Ø¯ÙŠØ« Ù„Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ©:* ${new Date(existingUser.last_algorithm_check).toLocaleTimeString('ar-SA')}`;
            } else {
                statusMessage = `ðŸŽ‰ *Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ø¹ÙˆØ¯ØªÙƒ!*\n\n` +
                               `ðŸš« *Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª*\n` +
                               `ðŸ“ *Ø§Ù„Ø¯ÙˆÙ„Ø©:* ${existingUser.country || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'}\n` +
                               `ðŸ” Ø§Ù„Ø­Ø³Ø§Ø¨: \`${existingUser.onexbet}\`\n` +
                               `ðŸ’³ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ù„Ù„Ù…ØªØ§Ø¨Ø¹Ø©\n` +
                               `ðŸ”„ *Ø¢Ø®Ø± ØªØ­Ø¯ÙŠØ« Ù„Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ©:* ${new Date(existingUser.last_algorithm_check).toLocaleTimeString('ar-SA')}`;
            }

            await ctx.replyWithMarkdown(statusMessage, getMainKeyboard());
            
        } else {
            // Ù…Ø³ØªØ®Ø¯Ù… Ø¬Ø¯ÙŠØ¯ - Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø¯ÙˆÙ„Ø© Ø£ÙˆÙ„Ø§Ù‹
            ctx.session.step = 'awaiting_country';
            ctx.session.awaitingCountry = true;

            // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±Ø© Ø£ÙˆÙ„Ø§Ù‹
            try {
                await ctx.replyWithPhoto(CONFIG.START_IMAGE, {
                    caption: `ðŸŽ‰ *Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ù†Ø¸Ø§Ù… GOAL Predictor Pro v${CONFIG.VERSION}* ðŸš€\n\n` +
                            `ðŸ¤– *Ø£Ù‚ÙˆÙ‰ Ù†Ø¸Ø§Ù… Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„Ø£Ù‡Ø¯Ø§Ù Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ*\n` +
                            `ðŸ’Ž *Ø§Ù„Ù…Ø·ÙˆØ±:* ${CONFIG.DEVELOPER}\n` +
                            `ðŸ“¢ *Ø§Ù„Ù‚Ù†Ø§Ø©:* ${CONFIG.CHANNEL}`
                });
            } catch (photoError) {
                await ctx.replyWithMarkdown(`ðŸŽ‰ *Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ù†Ø¸Ø§Ù… GOAL Predictor Pro v${CONFIG.VERSION}* ðŸš€`);
            }

            const countryMessage = `
ðŸŒ *Ø§Ø®ØªØ± Ø¯ÙˆÙ„ØªÙƒ*

ðŸ”° *Ù„Ø±Ø¨Ø· Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ø¨Ø­Ø³Ø§Ø¨Ùƒ*

ðŸ“‹ *ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ø¯ÙˆÙ„ØªÙƒ Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©:*

ðŸ‡¸ðŸ‡¦ Ø§Ù„Ø³Ø¹ÙˆØ¯ÙŠØ© - ðŸ‡¦ðŸ‡ª Ø§Ù„Ø¥Ù…Ø§Ø±Ø§Øª - ðŸ‡¶ðŸ‡¦ Ù‚Ø·Ø±
ðŸ‡°ðŸ‡¼ Ø§Ù„ÙƒÙˆÙŠØª - ðŸ‡§ðŸ‡­ Ø§Ù„Ø¨Ø­Ø±ÙŠÙ† - ðŸ‡´ðŸ‡² Ø¹Ù…Ø§Ù†
ðŸ‡¾ðŸ‡ª Ø§Ù„ÙŠÙ…Ù† - ðŸ‡®ðŸ‡¶ Ø§Ù„Ø¹Ø±Ø§Ù‚ - ðŸ‡¸ðŸ‡¾ Ø³ÙˆØ±ÙŠØ§
ðŸ‡¯ðŸ‡´ Ø§Ù„Ø£Ø±Ø¯Ù† - ðŸ‡±ðŸ‡§ Ù„Ø¨Ù†Ø§Ù† - ðŸ‡ªðŸ‡¬ Ù…ØµØ±
ðŸ‡©ðŸ‡¿ Ø§Ù„Ø¬Ø²Ø§Ø¦Ø± - ðŸ‡²ðŸ‡¦ Ø§Ù„Ù…ØºØ±Ø¨ - ðŸ‡¹ðŸ‡³ ØªÙˆÙ†Ø³
ðŸ‡±ðŸ‡¾ Ù„ÙŠØ¨ÙŠØ§ - ðŸ‡¸ðŸ‡© Ø§Ù„Ø³ÙˆØ¯Ø§Ù† - ðŸ‡¸ðŸ‡¸ Ø¬Ù†ÙˆØ¨ Ø§Ù„Ø³ÙˆØ¯Ø§Ù†
ðŸ‡µðŸ‡¸ ÙÙ„Ø³Ø·ÙŠÙ† - ðŸ‡²ðŸ‡· Ù…ÙˆØ±ÙŠØªØ§Ù†ÙŠØ§ - ðŸ‡©ðŸ‡¯ Ø¬ÙŠØ¨ÙˆØªÙŠ
ðŸ‡¸ðŸ‡´ Ø§Ù„ØµÙˆÙ…Ø§Ù„ - ðŸ‡°ðŸ‡² Ø¬Ø²Ø± Ø§Ù„Ù‚Ù…Ø±

ðŸ“ *Ø§Ø®ØªØ± Ø¯ÙˆÙ„ØªÙƒ Ù„Ù„Ø§Ø³ØªÙ…Ø±Ø§Ø±:*
            `;

            await ctx.replyWithMarkdown(countryMessage, getCountriesKeyboard());
        }

    } catch (error) {
        console.error('Start command error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù…ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù„Ø§Ø­Ù‚Ø§Ù‹');
    }
});

// ðŸ“ HANDLE TEXT MESSAGES - UPDATED FOR DUAL PAYMENT AND COUNTRY SELECTION
bot.on('text', async (ctx) => {
    try {
        const settings = await dbManager.getSettings();
        if (settings.maintenance_mode && ctx.from.id.toString() !== CONFIG.ADMIN_ID) {
            await ctx.replyWithMarkdown('ðŸ”§ *Ø§Ù„Ø¨ÙˆØª ØªØ­Øª Ø§Ù„ØµÙŠØ§Ù†Ø©*\n\nâ° Ù†Ø¹Ù…Ù„ Ø¹Ù„Ù‰ ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø®Ø¯Ù…Ø© Ù„ÙƒÙ…\nðŸ”„ Ø³Ù†Ø¹ÙˆØ¯ Ù‚Ø±ÙŠØ¨Ø§Ù‹ Ø¨Ø£ÙØ¶Ù„ Ù…Ù…Ø§ ÙƒØ§Ù†\n\nðŸ“ž Ù„Ù„Ø§Ø³ØªÙØ³Ø§Ø±: @GEMZGOOLBOT');
            return;
        }

        const text = ctx.message.text;
        const session = ctx.session;
        const userId = ctx.from.id.toString();

        // ðŸ” ADMIN COMMANDS - Ù„Ù„Ø¥Ø¯Ù…Ù† ÙÙ‚Ø·
        if (userId === CONFIG.ADMIN_ID) {
            if (text === '/admin' || text === 'ðŸ” Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…') {
                ctx.session.adminMode = true;
                ctx.session.adminStep = 'main';
                await ctx.replyWithMarkdown('ðŸ”§ *Ù…Ø±Ø­Ø¨Ø§Ù‹ ÙÙŠ Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…*', getAdminMainKeyboard());
                return;
            }

            if (session.adminMode) {
                await handleAdminCommands(ctx, text);
                return;
            }
        }

        // ðŸ†• Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø¯ÙˆÙ„Ø©
        if (session.step === 'awaiting_country' && session.awaitingCountry) {
            const arabCountries = [
                'ðŸ‡¸ðŸ‡¦ Ø§Ù„Ø³Ø¹ÙˆØ¯ÙŠØ©', 'ðŸ‡¦ðŸ‡ª Ø§Ù„Ø¥Ù…Ø§Ø±Ø§Øª', 'ðŸ‡¶ðŸ‡¦ Ù‚Ø·Ø±', 'ðŸ‡°ðŸ‡¼ Ø§Ù„ÙƒÙˆÙŠØª', 'ðŸ‡§ðŸ‡­ Ø§Ù„Ø¨Ø­Ø±ÙŠÙ†',
                'ðŸ‡´ðŸ‡² Ø¹Ù…Ø§Ù†', 'ðŸ‡¾ðŸ‡ª Ø§Ù„ÙŠÙ…Ù†', 'ðŸ‡®ðŸ‡¶ Ø§Ù„Ø¹Ø±Ø§Ù‚', 'ðŸ‡¸ðŸ‡¾ Ø³ÙˆØ±ÙŠØ§', 'ðŸ‡¯ðŸ‡´ Ø§Ù„Ø£Ø±Ø¯Ù†',
                'ðŸ‡±ðŸ‡§ Ù„Ø¨Ù†Ø§Ù†', 'ðŸ‡ªðŸ‡¬ Ù…ØµØ±', 'ðŸ‡©ðŸ‡¿ Ø§Ù„Ø¬Ø²Ø§Ø¦Ø±', 'ðŸ‡²ðŸ‡¦ Ø§Ù„Ù…ØºØ±Ø¨', 'ðŸ‡¹ðŸ‡³ ØªÙˆÙ†Ø³',
                'ðŸ‡±ðŸ‡¾ Ù„ÙŠØ¨ÙŠØ§', 'ðŸ‡¸ðŸ‡© Ø§Ù„Ø³ÙˆØ¯Ø§Ù†', 'ðŸ‡¸ðŸ‡¸ Ø¬Ù†ÙˆØ¨ Ø§Ù„Ø³ÙˆØ¯Ø§Ù†', 'ðŸ‡µðŸ‡¸ ÙÙ„Ø³Ø·ÙŠÙ†',
                'ðŸ‡²ðŸ‡· Ù…ÙˆØ±ÙŠØªØ§Ù†ÙŠØ§', 'ðŸ‡©ðŸ‡¯ Ø¬ÙŠØ¨ÙˆØªÙŠ', 'ðŸ‡¸ðŸ‡´ Ø§Ù„ØµÙˆÙ…Ø§Ù„', 'ðŸ‡°ðŸ‡² Ø¬Ø²Ø± Ø§Ù„Ù‚Ù…Ø±'
            ];

            if (arabCountries.includes(text)) {
                ctx.session.country = text;
                ctx.session.awaitingCountry = false;
                
                // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø© Ø¨Ø¹Ø¯ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø¯ÙˆÙ„Ø©
                const isSubscribed = await checkChannelSubscription(userId);
                
                if (!isSubscribed) {
                    // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø·Ù„Ø¨ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©
                    await ctx.replyWithMarkdown(
                        `ðŸ” *Ù…Ø±Ø­Ø¨Ø§Ù‹ ${ctx.from.first_name}*\n\n` +
                        `ðŸ“ *Ø§Ù„Ø¯ÙˆÙ„Ø©:* ${text}\n\n` +
                        `ðŸ“¢ *Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØª ÙŠØ¬Ø¨ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ù‚Ù†Ø§ØªÙ†Ø§ Ø£ÙˆÙ„Ø§Ù‹*\n\n` +
                        `ðŸ‘‰ ${CONFIG.CHANNEL_USERNAME}\n\n` +
                        `âœ… Ø¨Ø¹Ø¯ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø± Ø£Ø¯Ù†Ø§Ù‡ Ù„Ù„ØªØ­Ù‚Ù‚:`,
                        Markup.inlineKeyboard([
                            [Markup.button.callback('âœ… ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ', 'check_channel_subscription')]
                        ])
                    );
                    return;
                }

                const welcomeMessage = `
ðŸ” *Ù…Ø±Ø­Ø¨Ø§Ù‹ ${ctx.from.first_name} ÙÙŠ Ù†Ø¸Ø§Ù… GOAL Predictor Pro v${CONFIG.VERSION}*

ðŸ“ *Ø§Ù„Ø¯ÙˆÙ„Ø©:* ${text}

ðŸŽ¯ *Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ØªÙ‚Ø¯Ù… Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„Ø£Ù‡Ø¯Ø§Ù ÙÙŠ Ø§Ù„Ù…Ø¨Ø§Ø±ÙŠØ§Øª*
ðŸ¤– *Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ø°ÙƒÙŠØ© Ù…Ø®ÙÙŠØ© ØªØ­Ù„Ù„ Ø§Ù„Ù…Ø¨Ø§Ø±ÙŠØ§Øª Ø¨Ø¯Ù‚Ø© Ø¹Ø§Ù„ÙŠØ©*

ðŸ“‹ *Ø®Ø·ÙˆØ§Øª Ø§Ù„Ø¯Ø®ÙˆÙ„:*
1ï¸âƒ£ Ø£Ø¯Ø®Ù„ Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet (10 Ø£Ø±Ù‚Ø§Ù…)
2ï¸âƒ£ Ø§Ø³ØªÙ„Ù… ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚ (6 Ø£Ø±Ù‚Ø§Ù…)  
3ï¸âƒ£ Ø£Ø¯Ø®Ù„ ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚
4ï¸âƒ£ Ø§Ø¨Ø¯Ø£ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠØ©

ðŸ’Ž *Ø§Ù„Ù…Ø·ÙˆØ±:* ${CONFIG.DEVELOPER}
ðŸ“¢ *Ø§Ù„Ù‚Ù†Ø§Ø©:* ${CONFIG.CHANNEL}

ðŸ”¢ *Ø§Ù„Ø¢Ù† Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ "ðŸ” Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨" Ù„Ø¨Ø¯Ø¡ Ø§Ù„ØªØ³Ø¬ÙŠÙ„*
                `;

                await ctx.replyWithMarkdown(welcomeMessage, getLoginKeyboard());
                
            } else {
                await ctx.replyWithMarkdown('âŒ *ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ø¯ÙˆÙ„Ø© Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©*', getCountriesKeyboard());
            }
            return;
        }

        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ø¬Ø¯Ø¯
        const existingUser = await dbManager.getUser(userId);
        if (!existingUser && session.step !== 'awaiting_verification' && session.step !== 'awaiting_account_id') {
            const isSubscribed = await checkChannelSubscription(userId);
            if (!isSubscribed) {
                await ctx.replyWithMarkdown(
                    `âŒ *ÙŠØ¬Ø¨ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø© Ø£ÙˆÙ„Ø§Ù‹*\n\n` +
                    `ðŸ“¢ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©:\n` +
                    `ðŸ‘‰ ${CONFIG.CHANNEL_USERNAME}\n\n` +
                    `âœ… Ø«Ù… Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ /start Ù„Ù„Ø¨Ø¯Ø¡`,
                    Markup.inlineKeyboard([
                        [Markup.button.callback('âœ… ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ', 'check_channel_subscription')]
                    ])
                );
                return;
            }
        }

        // ðŸ†• Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¥Ø¯Ø®Ø§Ù„ Ù…Ø¨Ù„Øº Ø§Ù„Ø±Ù‡Ø§Ù† - Ø§Ù„Ø¥ØµÙ„Ø§Ø­ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ Ù‡Ù†Ø§
        if (session.awaitingBetAmount) {
            const betAmount = parseFloat(text);
            if (isNaN(betAmount) || betAmount <= 0) {
                await ctx.replyWithMarkdown('âŒ *Ù…Ø¨Ù„Øº ØºÙŠØ± ØµØ­ÙŠØ­!*\n\nÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ù…Ø¨Ù„Øº ØµØ­ÙŠØ­ (Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø·)');
                return;
            }

            // Ø­ÙØ¸ Ù…Ø¨Ù„Øº Ø§Ù„Ø±Ù‡Ø§Ù† ÙÙŠ Ø§Ù„Ø¬Ù„Ø³Ø©
            ctx.session.currentBet = betAmount;
            ctx.session.originalBet = betAmount;
            ctx.session.awaitingBetAmount = false;

            // Ø§Ù„Ø¢Ù† Ù†Ù†ØªÙ‚Ù„ Ø¥Ù„Ù‰ Ø¬Ù„Ø¨ Ø§Ù„ØªØ­Ù„ÙŠÙ„
            const userData = await dbManager.getUser(userId);
            if (!userData) {
                await ctx.replyWithMarkdown('âŒ *Ø¬Ù„Ø³Ø© Ù…Ù†ØªÙ‡ÙŠØ©*\n\nðŸ” Ø£Ø±Ø³Ù„ /start Ù„Ù„Ø¨Ø¯Ø¡', getLoginKeyboard());
                return;
            }

            await handleGetPrediction(ctx, userData);
            return;
        }

        // ðŸ†• Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ø®ØªÙŠØ§Ø± Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹
        if (session.step === 'choose_payment_method') {
            if (text === 'ðŸ’³ Ø¨Ø§ÙŠÙ†Ø§Ù†Ø³') {
                ctx.session.paymentSystem = 'binance';
                ctx.session.step = 'verified';
                await handleSubscriptions(ctx, session.userData);
                return;
            }
            else if (text === 'ðŸ¦ ØªØ­ÙˆÙŠÙ„ Ø¨Ù†ÙƒÙŠ') {
                ctx.session.paymentSystem = 'bank';
                ctx.session.step = 'verified';
                await handleSubscriptions(ctx, session.userData);
                return;
            }
            else if (text === 'ðŸ”™ Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø©') {
                ctx.session.step = 'verified';
                await ctx.replyWithMarkdown('ðŸ”™ *Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©*', getMainKeyboard());
                return;
            }
        }

        // ðŸ” Ø²Ø± Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨ - Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø£ÙˆÙ„Ø§Ù‹
        if (text === 'ðŸ” Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨') {
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø© Ø£ÙˆÙ„Ø§Ù‹
            const isSubscribed = await checkChannelSubscription(userId);
            if (!isSubscribed) {
                await ctx.replyWithMarkdown(
                    `âŒ *ÙŠØ¬Ø¨ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø© Ø£ÙˆÙ„Ø§Ù‹*\n\n` +
                    `ðŸ“¢ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©:\n` +
                    `ðŸ‘‰ ${CONFIG.CHANNEL_USERNAME}\n\n` +
                    `âœ… Ø«Ù… Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø± Ø£Ø¯Ù†Ø§Ù‡ Ù„Ù„ØªØ­Ù‚Ù‚:`,
                    Markup.inlineKeyboard([
                        [Markup.button.callback('âœ… ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ', 'check_channel_subscription')]
                    ])
                );
                return;
            }

            ctx.session.step = 'awaiting_account_id';
            await ctx.replyWithMarkdown(
                'ðŸ”¢ *Ø§Ù„Ø®Ø·ÙˆØ© 1:* Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ (10 Ø£Ø±Ù‚Ø§Ù…)\n\n' +
                'ðŸ’¡ *Ù…Ù„Ø§Ø­Ø¸Ø©:* ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø§Ù„Ø±Ù‚Ù… Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ'
            );
            return;
        }

        // ðŸ” STEP 1: Validate 1xBet Account - Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„Ù…Ø­Ø³Ù† Ù…Ø¹ Ù…Ù†Ø¹ Ø§Ù„ØªÙƒØ±Ø§Ø±
        if (session.step === 'awaiting_account_id') {
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø© Ø£ÙˆÙ„Ø§Ù‹
            const isSubscribed = await checkChannelSubscription(userId);
            if (!isSubscribed) {
                await ctx.replyWithMarkdown(
                    `âŒ *ÙŠØ¬Ø¨ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø© Ø£ÙˆÙ„Ø§Ù‹*\n\n` +
                    `ðŸ“¢ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©:\n` +
                    `ðŸ‘‰ ${CONFIG.CHANNEL_USERNAME}\n\n` +
                    `âœ… Ø«Ù… Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø± Ø£Ø¯Ù†Ø§Ù‡ Ù„Ù„ØªØ­Ù‚Ù‚:`,
                    Markup.inlineKeyboard([
                        [Markup.button.callback('âœ… ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ', 'check_channel_subscription')]
                    ])
                );
                return;
            }

            if (/^\d{10}$/.test(text)) {
                // ðŸ”’ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨ ØºÙŠØ± Ù…Ø³Ø¬Ù„ Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¢Ø®Ø± - ØªØ­Ø³ÙŠÙ† Ø§Ù„Ù†Ø¸Ø§Ù…
                const existingUserWithAccount = await dbManager.getUserByOneXBet(text);
                if (existingUserWithAccount) {
                    if (existingUserWithAccount.user_id === userId) {
                        // Ù†ÙØ³ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙŠØ­Ø§ÙˆÙ„ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø¨Ù†ÙØ³ Ø§Ù„Ø­Ø³Ø§Ø¨
                        await ctx.replyWithMarkdown(
                            'âš ï¸ *Ù‡Ø°Ø§ Ø§Ù„Ø­Ø³Ø§Ø¨ Ù…Ø³Ø¬Ù„ Ù„Ùƒ Ø¨Ø§Ù„ÙØ¹Ù„!*\n\n' +
                            'ðŸ” ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØª Ù…Ø¨Ø§Ø´Ø±Ø©\n' +
                            'ðŸ’¡ Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ /start Ù„Ù„Ø¯Ø®ÙˆÙ„ Ø¨Ø­Ø³Ø§Ø¨Ùƒ'
                        );
                        return;
                    } else {
                        // Ø­Ø³Ø§Ø¨ Ù…Ø³Ø¬Ù„ Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¢Ø®Ø±
                        await ctx.replyWithMarkdown(
                            'âŒ *Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨ Ù…Ø³Ø¬Ù„ Ø¨Ø§Ù„ÙØ¹Ù„!*\n\n' +
                            'ðŸ” Ù‡Ø°Ø§ Ø§Ù„Ø­Ø³Ø§Ø¨ Ù…Ø³Ø¬Ù„ Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¢Ø®Ø±\n' +
                            'ðŸ’¡ ÙŠØ±Ø¬Ù‰ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø­Ø³Ø§Ø¨Ùƒ Ø§Ù„Ø®Ø§Øµ Ø£Ùˆ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù…\n\n' +
                            'ðŸ“ž Ù„Ù„Ø§Ø³ØªÙØ³Ø§Ø±: @GEMZGOOLBOT'
                        );
                        return;
                    }
                }

                ctx.session.accountId = text;
                ctx.session.step = 'awaiting_verification';
                ctx.session.verificationCode = Math.floor(100000 + Math.random() * 900000);

                await ctx.replyWithMarkdown(
                    `âœ… *ØªÙ… Ø¥Ø±Ø³Ø§Ù„ ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚*\n\n` +
                    `ðŸ” *Ø§Ù„Ø­Ø³Ø§Ø¨:* \`${text}\`\n` +
                    `ðŸ“§ *Ø§Ù„ÙƒÙˆØ¯:* \`${ctx.session.verificationCode}\`\n\n` +
                    `ðŸ”¢ *Ø§Ù„Ø®Ø·ÙˆØ© 2:* Ø£Ø±Ø³Ù„ ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚ Ø®Ù„Ø§Ù„ 5 Ø¯Ù‚Ø§Ø¦Ù‚`
                );

                setTimeout(() => {
                    if (ctx.session.step === 'awaiting_verification') {
                        ctx.session.verificationCode = null;
                        ctx.session.step = 'start';
                    }
                }, 5 * 60 * 1000);
            } else {
                await ctx.replyWithMarkdown(
                    'âŒ *Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨ Ø®Ø·Ø£!*\n\n' +
                    'ðŸ”¢ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet Ù…ÙƒÙˆÙ† Ù…Ù† 10 Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø·\n' +
                    'ðŸ“ Ù…Ø«Ø§Ù„: 1234567890\n\n' +
                    'ðŸ’¡ ÙŠØ±Ø¬Ù‰ Ø¥Ø¹Ø§Ø¯Ø© Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø±Ù‚Ù… Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­'
                );
                return;
            }
        }
        // ðŸ” STEP 2: Verify Code
        else if (session.step === 'awaiting_verification' && /^\d{6}$/.test(text)) {
            if (parseInt(text) === ctx.session.verificationCode) {
                
                // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„Ù…ØªØ­Ø±ÙƒØ©
                const waitingMessage = await ctx.replyWithMarkdown(
                    'ðŸ” *Ø¬Ø§Ø±ÙŠ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„...*\n\n' +
                    'â³ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ø³Ø¬Ù„Ø§Øª...\n' +
                    'ðŸ“¡ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø³ÙŠØ±ÙØ±...\n' +
                    'âš¡ Ø¬Ø§Ø±ÙŠ ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø­Ø³Ø§Ø¨...\n' +
                    'ðŸŽ¯ Ø¬Ø§Ø±ÙŠ Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠØ©...\n\n' +
                    'â° Ù‚Ø¯ ØªØ³ØªØºØ±Ù‚ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© 10 Ø«ÙˆØ§Ù†ÙŠ...'
                );

                // Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ù„Ù…Ø¯Ø© 10 Ø«ÙˆØ§Ù†ÙŠ Ù…Ø¹ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø±Ø³Ø§Ù„Ø©
                for (let i = 1; i <= 10; i++) {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    try {
                        await ctx.telegram.editMessageText(
                            ctx.chat.id,
                            waitingMessage.message_id,
                            null,
                            `ðŸ” *Ø¬Ø§Ø±ÙŠ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„...*\n\n` +
                            `â³ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ø³Ø¬Ù„Ø§Øª... ${i}/10\n` +
                            `ðŸ“¡ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø³ÙŠØ±ÙØ±...\n` +
                            `âš¡ Ø¬Ø§Ø±ÙŠ ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø­Ø³Ø§Ø¨...\n` +
                            `ðŸŽ¯ Ø¬Ø§Ø±ÙŠ Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠØ©...`,
                            { parse_mode: 'Markdown' }
                        );
                    } catch (editError) {
                        console.log('Error editing waiting message:', editError);
                    }
                }

                const userData = {
                    user_id: userId,
                    username: ctx.from.first_name,
                    onexbet: ctx.session.accountId,
                    country: ctx.session.country || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯',
                    free_attempts: 10,
                    subscription_status: 'free',
                    subscription_type: 'none',
                    subscription_start_date: null,
                    subscription_end_date: null,
                    joined_at: new Date().toISOString(),
                    total_predictions: 0,
                    correct_predictions: 0,
                    wins: 0,
                    losses: 0,
                    total_bets: 0,
                    total_profit: 0,
                    algorithm_linked: true,
                    last_algorithm_check: new Date().toISOString()
                };

                await dbManager.saveUser(userId, userData);
                ctx.session.step = 'verified';
                ctx.session.userData = userData;

                // Ø­Ø°Ù Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±
                await ctx.deleteMessage(waitingMessage.message_id);

                await ctx.replyWithMarkdown(
                    `ðŸŽ‰ *ØªÙ… Ø§Ù„Ø±Ø¨Ø· Ø¨Ù†Ø¬Ø§Ø­!*\n\n` +
                    `ðŸ“ *Ø§Ù„Ø¯ÙˆÙ„Ø©:* ${userData.country}\n` +
                    `âœ… *Ø§Ù„Ø­Ø³Ø§Ø¨:* \`${ctx.session.accountId}\`\n` +
                    `ðŸ‘¤ *Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:* ${ctx.session.userData.username}\n` +
                    `ðŸ”„ *ØªÙ… Ø±Ø¨Ø· Ø§Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ø¨Ù†Ø¬Ø§Ø­*\n\n` +
                    `ðŸŽ *ØªØ­ØµÙ„ Ø¹Ù„Ù‰ 10 Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ù…Ø¬Ø§Ù†ÙŠØ©*\n\n` +
                    `ðŸŽ¯ *ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¢Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø²Ø± "Ø¬Ù„Ø¨ Ø§Ù„ØªØ­Ù„ÙŠÙ„" Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„ØªÙˆÙ‚Ø¹Ø§Øª*`,
                    getMainKeyboard()
                );

            } else {
                await ctx.replyWithMarkdown('âŒ *ÙƒÙˆØ¯ ØªØ­Ù‚Ù‚ Ø®Ø§Ø·Ø¦!*\n\nðŸ” ÙŠØ±Ø¬Ù‰ Ø¥Ø¹Ø§Ø¯Ø© Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„ØµØ­ÙŠØ­');
            }
        }
        // ðŸ’³ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ø¯ÙØ¹ - Ø·Ù„Ø¨ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨
        else if (session.awaitingPaymentAccount) {
            if (/^\d{10}$/.test(text)) {
                const userData = await dbManager.getUser(userId);
                
                // ðŸ”’ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØªØ·Ø§Ø¨Ù‚ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨ Ù…Ø¹ Ø§Ù„Ù…Ø³Ø¬Ù„
                if (text !== userData.onexbet) {
                    await ctx.replyWithMarkdown(
                        'âŒ *Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨ Ù„Ø§ ÙŠØªØ·Ø§Ø¨Ù‚!*\n\n' +
                        `ðŸ” Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨Ùƒ Ø§Ù„Ù…Ø³Ø¬Ù„: \`${userData.onexbet}\`\n` +
                        'ðŸ’¡ ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨Ùƒ Ø§Ù„ØµØ­ÙŠØ­ Ø§Ù„Ù…Ø³Ø¬Ù„ ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù…'
                    );
                    return;
                }
                
                ctx.session.awaitingPaymentAccount = false;
                ctx.session.paymentAccount = text;
                
                const paymentSystem = ctx.session.paymentSystem || 'binance';
                
                if (paymentSystem === 'binance') {
                    await ctx.replyWithMarkdown(
                        `âœ… *ØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨:* \`${text}\`\n\n` +
                        `ðŸ“¸ *Ø§Ù„Ø¢Ù† ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ ØµÙˆØ±Ø© Ø¥Ø«Ø¨Ø§Øª Ø§Ù„Ø¯ÙØ¹ Ù…Ù† Ø¨Ø§ÙŠÙ†Ø§Ù†Ø³*`
                    );
                } else if (paymentSystem === 'bank') {
                    await ctx.replyWithMarkdown(
                        `âœ… *ØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨:* \`${text}\`\n\n` +
                        `ðŸ“¸ *Ø§Ù„Ø¢Ù† ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ ØµÙˆØ±Ø© Ø¥Ø«Ø¨Ø§Øª Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¨Ù†ÙƒÙŠ*`
                    );
                }
            } else {
                await ctx.replyWithMarkdown('âŒ *Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ ØºÙŠØ± ØµØ­ÙŠØ­!*\n\nðŸ”¢ ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet Ù…ÙƒÙˆÙ† Ù…Ù† 10 Ø£Ø±Ù‚Ø§Ù…');
            }
            return;
        }
        // ðŸŽ¯ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø«Ø§Ø¨ØªØ© Ø¨Ø¹Ø¯ Ø§Ù„ØªØ­Ù‚Ù‚
        else if (session.step === 'verified') {
            const userData = await dbManager.getUser(userId);
            
            if (!userData) {
                await ctx.replyWithMarkdown('âŒ *Ø¬Ù„Ø³Ø© Ù…Ù†ØªÙ‡ÙŠØ©*\n\nðŸ” Ø£Ø±Ø³Ù„ /start Ù„Ù„Ø¨Ø¯Ø¡', getLoginKeyboard());
                return;
            }

            switch (text) {
                case 'ðŸŽ¯ Ø¬Ù„Ø¨ Ø§Ù„ØªØ­Ù„ÙŠÙ„':
                    await handleGetPrediction(ctx, userData);
                    break;

                case 'ðŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§ØªÙŠ':
                    await handleUserStats(ctx, userData);
                    break;

                case 'ðŸ‘¥ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØª':
                    await handleBotStats(ctx);
                    break;

                case 'ðŸ’³ Ø§Ù„Ø§Ø´ØªØ±Ø§ÙƒØ§Øª':
                    // ðŸ†• Ø§Ø®ØªÙŠØ§Ø± Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹ Ø£ÙˆÙ„Ø§Ù‹
                    ctx.session.step = 'choose_payment_method';
                    await ctx.replyWithMarkdown(
                        'ðŸ’³ *Ø§Ø®ØªØ± Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹*\n\n' +
                        'ðŸ”¹ Ø§Ø®ØªØ± Ø§Ù„Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ù…Ù†Ø§Ø³Ø¨Ø© Ù„Ù„Ø¯ÙØ¹:\n\n' +
                        'ðŸ’³ *Ø¨Ø§ÙŠÙ†Ø§Ù†Ø³* - Ø§Ù„Ø¯ÙØ¹ Ø¹Ø¨Ø± Ù…Ù†ØµØ© Ø¨Ø§ÙŠÙ†Ø§Ù†Ø³\n' +
                        'ðŸ¦ *ØªØ­ÙˆÙŠÙ„ Ø¨Ù†ÙƒÙŠ* - Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø¹Ø¨Ø± Ø§Ù„Ø¨Ù†Ùƒ Ø§Ù„ÙƒØ±ÙŠÙ…ÙŠ\n\n' +
                        'ðŸ“‹ Ø§Ø®ØªØ± Ø§Ù„Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„ØªÙŠ ØªÙ†Ø§Ø³Ø¨Ùƒ:',
                        getPaymentMethodKeyboard()
                    );
                    break;

                case 'ðŸ‘¤ Ø­Ø§Ù„Ø© Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ':
                    await handleSubscriptionStatus(ctx, userData);
                    break;

                case 'ðŸ†˜ Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ':
                    await ctx.replyWithMarkdown(
                        `ðŸ†˜ *Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ*\n\n` +
                        `ðŸ“ž Ù„Ù„Ø§Ø³ØªÙØ³Ø§Ø±Ø§Øª ÙˆØ§Ù„Ø¯Ø¹Ù…:\n` +
                        `ðŸ‘¤ @GEMZGOOLBOT\n` +
                        `ðŸ“¢ ${CONFIG.CHANNEL}\n\n` +
                        `â° Ù…ØªØ§Ø­ÙˆÙ† 24/7 Ù„Ø®Ø¯Ù…ØªÙƒÙ…`,
                        getMainKeyboard()
                    );
                    break;

                case 'ðŸ”™ Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø©':
                    await ctx.replyWithMarkdown('ðŸ”™ *Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©*', getMainKeyboard());
                    break;

                default:
                    if (text.startsWith('ðŸ’° ')) {
                        await handleSubscriptionSelection(ctx, userData, text);
                    } else {
                        await ctx.replyWithMarkdown('ðŸ”™ *Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©*', getMainKeyboard());
                    }
                    break;
            }
        }
        // ðŸ” Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…Ø³Ø¬Ù„ ÙˆØ­Ø§ÙˆÙ„ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø£Ø²Ø±Ø§Ø±
        else if (['ðŸŽ¯ Ø¬Ù„Ø¨ Ø§Ù„ØªØ­Ù„ÙŠÙ„', 'ðŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§ØªÙŠ', 'ðŸ’³ Ø§Ù„Ø§Ø´ØªØ±Ø§ÙƒØ§Øª', 'ðŸ‘¥ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØª'].includes(text)) {
            await ctx.replyWithMarkdown(
                'âŒ *ÙŠØ¬Ø¨ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø£ÙˆÙ„Ø§Ù‹*\n\n' +
                'ðŸ” Ø£Ø±Ø³Ù„ /start Ù„ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„',
                getLoginKeyboard()
            );
        } else {
            await ctx.replyWithMarkdown('ðŸ”™ *Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©*', getMainKeyboard());
        }

    } catch (error) {
        console.error('Text handler error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹', getMainKeyboard());
    }
});

// ðŸ–¼ï¸ Ù…Ø¹Ø§Ù„Ø¬Ø© ØµÙˆØ± Ø§Ù„Ø¯ÙØ¹ - UPDATED FOR DUAL PAYMENT
bot.on('photo', async (ctx) => {
    try {
        const userId = ctx.from.id.toString();
        const session = ctx.session;
        
        // ðŸ’³ Ù…Ø¹Ø§Ù„Ø¬Ø© ØµÙˆØ± Ø§Ù„Ø¯ÙØ¹ Ù…Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† ÙÙ‚Ø·
        if (session.paymentType) {
            await handlePaymentScreenshot(ctx, userId);
            return;
        }

        // ðŸ–¼ï¸ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø±ÙØ¹ ØµÙˆØ±Ø© Ù„Ù„Ø¯ÙØ¹ ÙÙŠ Ø§Ù„Ø¥Ø¯Ù…Ù†
        if (session.adminStep === 'edit_bank_image') {
            await handleAdminBankImageUpload(ctx, userId);
            return;
        }

        // ðŸ–¼ï¸ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø±ÙØ¹ ØµÙˆØ±Ø© Ù„Ù„Ø¯ÙØ¹ ÙÙŠ Ø§Ù„Ø¥Ø¯Ù…Ù† (Ø¨Ø§ÙŠÙ†Ø§Ù†Ø³)
        if (session.adminStep === 'edit_price_and_payment' && session.editingSubscriptionType && session.adminPaymentSystem === 'binance') {
            await handleAdminPaymentImageUpload(ctx, userId);
            return;
        }

        // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù‡Ù†Ø§Ùƒ Ø³ÙŠØ§Ù‚ Ù„Ù„ØµÙˆØ±Ø©ØŒ Ù†Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø© ØªÙˆØ¶ÙŠØ­ÙŠØ©
        await ctx.replyWithMarkdown(
            'âŒ *Ù„Ø§ ÙŠÙ…ÙƒÙ† Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø© Ø­Ø§Ù„ÙŠØ§Ù‹*\n\n' +
            'ðŸ’¡ ÙŠØ±Ø¬Ù‰ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù…ØªØ§Ø­Ø© ÙÙŠ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©',
            getMainKeyboard()
        );

    } catch (error) {
        console.error('Photo handler error:', error);
        await ctx.replyWithMarkdown('âŒ *Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø©*', getMainKeyboard());
    }
});

// ðŸŽ¯ HANDLE CALLBACK QUERIES - UPDATED WITH ALGORITHM RECONNECTION
bot.on('callback_query', async (ctx) => {
    try {
        const callbackData = ctx.callbackQuery.data;
        const userId = ctx.from.id.toString();
        
        if (callbackData.startsWith('win_') || callbackData.startsWith('lose_')) {
            const isWin = callbackData.startsWith('win_');
            
            const userData = await dbManager.getUser(userId);
            if (!userData) {
                await ctx.answerCbQuery('âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…');
                return;
            }
            
            if (isWin) {
                const profit = ctx.session.currentBet;
                userData.wins = (userData.wins || 0) + 1;
                userData.correct_predictions = (userData.correct_predictions || 0) + 1;
                userData.total_profit = (userData.total_profit || 0) + profit;
                ctx.session.totalProfit += profit;
                
                await ctx.answerCbQuery(`ðŸŽŠ Ù…Ø¨Ø±ÙˆÙƒ! Ù†Ø¬Ø­ Ø§Ù„ØªÙˆÙ‚Ø¹ ÙˆØ±Ø¨Ø­Øª ${profit}$`);
                
                await ctx.replyWithMarkdown(
                    `ðŸŽŠ *Ù…Ø¨Ø±ÙˆÙƒ! Ù†Ø¬Ø­ Ø§Ù„ØªÙˆÙ‚Ø¹ Ø¨Ù†Ø¬Ø§Ø­* âœ¨\n\n` +
                    `âœ… ØªÙˆÙ‚Ø¹Ùƒ ÙƒØ§Ù† Ø¯Ù‚ÙŠÙ‚Ø§Ù‹ ÙˆÙ…Ù…ÙŠØ²Ø§Ù‹\n` +
                    `ðŸ’° Ø±Ø¨Ø­Øª: ${profit}$\n` +
                    `ðŸ’µ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø£Ø±Ø¨Ø§Ø­Ùƒ: ${ctx.session.totalProfit}$\n\n` +
                    `ðŸŽ¯ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¨Ø¯Ø¡ Ø¨ØªÙˆÙ‚Ø¹ Ø¬Ø¯ÙŠØ¯`,
                    getMainKeyboard()
                );
                
            } else {
                // Ù…Ø¶Ø§Ø¹ÙØ© Ø§Ù„Ø±Ù‡Ø§Ù† ÙˆØªÙˆÙ„ÙŠØ¯ ØªÙˆÙ‚Ø¹ Ø¬Ø¯ÙŠØ¯ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
                const newBet = ctx.session.currentBet * 2;
                userData.losses = (userData.losses || 0) + 1;
                ctx.session.currentBet = newBet;
                
                await ctx.answerCbQuery(`ðŸ”„ Ø¬Ø§Ø±ÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„ØªØ§Ù„ÙŠ...`);
                
                // ØªÙˆÙ„ÙŠØ¯ ØªÙˆÙ‚Ø¹ Ø¬Ø¯ÙŠØ¯ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
                const newPrediction = goalAI.generateNextPrediction(userId);
                
                await ctx.replyWithMarkdown(
                    `ðŸ”„ *Ø®Ø³Ø±Øª Ù‡Ø°Ù‡ Ø§Ù„Ø¬ÙˆÙ„Ø©*\n\n` +
                    `ðŸ“ˆ Ø§Ù„Ø±Ù‡Ø§Ù† Ø§Ù„ØªØ§Ù„ÙŠ Ù…Ø¶Ø§Ø¹Ù: ${newBet}$\n` +
                    `ðŸ’ª Ù„Ø§ ØªÙˆÙ‚Ù.. Ø§Ø³ØªÙ…Ø± ÙÙŠ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©\n\n` +
                    `ðŸŽ¯ *Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„ØªØ§Ù„ÙŠ:*\n` +
                    `${newPrediction.type}\n` +
                    `ðŸ“ˆ ${newPrediction.probability}% | ðŸŽ¯ ${newPrediction.confidence}%\n` +
                    `ðŸ’¡ ${newPrediction.reasoning}`,
                    getMainKeyboard()
                );
            }
            
            await dbManager.saveUser(userId, userData);
            
            try {
                await ctx.deleteMessage(ctx.callbackQuery.message.message_id);
            } catch (deleteError) {
                console.log('Could not delete message:', deleteError);
            }
        }
        
        // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù‚Ø¨ÙˆÙ„ ÙˆØ§Ù„Ø±ÙØ¶ ÙÙŠ Ø§Ù„Ø¥Ø¯Ù…Ù†
        else if (callbackData.startsWith('accept_')) {
            const paymentId = callbackData.split('_')[1];
            await handlePaymentAccept(ctx, paymentId);
        }
        else if (callbackData.startsWith('reject_')) {
            const paymentId = callbackData.split('_')[1];
            await handlePaymentReject(ctx, paymentId);
        }
        
        // ðŸ†• Ù…Ø¹Ø§Ù„Ø¬Ø© ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ù„Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ø²Ø¯ÙˆØ¬
        else if (callbackData.startsWith('confirm_binance_') || callbackData.startsWith('confirm_bank_')) {
            await handleSubscriptionConfirmation(ctx, callbackData);
        }
        
        // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø²Ø± Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ø§Ø´ØªØ±Ø§ÙƒØ§Øª
        else if (callbackData === 'back_to_subscriptions') {
            await ctx.deleteMessage(ctx.callbackQuery.message.message_id);
            await ctx.replyWithMarkdown('ðŸ’³ *Ø¨Ø§Ù‚Ø§Øª Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ù…ØªØ§Ø­Ø©*', getSubscriptionKeyboard());
        }
        
        // ðŸ†• Ù…Ø¹Ø§Ù„Ø¬Ø© Ø²Ø± Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©
        else if (callbackData === 'check_channel_subscription') {
            await handleCheckChannelSubscription(ctx);
        }
        
        // ðŸ†• Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¥Ø¹Ø§Ø¯Ø© Ø±Ø¨Ø· Ø§Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ©
        else if (callbackData === 'reconnect_algorithm') {
            const userData = await dbManager.getUser(userId);
            if (userData) {
                await reconnectAlgorithm(ctx, userData);
            } else {
                await ctx.answerCbQuery('âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…');
            }
        }
        
    } catch (error) {
        console.error('Callback query error:', error);
        await ctx.answerCbQuery('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©');
    }
});

// ðŸ†• Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©
async function handleCheckChannelSubscription(ctx) {
    try {
        const userId = ctx.from.id.toString();
        const isSubscribed = await checkChannelSubscription(userId);
        
        if (isSubscribed) {
            await ctx.answerCbQuery('âœ… ØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø¨Ù†Ø¬Ø§Ø­!');
            await ctx.deleteMessage();
            
            // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªØ±Ø­ÙŠØ¨ Ø¨Ø¹Ø¯ Ø§Ù„ØªØ­Ù‚Ù‚
            const userName = ctx.from.first_name;
            
            const welcomeMessage = `
ðŸ” *Ù…Ø±Ø­Ø¨Ø§Ù‹ ${userName} ÙÙŠ Ù†Ø¸Ø§Ù… GOAL Predictor Pro v${CONFIG.VERSION}*

ðŸŽ¯ *Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ØªÙ‚Ø¯Ù… Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„Ø£Ù‡Ø¯Ø§Ù ÙÙŠ Ø§Ù„Ù…Ø¨Ø§Ø±ÙŠØ§Øª*
ðŸ¤– *Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ø°ÙƒÙŠØ© Ù…Ø®ÙÙŠØ© ØªØ­Ù„Ù„ Ø§Ù„Ù…Ø¨Ø§Ø±ÙŠØ§Øª Ø¨Ø¯Ù‚Ø© Ø¹Ø§Ù„ÙŠØ©*

ðŸ“‹ *Ø®Ø·ÙˆØ§Øª Ø§Ù„Ø¯Ø®ÙˆÙ„:*
1ï¸âƒ£ Ø£Ø¯Ø®Ù„ Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet (10 Ø£Ø±Ù‚Ø§Ù…)
2ï¸âƒ£ Ø§Ø³ØªÙ„Ù… ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚ (6 Ø£Ø±Ù‚Ø§Ù…)  
3ï¸âƒ£ Ø£Ø¯Ø®Ù„ ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚
4ï¸âƒ£ Ø§Ø¨Ø¯Ø£ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠØ©

ðŸ’Ž *Ø§Ù„Ù…Ø·ÙˆØ±:* ${CONFIG.DEVELOPER}
ðŸ“¢ *Ø§Ù„Ù‚Ù†Ø§Ø©:* ${CONFIG.CHANNEL}

ðŸ”¢ *Ø§Ù„Ø¢Ù† Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ "ðŸ” Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨" Ù„Ø¨Ø¯Ø¡ Ø§Ù„ØªØ³Ø¬ÙŠÙ„*
            `;

            await ctx.replyWithMarkdown(welcomeMessage, getLoginKeyboard());
        } else {
            await ctx.answerCbQuery('âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø¨Ø¹Ø¯!');
            await ctx.replyWithMarkdown(
                `âŒ *Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ø´ØªØ±Ø§ÙƒÙƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©*\n\n` +
                `ðŸ“¢ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø© Ø£ÙˆÙ„Ø§Ù‹:\n` +
                `ðŸ‘‰ ${CONFIG.CHANNEL_USERNAME}\n\n` +
                `âœ… Ø«Ù… Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø± Ø£Ø¯Ù†Ø§Ù‡ Ù„Ù„ØªØ­Ù‚Ù‚:`,
                Markup.inlineKeyboard([
                    [Markup.button.callback('âœ… ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ', 'check_channel_subscription')]
                ])
            );
        }
    } catch (error) {
        console.error('Channel subscription check error:', error);
        await ctx.answerCbQuery('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚');
    }
}

// ðŸŽ¯ HANDLER FUNCTIONS

async function handleGetPrediction(ctx, userData) {
    try {
        // ðŸ” Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ø£ÙˆÙ„Ø§Ù‹
        if (isAlgorithmExpired(userData.last_algorithm_check)) {
            await ctx.replyWithMarkdown(
                'âš ï¸ *Ø§Ù†ØªÙ‡Øª Ø¬Ù„Ø³Ø© Ø§Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ©*\n\n' +
                'ðŸ”„ ØªØ­ØªØ§Ø¬ Ø¥Ù„Ù‰ Ø¥Ø¹Ø§Ø¯Ø© Ø±Ø¨Ø· Ø§Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ø§Ù„ØªØ­Ù„ÙŠÙ„Ø§Øª\n' +
                `ðŸ“ *Ø§Ù„Ø¯ÙˆÙ„Ø©:* ${userData.country || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'}\n` +
                `ðŸ” *Ø§Ù„Ø­Ø³Ø§Ø¨:* \`${userData.onexbet}\`\n\n` +
                'ðŸ’¡ Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø± Ø£Ø¯Ù†Ø§Ù‡ Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø±Ø¨Ø·:',
                Markup.inlineKeyboard([
                    [Markup.button.callback('ðŸ”„ Ø¥Ø¹Ø§Ø¯Ø© Ø±Ø¨Ø· Ø§Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ©', 'reconnect_algorithm')]
                ])
            );
            return;
        }

        // ðŸ” Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠØ© Ø£Ùˆ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ
        if (userData.subscription_status !== 'active' && userData.free_attempts <= 0) {
            await ctx.replyWithMarkdown(
                'ðŸš« *Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠØ©*\n\n' +
                'ðŸ’³ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ù„Ù„Ù…ØªØ§Ø¨Ø¹Ø© ÙÙŠ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø®Ø¯Ù…Ø©',
                getMainKeyboard()
            );
            return;
        }

        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ù…Ø¨Ù„Øº Ø§Ù„Ø±Ù‡Ø§Ù†
        if (!ctx.session.currentBet || ctx.session.currentBet <= 0) {
            ctx.session.awaitingBetAmount = true;
            await ctx.replyWithMarkdown(
                'ðŸ’° *Ø£Ø¯Ø®Ù„ Ù…Ø¨Ù„Øº Ø§Ù„Ø±Ù‡Ø§Ù†:*\n\n' +
                'ðŸ’µ ÙŠØ±Ø¬Ù‰ ÙƒØªØ§Ø¨Ø© Ø§Ù„Ù…Ø¨Ù„Øº Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ø§Ù„Ø±Ù‡Ø§Ù† Ø¹Ù„ÙŠÙ‡ (Ø¨Ø§Ù„Ø¯ÙˆÙ„Ø§Ø±)\n' +
                'ðŸ“ Ù…Ø«Ø§Ù„: 10 Ø£Ùˆ 25.5'
            );
            return;
        }

        // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„Ù…ØªØ­Ø±ÙƒØ© Ù…Ø¹ ÙƒØ±Ø© Ù…ØªØ­Ø±ÙƒØ©
        const loadingMessages = [
            'ðŸŽ¯ *Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ Ø§Ù„ØªØ­Ù„ÙŠÙ„...*\n\nâš½ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† ÙØ±Øµ Ø§Ù„Ù‡Ø¯Ù...',
            'ðŸŽ¯ *Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ Ø§Ù„ØªØ­Ù„ÙŠÙ„...*\n\nðŸ”„ Ø¬Ø§Ø±ÙŠ ØªØ­Ù„ÙŠÙ„ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„ÙØ±ÙŠÙ‚ÙŠÙ†...',
            'ðŸŽ¯ *Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ Ø§Ù„ØªØ­Ù„ÙŠÙ„...*\n\nðŸ“Š Ø¬Ø§Ø±ÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª...',
            'ðŸŽ¯ *Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ Ø§Ù„ØªØ­Ù„ÙŠÙ„...*\n\nðŸ¤– Ø¬Ø§Ø±ÙŠ ØªØ·Ø¨ÙŠÙ‚ Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ...'
        ];

        let loadingMsg = await ctx.replyWithMarkdown(loadingMessages[0]);
        
        // Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„Ù…ØªØ­Ø±Ùƒ Ù„Ù…Ø¯Ø© 4 Ø«ÙˆØ§Ù†ÙŠ
        for (let i = 1; i < loadingMessages.length; i++) {
            await new Promise(resolve => setTimeout(resolve, 1000));
            try {
                await ctx.telegram.editMessageText(
                    ctx.chat.id,
                    loadingMsg.message_id,
                    null,
                    loadingMessages[i],
                    { parse_mode: 'Markdown' }
                );
            } catch (editError) {
                console.log('Error editing loading message:', editError);
            }
        }

        // ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØªÙˆÙ‚Ø¹
        const prediction = goalAI.generateSmartPrediction(userData.user_id);
        
        // ðŸ“Š ØªØ­Ø¯ÙŠØ« Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        if (userData.subscription_status !== 'active') {
            userData.free_attempts--;
        }
        userData.total_predictions = (userData.total_predictions || 0) + 1;
        userData.total_bets = (userData.total_bets || 0) + ctx.session.currentBet;
        userData.lastPrediction = prediction;
        await dbManager.saveUser(ctx.from.id.toString(), userData);

        // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ Ø§Ù„Ø­Ø§Ù„ÙŠ
        const now = new Date();
        const saudiTime = new Date(now.getTime() + (3 * 60 * 60 * 1000));
        const realTime = saudiTime.toLocaleTimeString('ar-SA', { 
            hour: '2-digit', 
            minute: '2-digit',
            second: '2-digit',
            hour12: false 
        });

        // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªÙˆÙ‚Ø¹ Ù…Ø¹ Ø§Ù„ØµÙˆØ±Ø© - Ù…Ø¯Ù…Ø¬ ÙÙŠ Ø±Ø³Ø§Ù„Ø© ÙˆØ§Ø­Ø¯Ø©
        const analysisMessage = `
ðŸ¤– *ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ø§Ù„Ù…ØªÙ‚Ø¯Ù… - v${CONFIG.VERSION}*

ðŸŽ¯ *Ù†ØªÙŠØ¬Ø© Ø§Ù„ØªØ­Ù„ÙŠÙ„:*
${prediction.type}
ðŸ“ˆ *Ø§Ù„Ø§Ø­ØªÙ…Ø§Ù„ÙŠØ©:* ${prediction.probability}%
ðŸŽ¯ *Ø§Ù„Ø«Ù‚Ø©:* ${prediction.confidence}%

ðŸ’¡ *Ø§Ù„ØªØ­Ù„ÙŠÙ„:*
${prediction.reasoning}

ðŸ” *Ø§Ù„Ø­Ø³Ø§Ø¨:* \`${userData.onexbet}\`
ðŸ’° *Ù…Ø¨Ù„Øº Ø§Ù„Ø±Ù‡Ø§Ù†:* ${ctx.session.currentBet}$
ðŸ•’ *Ø§Ù„ÙˆÙ‚Øª:* ${realTime}

${userData.subscription_status !== 'active' ? 
    `ðŸ†“ *Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„Ù…ØªØ¨Ù‚ÙŠØ©:* ${userData.free_attempts}` : 
    `âœ… *Ø§Ø´ØªØ±Ø§Ùƒ Ù†Ø´Ø· - Ù…Ø­Ø§ÙˆÙ„Ø§Øª ØºÙŠØ± Ù…Ø­Ø¯ÙˆØ¯Ø©*`}
        `;

        // Ø­ÙØ¸ Ø§Ù„Ø£Ø²Ø±Ø§Ø± ÙÙŠ Ø§Ù„Ø¬Ù„Ø³Ø©
        ctx.session.predictionButtons = Markup.inlineKeyboard([
            [Markup.button.callback('âœ… Ø±Ø¨Ø­Øª', `win_${Date.now()}`)],
            [Markup.button.callback('âŒ Ø®Ø³Ø±Øª', `lose_${Date.now()}`)]
        ]);

        // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±Ø© Ù…Ø¹ Ø§Ù„ØªÙˆÙ‚Ø¹ ÙÙŠ Ø±Ø³Ø§Ù„Ø© ÙˆØ§Ø­Ø¯Ø©
        await ctx.replyWithPhoto(CONFIG.PREDICTION_IMAGE, {
            caption: analysisMessage,
            parse_mode: 'Markdown',
            reply_markup: ctx.session.predictionButtons.reply_markup
        });

        // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø± Ù„Ù„Ù‚Ù†Ø§Ø©
        await channelNotifier.sendPredictionNotification(userData, prediction, ctx.session.currentBet);

        // Ø­Ø°Ù Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±
        await ctx.deleteMessage(loadingMsg.message_id);

    } catch (error) {
        console.error('Get prediction error:', error);
        await ctx.replyWithMarkdown('âŒ *Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„ØªØ­Ù„ÙŠÙ„*', getMainKeyboard());
    }
}

async function handleUserStats(ctx, userData) {
    const accuracy = userData.correct_predictions > 0 ? 
        Math.round((userData.correct_predictions / (userData.total_predictions || 1)) * 100) : 0;
    
    let subscriptionInfo = '';
    if (userData.subscription_status === 'active') {
        const remainingDays = calculateRemainingDays(userData.subscription_end_date);
        subscriptionInfo = `\nðŸ“¦ *Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ:* ${getSubscriptionDisplayName(userData.subscription_type)}\n` +
                          `â³ *Ù…ØªØ¨Ù‚ÙŠ:* ${remainingDays} ÙŠÙˆÙ…`;
    } else {
        subscriptionInfo = `\nðŸ†“ *Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ù…Ø¬Ø§Ù†ÙŠØ©:* ${userData.free_attempts}`;
    }
    
    await ctx.replyWithMarkdown(
        `ðŸ“Š *Ø¥Ø­ØµØ§Ø¦ÙŠØ§ØªÙƒ Ø§Ù„Ø´Ø®ØµÙŠØ©*\n\n` +
        `ðŸ“ *Ø§Ù„Ø¯ÙˆÙ„Ø©:* ${userData.country || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'}\n` +
        `ðŸ” ${userData.onexbet}\n` +
        `ðŸ‘¤ ${userData.username}\n` +
        `ðŸ“ˆ ${userData.total_predictions || 0} ØªÙˆÙ‚Ø¹\n` +
        `âœ… ${userData.correct_predictions || 0} ØµØ­ÙŠØ­Ø©\n` +
        `ðŸŽ¯ ${accuracy}% Ø¯Ù‚Ø©\n` +
        `ðŸŽ‰ ${userData.wins || 0} ÙÙˆØ²\n` +
        `ðŸ’” ${userData.losses || 0} Ø®Ø³Ø§Ø±Ø©\n` +
        `ðŸ’° Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø±Ù‡Ø§Ù†Ø§Øª: ${userData.total_bets || 0}$\n` +
        `ðŸ’µ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø£Ø±Ø¨Ø§Ø­: ${userData.total_profit || 0}$` +
        subscriptionInfo +
        `\nðŸ”„ *Ø¢Ø®Ø± ØªØ­Ø¯ÙŠØ« Ù„Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ©:* ${new Date(userData.last_algorithm_check).toLocaleTimeString('ar-SA')}`,
        getMainKeyboard()
    );
}

async function handleBotStats(ctx) {
    const stats = dynamicStats.getStats();
    await ctx.replyWithMarkdown(
        `ðŸ‘¥ *Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØª*\n\n` +
        `ðŸ‘¤ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: ${stats.totalUsers.toLocaleString()}\n` +
        `ðŸŸ¢ Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù†Ø´Ø·ÙŠÙ† Ø§Ù„Ø¢Ù†: ${stats.activeUsers}\n` +
        `ðŸ“Š Ø§Ù„ØªÙˆÙ‚Ø¹Ø§Øª Ø§Ù„ÙŠÙˆÙ…ÙŠØ©: ${Math.floor(stats.activeUsers * 8.5)}\n\n` +
        `ðŸŽ¯ *Ø§Ù„Ù†Ø¸Ø§Ù… ÙŠØ¹Ù…Ù„ Ø¨ÙƒÙØ§Ø¡Ø© Ø¹Ø§Ù„ÙŠØ©*`,
        getMainKeyboard()
    );
}

async function handleSubscriptions(ctx, userData) {
    try {
        await ctx.replyWithMarkdown(
            'ðŸ’³ *Ø¨Ø§Ù‚Ø§Øª Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ù…ØªØ§Ø­Ø©*\n\n' +
            'ðŸ“¦ Ø§Ø®ØªØ± Ø§Ù„Ø¨Ø§Ù‚Ø© Ø§Ù„Ù…Ù†Ø§Ø³Ø¨Ø© Ù„Ùƒ:\n\n' +
            'ðŸ’° Ø£Ø³Ø¨ÙˆØ¹ÙŠ - 7 Ø£ÙŠØ§Ù…\n' +
            'ðŸ’° Ø´Ù‡Ø±ÙŠ - 30 ÙŠÙˆÙ…Ø§Ù‹\n' +
            'ðŸ’° 3 Ø£Ø´Ù‡Ø± - 90 ÙŠÙˆÙ…Ø§Ù‹\n' +
            'ðŸ’° Ø³Ù†ÙˆÙŠ - 365 ÙŠÙˆÙ…Ø§Ù‹\n\n' +
            'ðŸ’¡ Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø± Ø§Ù„Ù…Ù†Ø§Ø³Ø¨ Ù„Ø¹Ø±Ø¶ Ø§Ù„ØªÙØ§ØµÙŠÙ„',
            getSubscriptionKeyboard()
        );
    } catch (error) {
        console.error('Subscriptions error:', error);
        await ctx.replyWithMarkdown('âŒ *Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø§Ø´ØªØ±Ø§ÙƒØ§Øª*', getMainKeyboard());
    }
}

// ðŸ†• HANDLE SUBSCRIPTION SELECTION - UPDATED FOR DUAL PAYMENT
async function handleSubscriptionSelection(ctx, userData, text) {
    const subscriptionTypeMap = {
        'ðŸ’° Ø£Ø³Ø¨ÙˆØ¹ÙŠ': 'week',
        'ðŸ’° Ø´Ù‡Ø±ÙŠ': 'month', 
        'ðŸ’° 3 Ø£Ø´Ù‡Ø±': 'three_months',
        'ðŸ’° Ø³Ù†ÙˆÙŠ': 'year'
    };

    const subscriptionType = subscriptionTypeMap[text];
    if (!subscriptionType) {
        await ctx.replyWithMarkdown('âŒ *Ø§Ø®ØªÙŠØ§Ø± ØºÙŠØ± ØµØ­ÙŠØ­*', getSubscriptionKeyboard());
        return;
    }

    try {
        const settings = await dbManager.getSettings();
        const paymentSystem = ctx.session.paymentSystem || 'binance';
        
        if (paymentSystem === 'binance') {
            // Ù†Ø¸Ø§Ù… Ø¨Ø§ÙŠÙ†Ø§Ù†Ø³
            const prices = settings.prices.binance;
            const payment_links = settings.payment_links.binance;

            // ðŸ”§ FIX: Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ø³Ø¹Ø± Ù„Ø¨Ø§Ù‚Ø© 3 Ø£Ø´Ù‡Ø±
            if (!prices || !prices[subscriptionType]) {
                await ctx.replyWithMarkdown('âŒ *Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø³Ø¹Ø± Ù„Ù„Ø¨Ø§Ù‚Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©*', getSubscriptionKeyboard());
                return;
            }

            const displayName = getSubscriptionDisplayName(subscriptionType);
            
            const paymentLink = payment_links[subscriptionType];
            const isImage = paymentLink && (paymentLink.includes('.jpg') || paymentLink.includes('.png') || paymentLink.includes('.jpeg') || paymentLink.includes('.gif') || paymentLink.includes('imgbb') || paymentLink.includes('i.ibb.co') || paymentLink.startsWith('https://i.ibb.co'));

            if (isImage) {
                const subscriptionMessage = `ðŸ’³ *Ø¨Ø§Ù‚Ø© ${displayName} - Ø¨Ø§ÙŠÙ†Ø§Ù†Ø³*\n\n` +
                    `ðŸ’° Ø§Ù„Ø³Ø¹Ø±: ${prices[subscriptionType]}$\n` +
                    `â° Ø§Ù„Ù…Ø¯Ø©: ${getSubscriptionDuration(subscriptionType)}\n\n` +
                    `ðŸ“‹ *Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹:*\n` +
                    `ðŸ’³ Ø§Ø¯ÙØ¹ Ø¨Ø§Ù„Ù…Ø³Ø­ Ø¹Ø¨Ø± Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§\n` +
                    `ðŸ“± Ø£Ùˆ Ø§Ù…Ø³Ø­ Ø§Ù„ÙƒÙˆØ¯ Ù„Ù…ÙˆØ§ØµÙ„Ø© Ø§Ù„Ø¯ÙØ¹\n\n` +
                    `ðŸ’¡ *Ù‡Ù„ ØªØ±ÙŠØ¯ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ù…Ø¹ Ù‡Ø°Ù‡ Ø§Ù„Ø¨Ø§Ù‚Ø©ØŸ*`;

                try {
                    await ctx.replyWithPhoto(paymentLink, {
                        caption: subscriptionMessage,
                        parse_mode: 'Markdown',
                        reply_markup: {
                            inline_keyboard: [
                                [ { text: 'âœ… Ù†Ø¹Ù…ØŒ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©', callback_data: `confirm_binance_${subscriptionType}` } ],
                                [ { text: 'ðŸ”™ Ø±Ø¬ÙˆØ¹', callback_data: 'back_to_subscriptions' } ]
                            ]
                        }
                    });
                } catch (photoError) {
                    console.error('Error sending payment image:', photoError);
                    await ctx.replyWithMarkdown(
                        `âŒ *ØªØ¹Ø°Ø± ØªØ­Ù…ÙŠÙ„ ØµÙˆØ±Ø© Ø§Ù„Ø¯ÙØ¹*\n\n${subscriptionMessage}`,
                        {
                            reply_markup: {
                                inline_keyboard: [
                                    [ { text: 'âœ… Ù†Ø¹Ù…ØŒ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©', callback_data: `confirm_binance_${subscriptionType}` } ],
                                    [ { text: 'ðŸ”™ Ø±Ø¬ÙˆØ¹', callback_data: 'back_to_subscriptions' } ]
                                ]
                            }
                        }
                    );
                }
            } else {
                const subscriptionMessage = `ðŸ’³ *Ø¨Ø§Ù‚Ø© ${displayName} - Ø¨Ø§ÙŠÙ†Ø§Ù†Ø³*\n\n` +
                    `ðŸ’° Ø§Ù„Ø³Ø¹Ø±: ${prices[subscriptionType]}$\n` +
                    `â° Ø§Ù„Ù…Ø¯Ø©: ${getSubscriptionDuration(subscriptionType)}\n\n` +
                    `ðŸ”— *Ø±Ø§Ø¨Ø· Ø§Ù„Ø¯ÙØ¹:* ${paymentLink}\n\n` +
                    `ðŸ“‹ *Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹:*\n` +
                    `1. Ø§Ø¯ÙØ¹ Ø¹Ø¨Ø± Ø§Ù„Ø±Ø§Ø¨Ø· Ø£Ø¹Ù„Ø§Ù‡\n` +
                    `2. Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet (10 Ø£Ø±Ù‚Ø§Ù…)\n` +
                    `3. Ø£Ø±Ø³Ù„ ØµÙˆØ±Ø© Ø¥Ø«Ø¨Ø§Øª Ø§Ù„Ø¯ÙØ¹\n` +
                    `4. Ø§Ù†ØªØ¸Ø± Ø§Ù„ØªÙØ¹ÙŠÙ„ Ù…Ù† Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©\n\n` +
                    `ðŸ’¡ *Ù‡Ù„ ØªØ±ÙŠØ¯ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ù…Ø¹ Ù‡Ø°Ù‡ Ø§Ù„Ø¨Ø§Ù‚Ø©ØŸ*`;

                await ctx.replyWithMarkdown(subscriptionMessage, {
                    reply_markup: {
                        inline_keyboard: [
                            [ { text: 'âœ… Ù†Ø¹Ù…ØŒ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©', callback_data: `confirm_binance_${subscriptionType}` } ],
                            [ { text: 'ðŸ”™ Ø±Ø¬ÙˆØ¹', callback_data: 'back_to_subscriptions' } ]
                        ]
                    }
                });
            }
        } 
        else if (paymentSystem === 'bank') {
            // ðŸ†• Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¨Ù†ÙƒÙŠ Ø§Ù„Ø¬Ø¯ÙŠØ¯
            const prices = settings.prices.bank;
            const bankDetails = settings.payment_links.bank[subscriptionType];

            // ðŸ”§ FIX: Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ø³Ø¹Ø± Ù„Ø¨Ø§Ù‚Ø© 3 Ø£Ø´Ù‡Ø±
            if (!prices || !prices[subscriptionType]) {
                await ctx.replyWithMarkdown('âŒ *Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø³Ø¹Ø± Ù„Ù„Ø¨Ø§Ù‚Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©*', getSubscriptionKeyboard());
                return;
            }

            const displayName = getSubscriptionDisplayName(subscriptionType);
            
            const subscriptionMessage = `ðŸ¦ *Ø¨Ø§Ù‚Ø© ${displayName} - ØªØ­ÙˆÙŠÙ„ Ø¨Ù†ÙƒÙŠ*\n\n` +
                `ðŸ’° Ø§Ù„Ø³Ø¹Ø±: ${prices[subscriptionType]}$\n` +
                `â° Ø§Ù„Ù…Ø¯Ø©: ${getSubscriptionDuration(subscriptionType)}\n\n` +
                `ðŸ’³ *Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¨Ù†ÙƒÙŠ:*\n` +
                `${bankDetails.description}\n\n` +
                `ðŸ’¡ *Ù‡Ù„ ØªØ±ÙŠØ¯ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ù…Ø¹ Ù‡Ø°Ù‡ Ø§Ù„Ø¨Ø§Ù‚Ø©ØŸ*`;

            // Ø¥Ø±Ø³Ø§Ù„ ØµÙˆØ±Ø© Ø§Ù„Ø¨Ù†Ùƒ Ø¥Ø°Ø§ Ù…ÙˆØ¬ÙˆØ¯Ø©
            if (bankDetails.image && bankDetails.image.startsWith('http')) {
                try {
                    await ctx.replyWithPhoto(bankDetails.image, {
                        caption: subscriptionMessage,
                        parse_mode: 'Markdown',
                        reply_markup: {
                            inline_keyboard: [
                                [ { text: 'âœ… Ù†Ø¹Ù…ØŒ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©', callback_data: `confirm_bank_${subscriptionType}` } ],
                                [ { text: 'ðŸ”™ Ø±Ø¬ÙˆØ¹', callback_data: 'back_to_subscriptions' } ]
                            ]
                        }
                    });
                } catch (photoError) {
                    console.error('Error sending bank image:', photoError);
                    await ctx.replyWithMarkdown(subscriptionMessage, {
                        reply_markup: {
                            inline_keyboard: [
                                [ { text: 'âœ… Ù†Ø¹Ù…ØŒ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©', callback_data: `confirm_bank_${subscriptionType}` } ],
                                [ { text: 'ðŸ”™ Ø±Ø¬ÙˆØ¹', callback_data: 'back_to_subscriptions' } ]
                            ]
                        }
                    });
                }
            } else {
                await ctx.replyWithMarkdown(subscriptionMessage, {
                    reply_markup: {
                        inline_keyboard: [
                            [ { text: 'âœ… Ù†Ø¹Ù…ØŒ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©', callback_data: `confirm_bank_${subscriptionType}` } ],
                            [ { text: 'ðŸ”™ Ø±Ø¬ÙˆØ¹', callback_data: 'back_to_subscriptions' } ]
                        ]
                    }
                });
            }
        }

    } catch (error) {
        console.error('Subscription selection error:', error);
        await ctx.replyWithMarkdown('âŒ *Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø·Ù„Ø¨ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ*', getSubscriptionKeyboard());
    }
}

// ðŸ†• Ù…Ø¹Ø§Ù„Ø¬Ø© ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ - UPDATED FOR DUAL PAYMENT
async function handleSubscriptionConfirmation(ctx, callbackData) {
    try {
        const userId = ctx.from.id.toString();
        const userData = await dbManager.getUser(userId);

        if (!userData) {
            await ctx.answerCbQuery('âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…');
            return;
        }

        // ÙØµÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ùƒallback
        const parts = callbackData.split('_');
        const paymentSystem = parts[1];
        const subscriptionType = parts.slice(2).join('_');

        const settings = await dbManager.getSettings();
        const prices = settings.prices[paymentSystem];

        // ðŸ”§ FIX: Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ø³Ø¹Ø±
        if (!prices || !prices[subscriptionType]) {
            await ctx.answerCbQuery('âŒ Ø®Ø·Ø£ ÙÙŠ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø³Ø¹Ø±');
            return;
        }

        ctx.session.paymentSystem = paymentSystem;
        ctx.session.paymentType = subscriptionType;
        ctx.session.awaitingPaymentAccount = true;

        await ctx.answerCbQuery('âœ… ØªÙ… ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø§Ø®ØªÙŠØ§Ø±');
        
        // Ø­Ø°Ù Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©
        await ctx.deleteMessage(ctx.callbackQuery.message.message_id);

        if (paymentSystem === 'binance') {
            await ctx.replyWithMarkdown(
                `ðŸ’³ *Ø¨Ø§Ù‚Ø© ${getSubscriptionDisplayName(subscriptionType)} - Ø¨Ø§ÙŠÙ†Ø§Ù†Ø³*\n\n` +
                `ðŸ’° Ø§Ù„Ø³Ø¹Ø±: ${prices[subscriptionType]}$\n\n` +
                `ðŸ” *Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨Ùƒ Ø§Ù„Ù…Ø³Ø¬Ù„:* \`${userData.onexbet}\`\n\n` +
                `ðŸ”¢ *Ø§Ù„Ø¢Ù† Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet Ù„Ù„ØªØ£ÙƒØ¯:*`
            );
        } 
        else if (paymentSystem === 'bank') {
            const bankDetails = settings.payment_links.bank[subscriptionType];
            
            await ctx.replyWithMarkdown(
                `ðŸ¦ *Ø¨Ø§Ù‚Ø© ${getSubscriptionDisplayName(subscriptionType)} - ØªØ­ÙˆÙŠÙ„ Ø¨Ù†ÙƒÙŠ*\n\n` +
                `ðŸ’° Ø§Ù„Ø³Ø¹Ø±: ${prices[subscriptionType]}$\n\n` +
                `ðŸ’³ *Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ØªØ­ÙˆÙŠÙ„:*\n` +
                `${bankDetails.description}\n\n` +
                `ðŸ” *Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨Ùƒ Ø§Ù„Ù…Ø³Ø¬Ù„:* \`${userData.onexbet}\`\n\n` +
                `ðŸ”¢ *Ø§Ù„Ø¢Ù† Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet Ù„Ù„ØªØ£ÙƒØ¯:*`
            );
        }

    } catch (error) {
        console.error('Subscription confirmation error:', error);
        await ctx.answerCbQuery('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©');
    }
}

async function handleSubscriptionStatus(ctx, userData) {
    let statusMessage = '';
    
    if (userData.subscription_status === 'active') {
        const remainingDays = calculateRemainingDays(userData.subscription_end_date);
        statusMessage = `âœ… *Ø§Ø´ØªØ±Ø§ÙƒÙƒ Ù†Ø´Ø·*\n\n` +
                       `ðŸ“ *Ø§Ù„Ø¯ÙˆÙ„Ø©:* ${userData.country || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'}\n` +
                       `ðŸ” Ø§Ù„Ø­Ø³Ø§Ø¨: \`${userData.onexbet}\`\n` +
                       `ðŸ“¦ Ø§Ù„Ù†ÙˆØ¹: ${getSubscriptionDisplayName(userData.subscription_type)}\n` +
                       `ðŸ“… Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡: ${new Date(userData.subscription_end_date).toLocaleDateString('ar-EG')}\n` +
                       `â³ Ù…ØªØ¨Ù‚ÙŠ: ${remainingDays} ÙŠÙˆÙ…\n` +
                       `ðŸ”„ *Ø¢Ø®Ø± ØªØ­Ø¯ÙŠØ« Ù„Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ©:* ${new Date(userData.last_algorithm_check).toLocaleTimeString('ar-SA')}`;
    } else if (userData.free_attempts > 0) {
        statusMessage = `ðŸŽ¯ *Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ù…Ø¬Ø§Ù†ÙŠØ© Ù…ØªØ§Ø­Ø©*\n\n` +
                       `ðŸ“ *Ø§Ù„Ø¯ÙˆÙ„Ø©:* ${userData.country || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'}\n` +
                       `ðŸ” Ø§Ù„Ø­Ø³Ø§Ø¨: \`${userData.onexbet}\`\n` +
                       `ðŸ†“ Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ù…Ø¬Ø§Ù†ÙŠØ©: ${userData.free_attempts}\n` +
                       `ðŸ”„ *Ø¢Ø®Ø± ØªØ­Ø¯ÙŠØ« Ù„Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ©:* ${new Date(userData.last_algorithm_check).toLocaleTimeString('ar-SA')}\n\n` +
                       `ðŸ’³ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…ÙŠØ²Ø§Øª ØºÙŠØ± Ù…Ø­Ø¯ÙˆØ¯Ø©`;
    } else {
        statusMessage = `ðŸš« *Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª*\n\n` +
                       `ðŸ“ *Ø§Ù„Ø¯ÙˆÙ„Ø©:* ${userData.country || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'}\n` +
                       `ðŸ” Ø§Ù„Ø­Ø³Ø§Ø¨: \`${userData.onexbet}\`\n` +
                       `ðŸ”„ *Ø¢Ø®Ø± ØªØ­Ø¯ÙŠØ« Ù„Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ©:* ${new Date(userData.last_algorithm_check).toLocaleTimeString('ar-SA')}\n\n` +
                       `ðŸ’³ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ù„Ù„Ù…ØªØ§Ø¨Ø¹Ø© ÙÙŠ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø®Ø¯Ù…Ø©`;
    }
    
    await ctx.replyWithMarkdown(statusMessage, getMainKeyboard());
}

// ðŸ†• ØªØ­Ø¯ÙŠØ« Ù…Ø¹Ø§Ù„Ø¬Ø© ØµÙˆØ± Ø§Ù„Ø¯ÙØ¹ Ù„ØªØ´Ù…Ù„ Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ø²Ø¯ÙˆØ¬
async function handlePaymentScreenshot(ctx, userId) {
    try {
        const userData = await dbManager.getUser(userId);
        const photo = ctx.message.photo[ctx.message.photo.length - 1];
        const fileLink = await bot.telegram.getFileLink(photo.file_id);
        const imageUrl = fileLink.href;

        const settings = await dbManager.getSettings();
        const paymentSystem = ctx.session.paymentSystem || 'binance';
        const prices = settings.prices[paymentSystem];

        const accountNumber = ctx.session.paymentAccount || userData.onexbet;

        // ðŸ”§ FIX: Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ø³Ø¹Ø± ÙˆØ§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        if (!prices || !prices[ctx.session.paymentType]) {
            await ctx.replyWithMarkdown('âŒ Ø®Ø·Ø£ ÙÙŠ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø³Ø¹Ø±ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰');
            return;
        }

        // Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ Ù…Ù† ØªØ·Ø§Ø¨Ù‚ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨
        if (accountNumber !== userData.onexbet) {
            await ctx.replyWithMarkdown(
                'âŒ *Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨ Ù„Ø§ ÙŠØªØ·Ø§Ø¨Ù‚ Ù…Ø¹ Ø§Ù„Ù…Ø³Ø¬Ù„!*\n\n' +
                `ðŸ” Ø­Ø³Ø§Ø¨Ùƒ Ø§Ù„Ù…Ø³Ø¬Ù„: \`${userData.onexbet}\`\n` +
                `ðŸ”¢ Ø§Ù„Ø±Ù‚Ù… Ø§Ù„Ù…Ø±Ø³Ù„: \`${accountNumber}\`\n\n` +
                'ðŸ’¡ ÙŠØ±Ø¬Ù‰ Ø¥Ø¹Ø§Ø¯Ø© Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø¯ÙØ¹ Ø¨Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨Ùƒ Ø§Ù„ØµØ­ÙŠØ­',
                getMainKeyboard()
            );
            
            ctx.session.paymentSystem = null;
            ctx.session.paymentType = null;
            ctx.session.awaitingPaymentAccount = false;
            ctx.session.paymentAccount = null;
            return;
        }

        // Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø© Ø¥Ù„Ù‰ imgbb
        const uploadResult = await imgbbUploader.uploadImageFromUrl(imageUrl);
        
        if (!uploadResult.success) {
            await ctx.replyWithMarkdown('âŒ ÙØ´Ù„ ÙÙŠ Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø©ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰');
            return;
        }

        const paymentData = {
            user_id: userId,
            onexbet: accountNumber,
            screenshot_url: uploadResult.url,
            amount: prices[ctx.session.paymentType],
            subscription_type: ctx.session.paymentType,
            payment_system: paymentSystem,
            username: userData.username,
            timestamp: new Date().toISOString()
        };

        const paymentId = await dbManager.addPayment(paymentData);
        
        // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø± Ù„Ù„Ø¥Ø¯Ø§Ø±Ø© Ù…Ø¹ Ø§Ù„ØµÙˆØ±Ø©
        try {
            const paymentSystemText = paymentSystem === 'binance' ? 'Ø¨Ø§ÙŠÙ†Ø§Ù†Ø³' : 'ØªØ­ÙˆÙŠÙ„ Ø¨Ù†ÙƒÙŠ';
            const subscriptionDisplayName = getSubscriptionDisplayName(ctx.session.paymentType);
            
            await bot.telegram.sendPhoto(
                CONFIG.ADMIN_ID,
                uploadResult.url,
                {
                    caption: `ðŸ†• *Ø·Ù„Ø¨ Ø¯ÙØ¹ Ø¬Ø¯ÙŠØ¯ - ${paymentSystemText}*\n\n` +
                    `ðŸ‘¤ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: ${userData.username}\n` +
                    `ðŸ” Ø§Ù„Ø­Ø³Ø§Ø¨: ${accountNumber}\n` +
                    `ðŸ’° Ø§Ù„Ù…Ø¨Ù„Øº: ${paymentData.amount}$\n` +
                    `ðŸ“¦ Ø§Ù„Ø¨Ø§Ù‚Ø©: ${subscriptionDisplayName}\n` +
                    `ðŸ’³ Ø§Ù„Ù†Ø¸Ø§Ù…: ${paymentSystemText}\n` +
                    `ðŸ†” Ø§Ù„Ø±Ù‚Ù…: ${paymentId}\n` +
                    `ðŸ“… Ø§Ù„ÙˆÙ‚Øª: ${new Date().toLocaleString('ar-EG')}`,
                    parse_mode: 'Markdown',
                    reply_markup: {
                        inline_keyboard: [
                            [
                                { text: 'âœ… Ù‚Ø¨ÙˆÙ„ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ', callback_data: `accept_${paymentId}` },
                                { text: 'âŒ Ø±ÙØ¶ Ø§Ù„Ø·Ù„Ø¨', callback_data: `reject_${paymentId}` }
                            ]
                        ]
                    }
                }
            );
        } catch (error) {
            console.error('Error notifying admin:', error);
        }

        await ctx.replyWithMarkdown(
            'ðŸ“© *ØªÙ… Ø§Ø³ØªÙ„Ø§Ù… ØµÙˆØ±Ø© Ø§Ù„Ø¯ÙØ¹ Ø¨Ù†Ø¬Ø§Ø­*\n\n' +
            `âœ… Ø§Ù„Ø­Ø³Ø§Ø¨: \`${accountNumber}\`\n` +
            `âœ… Ø§Ù„Ø¨Ø§Ù‚Ø©: ${getSubscriptionDisplayName(ctx.session.paymentType)}\n` +
            `ðŸ’° Ø§Ù„Ù…Ø¨Ù„Øº: ${paymentData.amount}$\n` +
            `ðŸ’³ Ø§Ù„Ù†Ø¸Ø§Ù…: ${paymentSystem === 'binance' ? 'Ø¨Ø§ÙŠÙ†Ø§Ù†Ø³' : 'ØªØ­ÙˆÙŠÙ„ Ø¨Ù†ÙƒÙŠ'}\n\n` +
            'âœ… Ø³ÙŠØªÙ… Ù…Ø±Ø§Ø¬Ø¹ØªÙ‡Ø§ Ù…Ù† Ø§Ù„Ø¥Ø¯Ø§Ø±Ø© ÙÙŠ Ø£Ù‚Ø±Ø¨ ÙˆÙ‚Øª\n' +
            'â° Ø¹Ø§Ø¯Ø©Ù‹ Ø®Ù„Ø§Ù„ 24 Ø³Ø§Ø¹Ø©\n\n' +
            `ðŸ“ž Ù„Ù„Ø§Ø³ØªÙØ³Ø§Ø±: @GEMZGOOLBOT`,
            getMainKeyboard()
        );

        ctx.session.paymentSystem = null;
        ctx.session.paymentType = null;
        ctx.session.awaitingPaymentAccount = false;
        ctx.session.paymentAccount = null;
    } catch (error) {
        console.error('Payment screenshot error:', error);
        await ctx.replyWithMarkdown('âŒ *Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© ØµÙˆØ±Ø© Ø§Ù„Ø¯ÙØ¹*', getMainKeyboard());
    }
}

// ðŸ†• ðŸ”§ ADMIN HANDLERS - UPDATED FOR DUAL PAYMENT SYSTEM

async function handleAdminCommands(ctx, text) {
    const session = ctx.session;
    
    try {
        // FIRST: Handle all specific admin steps
        if (session.adminStep === 'search_user') {
            await handleAdminSearchUser(ctx, text);
            return;
        }

        if (session.adminStep === 'broadcast') {
            await handleAdminBroadcast(ctx, text);
            return;
        }

        if (session.adminStep === 'select_payment_system') {
            await handleAdminSelectPaymentSystem(ctx, text);
            return;
        }

        if (session.adminStep === 'edit_price_and_payment') {
            await handleAdminEditPriceAndPayment(ctx, text);
            return;
        }

        if (session.adminStep === 'select_subscription_edit') {
            await handleAdminSelectSubscriptionEdit(ctx, text);
            return;
        }

        // ðŸ†• Ù…Ø¹Ø§Ù„Ø¬Ø© Ø®Ø·ÙˆØ§Øª ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø¨Ù†ÙƒÙŠ Ø§Ù„Ù…Ù†Ø¸Ù…Ø©
        if (session.adminStep === 'edit_bank_price') {
            await handleAdminEditBankPrice(ctx, text);
            return;
        }

        if (session.adminStep === 'edit_bank_account') {
            await handleAdminEditBankAccount(ctx, text);
            return;
        }

        // ðŸ†• Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠ
        if (['ðŸ’¾ Ù†Ø³Ø® Ø§Ø­ØªÙŠØ§Ø·ÙŠ', 'ðŸ“¥ Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª', 'ðŸ“‹ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù†Ø³Ø®'].includes(text)) {
            await handleAdminBackupCommands(ctx, text);
            return;
        }

        // Handle backup restore step
        if (session.adminStep === 'restore_backup') {
            await handleAdminBackupRestoreSelection(ctx, text);
            return;
        }

        // SECOND: Handle navigation and main commands
        switch (text) {
            case 'ðŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù†Ø¸Ø§Ù…':
                await handleAdminStats(ctx);
                break;
                
            case 'ðŸ‘¥ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†':
                session.adminStep = 'users';
                await ctx.replyWithMarkdown('ðŸ‘¥ *Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†*', getAdminUsersKeyboard());
                break;
                
            case 'ðŸ’° Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ø¯ÙØ¹':
                session.adminStep = 'payments';
                await ctx.replyWithMarkdown('ðŸ’° *Ø¥Ø¯Ø§Ø±Ø© Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ø¯ÙØ¹*', getAdminPaymentsKeyboard());
                break;
                
            case 'âš™ï¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª':
                session.adminStep = 'settings';
                await ctx.replyWithMarkdown('âš™ï¸ *Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø©*', getAdminSettingsKeyboard());
                break;

            case 'ðŸ“¢ Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø±':
                session.adminStep = 'broadcast';
                await ctx.replyWithMarkdown(
                    'ðŸ“¢ *Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Ø¬Ù…Ø§Ø¹ÙŠ*\n\n' +
                    'âœï¸ Ø§Ù„Ø±Ø¬Ø§Ø¡ ÙƒØªØ§Ø¨Ø© Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ Ø¥Ø±Ø³Ø§Ù„Ù‡Ø§ Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†:'
                );
                break;

            case 'ðŸ” Ø¨Ø­Ø« Ø¹Ù† Ù…Ø³ØªØ®Ø¯Ù…':
                session.adminStep = 'search_user';
                await ctx.replyWithMarkdown(
                    'ðŸ” *Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù…Ø³ØªØ®Ø¯Ù…*\n\n' +
                    'ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¨Ø­Ø« Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù…:\n' +
                    'â€¢ Ø¢ÙŠØ¯ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…\n' +
                    'â€¢ Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…\n' +
                    'â€¢ Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet\n\n' +
                    'ðŸ”Ž Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ ÙƒÙ„Ù…Ø© Ø§Ù„Ø¨Ø­Ø«:'
                );
                break;

            case 'ðŸ”§ Ù‚ÙÙ„/ÙØªØ­ Ø§Ù„Ø¨ÙˆØª':
                await handleAdminToggleMaintenance(ctx);
                break;

            case 'ðŸ’° ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø£Ø³Ø¹Ø§Ø± ÙˆØ§Ù„Ø¯ÙØ¹':
                await handleAdminPriceAndPaymentSettings(ctx);
                break;
                
            case 'âš™ï¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø©':
                await handleAdminGeneralSettings(ctx);
                break;

            case 'ðŸ”„ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ¹ÙŠÙŠÙ†':
                await handleAdminReset(ctx);
                break;

            case 'ðŸ”™ Ø±Ø¬ÙˆØ¹':
                session.adminStep = 'main';
                await ctx.replyWithMarkdown('ðŸ”™ *Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©*', getAdminMainKeyboard());
                break;

            case 'ðŸ“‹ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†':
                await handleAdminUsersList(ctx);
                break;
                
            case 'âœ… Ø§Ù„Ù…Ø´ØªØ±ÙƒÙŠÙ† Ø§Ù„Ù†Ø´Ø·ÙŠÙ†':
                await handleAdminActiveUsers(ctx);
                break;
                
            case 'ðŸ†“ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠÙ†':
                await handleAdminFreeUsers(ctx);
                break;
                
            case 'ðŸ“ˆ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†':
                await handleAdminUsersStats(ctx);
                break;

            case 'ðŸ“¥ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…Ø¹Ù„Ù‚Ø©':
                await handleAdminPendingPayments(ctx);
                break;
                
            case 'âœ… Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…Ù‚Ø¨ÙˆÙ„Ø©':
                await handleAdminAcceptedPayments(ctx);
                break;
                
            case 'âŒ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…Ø±ÙÙˆØ¶Ø©':
                await handleAdminRejectedPayments(ctx);
                break;
                
            case 'ðŸ“‹ ÙƒÙ„ Ø§Ù„Ø·Ù„Ø¨Ø§Øª':
                await handleAdminAllPayments(ctx);
                break;
                
            case 'ðŸ”™ Ø§Ù„Ø®Ø±ÙˆØ¬ Ù…Ù† Ø§Ù„Ø¥Ø¯Ù…Ù†':
                session.adminMode = false;
                session.adminStep = null;
                await ctx.replyWithMarkdown('ðŸ”’ *ØªÙ… Ø§Ù„Ø®Ø±ÙˆØ¬ Ù…Ù† ÙˆØ¶Ø¹ Ø§Ù„Ø¥Ø¯Ù…Ù†*', { 
                    reply_markup: { remove_keyboard: true } 
                });
                break;
                
            default:
                await ctx.replyWithMarkdown('âŒ *Ø®ÙŠØ§Ø± ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ*', getAdminMainKeyboard());
                break;
        }
    } catch (error) {
        console.error('Admin commands error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£Ù…Ø±', getAdminMainKeyboard());
    }
}

// ðŸ†• Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠ ÙÙŠ Ø§Ù„Ø¥Ø¯Ù…Ù†
async function handleAdminBackupCommands(ctx, text) {
    try {
        const session = ctx.session;
        
        if (text === 'ðŸ’¾ Ù†Ø³Ø® Ø§Ø­ØªÙŠØ§Ø·ÙŠ') {
            const backupMsg = await ctx.replyWithMarkdown('ðŸ”„ *Ø¬Ø§Ø±ÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©...*');
            
            const success = await dbManager.createBackup();
            
            if (success) {
                await ctx.telegram.editMessageText(
                    ctx.chat.id,
                    backupMsg.message_id,
                    null,
                    'âœ… *ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø¨Ù†Ø¬Ø§Ø­*\n\n' +
                    'ðŸ“Š ØªÙ… Ø­ÙØ¸ Ø¬Ù…ÙŠØ¹ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† ÙˆØ§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª\n' +
                    'ðŸ›¡ï¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø­ÙÙˆØ¸Ø© Ø¨Ø£Ù…Ø§Ù† ÙÙŠ Firebase',
                    { parse_mode: 'Markdown' }
                );
            } else {
                await ctx.telegram.editMessageText(
                    ctx.chat.id,
                    backupMsg.message_id,
                    null,
                    'âŒ *ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©*\n\n' +
                    'âš ï¸ ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§ØªØµØ§Ù„ Firebase ÙˆØ§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰',
                    { parse_mode: 'Markdown' }
                );
            }
            return;
        }

        if (text === 'ðŸ“¥ Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª') {
            await handleAdminRestoreData(ctx);
            return;
        }

        if (text === 'ðŸ“‹ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù†Ø³Ø®') {
            await handleAdminListBackups(ctx);
            return;
        }

    } catch (error) {
        console.error('Admin backup commands error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£Ù…Ø±', getAdminMainKeyboard());
    }
}

// ðŸ†• Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
async function handleAdminRestoreData(ctx) {
    try {
        const backups = await dbManager.listBackups();
        
        if (backups.length === 0) {
            await ctx.replyWithMarkdown(
                'âŒ *Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†Ø³Ø® Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©*\n\n' +
                'ðŸ’¾ ÙŠØ±Ø¬Ù‰ Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø£ÙˆÙ„Ø§Ù‹',
                getAdminMainKeyboard()
            );
            return;
        }

        let message = 'ðŸ“‹ *Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø§Ù„Ù…ØªØ§Ø­Ø©*\n\n';
        
        backups.forEach((backup, index) => {
            const date = new Date(backup.timestamp).toLocaleString('ar-EG');
            message += `${index + 1}. *${backup.id}*\n`;
            message += `   ðŸ“… ${date}\n`;
            message += `   ðŸ‘¥ ${backup.userCount} Ù…Ø³ØªØ®Ø¯Ù…\n`;
            message += `   ðŸ’° ${backup.paymentCount} Ø¹Ù…Ù„ÙŠØ© Ø¯ÙØ¹\n\n`;
        });

        message += 'ðŸ”¢ *Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ Ø§Ø³ØªØ¹Ø§Ø¯ØªÙ‡Ø§:*';

        await ctx.replyWithMarkdown(message);
        ctx.session.adminStep = 'restore_backup';
        
    } catch (error) {
        console.error('Admin restore data error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©', getAdminMainKeyboard());
    }
}

// ðŸ†• Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù†Ø³Ø®Ø© Ù„Ù„Ø§Ø³ØªØ¹Ø§Ø¯Ø©
async function handleAdminBackupRestoreSelection(ctx, text) {
    try {
        const backups = await dbManager.listBackups();
        const backupIndex = parseInt(text) - 1;
        
        if (isNaN(backupIndex) || backupIndex < 0 || backupIndex >= backups.length) {
            await ctx.replyWithMarkdown('âŒ *Ø±Ù‚Ù… ØºÙŠØ± ØµØ­ÙŠØ­!*\n\nÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… ØµØ­ÙŠØ­ Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©');
            return;
        }

        const selectedBackup = backups[backupIndex];
        
        const confirmKeyboard = Markup.inlineKeyboard([
            [Markup.button.callback('âœ… Ù†Ø¹Ù…ØŒ Ø§Ø³ØªØ¹Ø§Ø¯Ø©', `confirm_restore_${selectedBackup.id}`)],
            [Markup.button.callback('âŒ Ø¥Ù„ØºØ§Ø¡', 'cancel_restore')]
        ]);

        await ctx.replyWithMarkdown(
            `âš ï¸ *ØªØ£ÙƒÙŠØ¯ Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª*\n\n` +
            `ðŸ“¦ *Ø§Ù„Ù†Ø³Ø®Ø©:* ${selectedBackup.id}\n` +
            `ðŸ“… *Ø§Ù„ØªØ§Ø±ÙŠØ®:* ${new Date(selectedBackup.timestamp).toLocaleString('ar-EG')}\n` +
            `ðŸ‘¥ *Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†:* ${selectedBackup.userCount}\n` +
            `ðŸ’° *Ø§Ù„Ù…Ø¯ÙÙˆØ¹Ø§Øª:* ${selectedBackup.paymentCount}\n\n` +
            `âŒ *ØªØ­Ø°ÙŠØ±:* Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø³ØªØ³ØªØ¨Ø¯Ù„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ©!\n\n` +
            `Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©ØŸ`,
            confirmKeyboard
        );

        ctx.session.adminStep = 'main';
        
    } catch (error) {
        console.error('Admin backup restore selection error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø§Ø®ØªÙŠØ§Ø±', getAdminMainKeyboard());
    }
}

// ðŸ†• Ù…Ø¹Ø§Ù„Ø¬Ø© Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©
async function handleAdminListBackups(ctx) {
    try {
        const backups = await dbManager.listBackups();
        
        if (backups.length === 0) {
            await ctx.replyWithMarkdown(
                'âŒ *Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†Ø³Ø® Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©*\n\n' +
                'ðŸ’¾ ÙŠØ±Ø¬Ù‰ Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø£ÙˆÙ„Ø§Ù‹',
                getAdminMainKeyboard()
            );
            return;
        }

        let message = 'ðŸ“‹ *Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©*\n\n';
        
        backups.forEach((backup, index) => {
            const date = new Date(backup.timestamp).toLocaleString('ar-EG');
            message += `${index + 1}. *${backup.id}*\n`;
            message += `   ðŸ“… ${date}\n`;
            message += `   ðŸ‘¥ ${backup.userCount} Ù…Ø³ØªØ®Ø¯Ù…\n`;
            message += `   ðŸ’° ${backup.paymentCount} Ø¹Ù…Ù„ÙŠØ© Ø¯ÙØ¹\n`;
            message += `   ðŸ·ï¸ ${backup.version}\n\n`;
        });

        await ctx.replyWithMarkdown(message, getAdminMainKeyboard());
        
    } catch (error) {
        console.error('Admin list backups error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù†Ø³Ø®', getAdminMainKeyboard());
    }
}

// Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù…Ø³ØªØ®Ø¯Ù…
async function handleAdminSearchUser(ctx, query) {
    try {
        console.log('ðŸ” Searching for users with query:', query);
        
        const users = await dbManager.searchUsers(query);
        
        if (users.length === 0) {
            await ctx.replyWithMarkdown('âŒ *Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†*', getAdminMainKeyboard());
            ctx.session.adminStep = 'main';
            return;
        }

        let message = `ðŸ” *Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨Ø­Ø« (${users.length})*\n\n`;
        
        users.slice(0, 10).forEach((user, index) => {
            const status = user.subscription_status === 'active' ? 'âœ…' : 'ðŸ†“';
            const username = user.username || 'Ø¨Ø¯ÙˆÙ† Ø§Ø³Ù…';
            const onexbet = user.onexbet || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯';
            const predictions = user.total_predictions || 0;
            const profit = user.total_profit || 0;
            
            message += `${index + 1}. ${username} ${status}\n`;
            message += `   ðŸ‘¤ ${user.user_id} | ðŸ” ${onexbet}\n`;
            message += `   ðŸ“Š ${predictions} ØªÙˆÙ‚Ø¹ | ðŸ’° ${profit}$\n\n`;
        });

        if (users.length > 10) {
            message += `... Ùˆ ${users.length - 10} Ù…Ø³ØªØ®Ø¯Ù… Ø¢Ø®Ø±`;
        }

        await ctx.replyWithMarkdown(message, getAdminMainKeyboard());
        ctx.session.adminStep = 'main';
        
    } catch (error) {
        console.error('Admin search user error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨Ø­Ø«', getAdminMainKeyboard());
        ctx.session.adminStep = 'main';
    }
}

// Ø§Ù„Ø¥Ø´Ø¹Ø§Ø± Ø§Ù„Ø¬Ù…Ø§Ø¹ÙŠ
async function handleAdminBroadcast(ctx, message) {
    try {
        console.log('ðŸ“¢ Starting broadcast to all users');
        
        const users = await dbManager.getAllUsers();
        let success = 0;
        let failed = 0;

        const broadcastMsg = await ctx.replyWithMarkdown('ðŸ“¢ *Ø¬Ø§Ø±ÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø± Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†...*');

        // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ù„ÙƒÙ„ Ù…Ø³ØªØ®Ø¯Ù…
        for (const user of users) {
            try {
                await bot.telegram.sendMessage(
                    user.user_id, 
                    `ðŸ“¢ *Ø¥Ø´Ø¹Ø§Ø± Ù…Ù† Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©*\n\n${message}`,
                    { parse_mode: 'Markdown' }
                );
                success++;
                
                // ØªØ£Ø®ÙŠØ± Ø¨Ø³ÙŠØ· Ù„ØªØ¬Ù†Ø¨ Ø­Ø¸Ø± Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù…
                await new Promise(resolve => setTimeout(resolve, 50));
                
            } catch (error) {
                console.log(`âŒ Failed to send to user ${user.user_id}:`, error.message);
                failed++;
            }
        }

        await ctx.replyWithMarkdown(
            `ðŸ“¢ *ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø± Ø¨Ù†Ø¬Ø§Ø­*\n\n` +
            `âœ… ØªÙ… Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ø¨Ù†Ø¬Ø§Ø­: ${success} Ù…Ø³ØªØ®Ø¯Ù…\n` +
            `âŒ ÙØ´Ù„ ÙÙŠ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„: ${failed} Ù…Ø³ØªØ®Ø¯Ù…\n` +
            `ðŸ‘¥ Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: ${users.length} Ù…Ø³ØªØ®Ø¯Ù…`,
            getAdminMainKeyboard()
        );

        ctx.session.adminStep = 'main';
        
    } catch (error) {
        console.error('Admin broadcast error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±', getAdminMainKeyboard());
        ctx.session.adminStep = 'main';
    }
}

async function handleAdminToggleMaintenance(ctx) {
    try {
        const settings = await dbManager.getSettings();
        const newStatus = !settings.maintenance_mode;
        
        await dbManager.setMaintenanceMode(newStatus);
        
        if (newStatus) {
            await ctx.replyWithMarkdown('ðŸ”’ *ØªÙ… Ù‚ÙÙ„ Ø§Ù„Ø¨ÙˆØª Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†*', getAdminMainKeyboard());
        } else {
            await ctx.replyWithMarkdown('ðŸ”“ *ØªÙ… ÙØªØ­ Ø§Ù„Ø¨ÙˆØª Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†*', getAdminMainKeyboard());
        }
    } catch (error) {
        console.error('Toggle maintenance error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØºÙŠÙŠØ± Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª', getAdminMainKeyboard());
    }
}

async function handleAdminStats(ctx) {
    try {
        const users = await dbManager.getAllUsers();
        const payments = await dbManager.getAllPayments();
        const pendingPayments = payments.filter(p => p.status === 'pending');
        
        const activeUsers = users.filter(u => u.subscription_status === 'active');
        const freeUsers = users.filter(u => u.subscription_status === 'free');
        
        const totalPredictions = users.reduce((sum, user) => sum + (user.total_predictions || 0), 0);
        const totalProfit = users.reduce((sum, user) => sum + (user.total_profit || 0), 0);
        
        const statsMessage = `
ðŸ“Š *Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù†Ø¸Ø§Ù…*

ðŸ‘¥ *Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†:*
â€¢ Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: ${users.length}
â€¢ Ù†Ø´Ø·ÙŠÙ†: ${activeUsers.length}
â€¢ Ù…Ø¬Ø§Ù†ÙŠÙ†: ${freeUsers.length}

ðŸ’° *Ø§Ù„Ù…Ø¯ÙÙˆØ¹Ø§Øª:*
â€¢ Ø§Ù„Ù…Ø¹Ù„Ù‚Ø©: ${pendingPayments.length}
â€¢ Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: ${payments.length}

ðŸ“ˆ *Ø§Ù„Ù†Ø´Ø§Ø·:*
â€¢ Ø§Ù„ØªÙˆÙ‚Ø¹Ø§Øª: ${totalPredictions}
â€¢ Ø§Ù„Ø£Ø±Ø¨Ø§Ø­: ${totalProfit}$

ðŸ”§ *Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª:* ${dbManager.isMaintenanceMode() ? 'ðŸ”’ Ù…Ù‚ÙÙ„' : 'ðŸ”“ Ù…ÙØªÙˆØ­'}
        `;
        
        await ctx.replyWithMarkdown(statsMessage, getAdminMainKeyboard());
    } catch (error) {
        console.error('Admin stats error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª', getAdminMainKeyboard());
    }
}

async function handleAdminUsersList(ctx) {
    try {
        const users = await dbManager.getAllUsers();
        
        let message = `ðŸ“‹ *Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† (${users.length})*\n\n`;
        
        users.slice(0, 10).forEach((user, index) => {
            const status = user.subscription_status === 'active' ? 'âœ…' : 'ðŸ†“';
            message += `${index + 1}. ${user.username || 'Ø¨Ø¯ÙˆÙ† Ø§Ø³Ù…'} ${status}\n`;
            message += `   ðŸ‘¤ ${user.user_id} | ðŸ” ${user.onexbet}\n\n`;
        });
        
        if (users.length > 10) {
            message += `... Ùˆ ${users.length - 10} Ù…Ø³ØªØ®Ø¯Ù… Ø¢Ø®Ø±`;
        }
        
        await ctx.replyWithMarkdown(message, getAdminUsersKeyboard());
    } catch (error) {
        console.error('Admin users list error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†', getAdminUsersKeyboard());
    }
}

async function handleAdminActiveUsers(ctx) {
    try {
        const users = await dbManager.getAllUsers();
        const activeUsers = users.filter(u => u.subscription_status === 'active');
        
        let message = `âœ… *Ø§Ù„Ù…Ø´ØªØ±ÙƒÙŠÙ† Ø§Ù„Ù†Ø´Ø·ÙŠÙ† (${activeUsers.length})*\n\n`;
        
        activeUsers.slice(0, 10).forEach((user, index) => {
            const remainingDays = calculateRemainingDays(user.subscription_end_date);
            message += `${index + 1}. ${user.username || 'Ø¨Ø¯ÙˆÙ† Ø§Ø³Ù…'}\n`;
            message += `   ðŸ“¦ ${getSubscriptionDisplayName(user.subscription_type)} | â³ ${remainingDays} ÙŠÙˆÙ…\n\n`;
        });
        
        await ctx.replyWithMarkdown(message, getAdminUsersKeyboard());
    } catch (error) {
        console.error('Admin active users error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø´ØªØ±ÙƒÙŠÙ† Ø§Ù„Ù†Ø´Ø·ÙŠÙ†', getAdminUsersKeyboard());
    }
}

async function handleAdminFreeUsers(ctx) {
    try {
        const users = await dbManager.getAllUsers();
        const freeUsers = users.filter(u => u.subscription_status === 'free');
        
        let message = `ðŸ†“ *Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠÙ† (${freeUsers.length})*\n\n`;
        
        freeUsers.slice(0, 10).forEach((user, index) => {
            message += `${index + 1}. ${user.username || 'Ø¨Ø¯ÙˆÙ† Ø§Ø³Ù…'}\n`;
            message += `   ðŸ†“ Ù…Ø­Ø§ÙˆÙ„Ø§Øª: ${user.free_attempts}\n\n`;
        });
        
        await ctx.replyWithMarkdown(message, getAdminUsersKeyboard());
    } catch (error) {
        console.error('Admin free users error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠÙ†', getAdminUsersKeyboard());
    }
}

async function handleAdminUsersStats(ctx) {
    try {
        const users = await dbManager.getAllUsers();
        const activeUsers = users.filter(u => u.subscription_status === 'active');
        const freeUsers = users.filter(u => u.subscription_status === 'free');
        
        const totalPredictions = users.reduce((sum, user) => sum + (user.total_predictions || 0), 0);
        const totalProfit = users.reduce((sum, user) => sum + (user.total_profit || 0), 0);
        const totalBets = users.reduce((sum, user) => sum + (user.total_bets || 0), 0);
        
        const message = `
ðŸ“ˆ *Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†*

ðŸ‘¥ Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: ${users.length}
âœ… Ù†Ø´Ø·ÙŠÙ†: ${activeUsers.length}
ðŸ†“ Ù…Ø¬Ø§Ù†ÙŠÙ†: ${freeUsers.length}

ðŸ“Š Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ØªÙˆÙ‚Ø¹Ø§Øª: ${totalPredictions}
ðŸ’° Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø±Ù‡Ø§Ù†Ø§Øª: ${totalBets}$
ðŸ’µ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø£Ø±Ø¨Ø§Ø­: ${totalProfit}$
        `;
        
        await ctx.replyWithMarkdown(message, getAdminUsersKeyboard());
    } catch (error) {
        console.error('Admin users stats error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†', getAdminUsersKeyboard());
    }
}

async function handleAdminPendingPayments(ctx) {
    try {
        const payments = await dbManager.getPendingPayments();
        
        if (payments.length === 0) {
            await ctx.replyWithMarkdown('âœ… *Ù„Ø§ ØªÙˆØ¬Ø¯ Ø·Ù„Ø¨Ø§Øª Ø¯ÙØ¹ Ù…Ø¹Ù„Ù‚Ø©*', getAdminPaymentsKeyboard());
            return;
        }
        
        for (const payment of payments) {
            await ctx.replyWithPhoto(
                payment.screenshot_url,
                {
                    caption: `ðŸ“¥ *Ø·Ù„Ø¨ Ø¯ÙØ¹ Ù…Ø¹Ù„Ù‚ #${payment.id}*\n\n` +
                    `ðŸ‘¤ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: ${payment.username}\n` +
                    `ðŸ” Ø§Ù„Ø­Ø³Ø§Ø¨: ${payment.onexbet}\n` +
                    `ðŸ’° Ø§Ù„Ù…Ø¨Ù„Øº: ${payment.amount}$\n` +
                    `ðŸ“¦ Ø§Ù„Ø¨Ø§Ù‚Ø©: ${getSubscriptionDisplayName(payment.subscription_type)}\n` +
                    `ðŸ’³ Ø§Ù„Ù†Ø¸Ø§Ù…: ${payment.payment_system === 'binance' ? 'Ø¨Ø§ÙŠÙ†Ø§Ù†Ø³' : 'ØªØ­ÙˆÙŠÙ„ Ø¨Ù†ÙƒÙŠ'}\n` +
                    `ðŸ“… Ø§Ù„ØªØ§Ø±ÙŠØ®: ${new Date(payment.timestamp).toLocaleString('ar-EG')}`,
                    reply_markup: {
                        inline_keyboard: [
                            [
                                { text: 'âœ… Ù‚Ø¨ÙˆÙ„ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ', callback_data: `accept_${payment.id}` },
                                { text: 'âŒ Ø±ÙØ¶ Ø§Ù„Ø·Ù„Ø¨', callback_data: `reject_${payment.id}` }
                            ]
                        ]
                    }
                }
            );
        }
    } catch (error) {
        console.error('Admin pending payments error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…Ø¹Ù„Ù‚Ø©', getAdminPaymentsKeyboard());
    }
}

async function handleAdminAcceptedPayments(ctx) {
    try {
        const payments = await dbManager.getAllPayments();
        const acceptedPayments = payments.filter(p => p.status === 'accepted');
        
        if (acceptedPayments.length === 0) {
            await ctx.replyWithMarkdown('âœ… *Ù„Ø§ ØªÙˆØ¬Ø¯ Ø·Ù„Ø¨Ø§Øª Ø¯ÙØ¹ Ù…Ù‚Ø¨ÙˆÙ„Ø©*', getAdminPaymentsKeyboard());
            return;
        }
        
        let message = `âœ… *Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…Ù‚Ø¨ÙˆÙ„Ø© (${acceptedPayments.length})*\n\n`;
        
        acceptedPayments.slice(0, 10).forEach((payment, index) => {
            message += `${index + 1}. ${payment.username} | ${payment.onexbet}\n`;
            message += `   ðŸ’° ${payment.amount}$ | ðŸ“¦ ${getSubscriptionDisplayName(payment.subscription_type)} | ðŸ’³ ${payment.payment_system === 'binance' ? 'Ø¨Ø§ÙŠÙ†Ø§Ù†Ø³' : 'Ø¨Ù†ÙƒÙŠ'}\n\n`;
        });
        
        await ctx.replyWithMarkdown(message, getAdminPaymentsKeyboard());
    } catch (error) {
        console.error('Admin accepted payments error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…Ù‚Ø¨ÙˆÙ„Ø©', getAdminPaymentsKeyboard());
    }
}

async function handleAdminRejectedPayments(ctx) {
    try {
        const payments = await dbManager.getAllPayments();
        const rejectedPayments = payments.filter(p => p.status === 'rejected');
        
        if (rejectedPayments.length === 0) {
            await ctx.replyWithMarkdown('âœ… *Ù„Ø§ ØªÙˆØ¬Ø¯ Ø·Ù„Ø¨Ø§Øª Ø¯ÙØ¹ Ù…Ø±ÙÙˆØ¶Ø©*', getAdminPaymentsKeyboard());
            return;
        }
        
        let message = `âŒ *Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…Ø±ÙÙˆØ¶Ø© (${rejectedPayments.length})*\n\n`;
        
        rejectedPayments.slice(0, 10).forEach((payment, index) => {
            message += `${index + 1}. ${payment.username} | ${payment.onexbet}\n`;
            message += `   ðŸ’° ${payment.amount}$ | ðŸ“¦ ${getSubscriptionDisplayName(payment.subscription_type)} | ðŸ’³ ${payment.payment_system === 'binance' ? 'Ø¨Ø§ÙŠÙ†Ø§Ù†Ø³' : 'Ø¨Ù†ÙƒÙŠ'}\n\n`;
        });
        
        await ctx.replyWithMarkdown(message, getAdminPaymentsKeyboard());
    } catch (error) {
        console.error('Admin rejected payments error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…Ø±ÙÙˆØ¶Ø©', getAdminPaymentsKeyboard());
    }
}

async function handleAdminAllPayments(ctx) {
    try {
        const payments = await dbManager.getAllPayments();
        
        if (payments.length === 0) {
            await ctx.replyWithMarkdown('âœ… *Ù„Ø§ ØªÙˆØ¬Ø¯ Ø·Ù„Ø¨Ø§Øª Ø¯ÙØ¹*', getAdminPaymentsKeyboard());
            return;
        }
        
        const pending = payments.filter(p => p.status === 'pending').length;
        const accepted = payments.filter(p => p.status === 'accepted').length;
        const rejected = payments.filter(p => p.status === 'rejected').length;
        const binancePayments = payments.filter(p => p.payment_system === 'binance').length;
        const bankPayments = payments.filter(p => p.payment_system === 'bank').length;
        
        const message = `
ðŸ“‹ *Ø¬Ù…ÙŠØ¹ Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ø¯ÙØ¹*

ðŸ“¥ Ø§Ù„Ù…Ø¹Ù„Ù‚Ø©: ${pending}
âœ… Ø§Ù„Ù…Ù‚Ø¨ÙˆÙ„Ø©: ${accepted}
âŒ Ø§Ù„Ù…Ø±ÙÙˆØ¶Ø©: ${rejected}
ðŸ’³ Ø¨Ø§ÙŠÙ†Ø§Ù†Ø³: ${binancePayments}
ðŸ¦ Ø¨Ù†ÙƒÙŠ: ${bankPayments}
ðŸ’° Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: ${payments.length}
        `;
        
        await ctx.replyWithMarkdown(message, getAdminPaymentsKeyboard());
    } catch (error) {
        console.error('Admin all payments error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø·Ù„Ø¨Ø§Øª', getAdminPaymentsKeyboard());
    }
}

// ðŸ†• ðŸ”§ ADMIN PAYMENT SYSTEM - UPDATED FOR DUAL PAYMENT

async function handleAdminPriceAndPaymentSettings(ctx) {
    try {
        await ctx.replyWithMarkdown(
            'ðŸ’° *ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø£Ø³Ø¹Ø§Ø± ÙˆÙ…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¯ÙØ¹*\n\n' +
            'ðŸ“ Ø§Ø®ØªØ± Ù†Ø¸Ø§Ù… Ø§Ù„Ø¯ÙØ¹ Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ ØªØ¹Ø¯ÙŠÙ„Ù‡:',
            getAdminPaymentSystemKeyboard()
        );
        ctx.session.adminStep = 'select_payment_system';
    } catch (error) {
        console.error('Admin price and payment settings error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¨Ø¯Ø¡ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„', getAdminSettingsKeyboard());
    }
}

// ðŸ†• Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ø®ØªÙŠØ§Ø± Ù†Ø¸Ø§Ù… Ø§Ù„Ø¯ÙØ¹ ÙÙŠ Ø§Ù„Ø¥Ø¯Ù…Ù†
async function handleAdminSelectPaymentSystem(ctx, text) {
    try {
        if (text === 'ðŸ”™ Ø±Ø¬ÙˆØ¹') {
            ctx.session.adminStep = 'settings';
            await ctx.replyWithMarkdown('ðŸ”™ *Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª*', getAdminSettingsKeyboard());
            return;
        }

        const paymentSystemMap = {
            'ðŸ’³ Ù†Ø¸Ø§Ù… Ø¨Ø§ÙŠÙ†Ø§Ù†Ø³': 'binance',
            'ðŸ¦ Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¨Ù†ÙƒÙŠ': 'bank'
        };

        const paymentSystem = paymentSystemMap[text];
        if (!paymentSystem) {
            await ctx.replyWithMarkdown('âŒ *Ø§Ø®ØªÙŠØ§Ø± ØºÙŠØ± ØµØ­ÙŠØ­*', getAdminPaymentSystemKeyboard());
            return;
        }

        ctx.session.adminPaymentSystem = paymentSystem;
        ctx.session.adminStep = 'select_subscription_edit';

        await ctx.replyWithMarkdown(
            `ðŸ”§ *ØªØ¹Ø¯ÙŠÙ„ ${text}*\n\n` +
            'ðŸ“ Ø§Ø®ØªØ± Ù†ÙˆØ¹ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ ØªØ¹Ø¯ÙŠÙ„Ù‡:',
            getAdminPaymentTypesKeyboard()
        );

    } catch (error) {
        console.error('Admin select payment system error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£', getAdminSettingsKeyboard());
    }
}

// ðŸ†• ØªØ­Ø¯ÙŠØ« Ù…Ø¹Ø§Ù„Ø¬Ø© ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø£Ø³Ø¹Ø§Ø± ÙˆØ§Ù„Ø¯ÙØ¹ Ù„Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ø²Ø¯ÙˆØ¬
async function handleAdminSelectSubscriptionEdit(ctx, text) {
    try {
        const subscriptionTypeMap = {
            'ðŸ’° Ø£Ø³Ø¨ÙˆØ¹ÙŠ': 'week',
            'ðŸ’° Ø´Ù‡Ø±ÙŠ': 'month', 
            'ðŸ’° 3 Ø£Ø´Ù‡Ø±': 'three_months',
            'ðŸ’° Ø³Ù†ÙˆÙŠ': 'year'
        };

        if (text === 'ðŸ”™ Ø±Ø¬ÙˆØ¹') {
            ctx.session.adminStep = 'select_payment_system';
            await ctx.replyWithMarkdown('ðŸ”™ *Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ø§Ø®ØªÙŠØ§Ø± Ù†Ø¸Ø§Ù… Ø§Ù„Ø¯ÙØ¹*', getAdminPaymentSystemKeyboard());
            return;
        }

        const subscriptionType = subscriptionTypeMap[text];
        if (!subscriptionType) {
            await ctx.replyWithMarkdown('âŒ *Ø§Ø®ØªÙŠØ§Ø± ØºÙŠØ± ØµØ­ÙŠØ­*', getAdminPaymentTypesKeyboard());
            return;
        }

        ctx.session.editingSubscriptionType = subscriptionType;

        const paymentSystem = ctx.session.adminPaymentSystem;

        if (paymentSystem === 'binance') {
            ctx.session.adminStep = 'edit_price_and_payment';
            const settings = await dbManager.getSettings();
            
            // ðŸ”§ FIX: Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ø£Ø³Ø¹Ø§Ø± ÙˆØ§Ù„Ø±ÙˆØ§Ø¨Ø·
            const currentPrice = settings.prices?.binance?.[subscriptionType] || CONFIG.SUBSCRIPTION_PRICES.binance[subscriptionType];
            const currentLink = settings.payment_links?.binance?.[subscriptionType] || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯';

            await ctx.replyWithMarkdown(
                `ðŸ”§ *ØªØ¹Ø¯ÙŠÙ„ ${text} - Ø¨Ø§ÙŠÙ†Ø§Ù†Ø³*\n\n` +
                `ðŸ’° Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ: ${currentPrice}$\n` +
                `ðŸ“Ž Ø±Ø§Ø¨Ø·/ØµÙˆØ±Ø© Ø§Ù„Ø¯ÙØ¹ Ø§Ù„Ø­Ø§Ù„ÙŠ: ${currentLink}\n\n` +
                `ðŸ“ *Ø§Ù„Ø¢Ù† ÙŠÙ…ÙƒÙ†Ùƒ:*\n` +
                `â€¢ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯ (Ù…Ø«Ø§Ù„: 15)\n` +
                `â€¢ Ø£Ùˆ Ø¥Ø±Ø³Ø§Ù„ Ø±Ø§Ø¨Ø· Ø¯ÙØ¹ Ø¬Ø¯ÙŠØ¯\n` +
                `â€¢ Ø£Ùˆ Ø¥Ø±Ø³Ø§Ù„ ØµÙˆØ±Ø© QR\n` +
                `â€¢ Ø£Ùˆ ÙƒØªØ§Ø¨Ø© "Ø¥Ù„ØºØ§Ø¡" Ù„Ù„Ø±Ø¬ÙˆØ¹\n\n` +
                `ðŸ’¡ *Ø£Ø±Ø³Ù„ Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ø£ÙˆÙ„Ø§Ù‹:*`
            );
        } 
        else if (paymentSystem === 'bank') {
            // ðŸ†• Ù†Ø¸Ø§Ù… ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø¨Ù†ÙƒÙŠ Ø§Ù„Ù…Ù†Ø¸Ù…
            ctx.session.bankEditData = {
                subscriptionType: subscriptionType,
                step: 'price'
            };
            ctx.session.adminStep = 'edit_bank_price';
            
            const settings = await dbManager.getSettings();
            
            // ðŸ”§ FIX: Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ø£Ø³Ø¹Ø§Ø± ÙˆØ§Ù„ØªÙØ§ØµÙŠÙ„
            const currentPrice = settings.prices?.bank?.[subscriptionType] || CONFIG.SUBSCRIPTION_PRICES.bank[subscriptionType];
            const currentBankDetails = settings.payment_links?.bank?.[subscriptionType] || CONFIG.PAYMENT_LINKS.bank[subscriptionType];

            await ctx.replyWithMarkdown(
                `ðŸ”§ *ØªØ¹Ø¯ÙŠÙ„ ${text} - ØªØ­ÙˆÙŠÙ„ Ø¨Ù†ÙƒÙŠ*\n\n` +
                `ðŸ’° *Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ:* ${currentPrice}$\n` +
                `ðŸ’³ *Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø­Ø§Ù„ÙŠ:* ${currentBankDetails.account}\n` +
                `ðŸ“‹ *Ø§Ù„ÙˆØµÙ Ø§Ù„Ø­Ø§Ù„ÙŠ:*\n${currentBankDetails.description}\n\n` +
                `ðŸ“ *Ø§Ù„Ø¢Ù† Ø£Ø±Ø³Ù„ Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ù„Ù„Ø¨Ø§Ù‚Ø© (Ø¨Ø§Ù„Ø¯ÙˆÙ„Ø§Ø±):*`
            );
        }

    } catch (error) {
        console.error('Admin select subscription edit error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£', getAdminSettingsKeyboard());
    }
}

// ðŸ†• Ù…Ø¹Ø§Ù„Ø¬Ø© ØªØ¹Ø¯ÙŠÙ„ Ø³Ø¹Ø± Ø§Ù„Ø¨Ù†ÙƒÙŠ
async function handleAdminEditBankPrice(ctx, text) {
    try {
        if (text === 'Ø¥Ù„ØºØ§Ø¡') {
            ctx.session.adminStep = 'settings';
            ctx.session.editingSubscriptionType = null;
            ctx.session.adminPaymentSystem = null;
            ctx.session.bankEditData = {};
            await ctx.replyWithMarkdown('ðŸ”™ *ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡*', getAdminSettingsKeyboard());
            return;
        }

        if (!isNaN(text) && parseFloat(text) > 0) {
            const priceNum = parseFloat(text);
            const subscriptionType = ctx.session.bankEditData.subscriptionType;
            
            // Ø­ÙØ¸ Ø§Ù„Ø³Ø¹Ø± Ù…Ø¤Ù‚ØªØ§Ù‹
            ctx.session.bankEditData.price = priceNum;
            ctx.session.bankEditData.step = 'account';
            ctx.session.adminStep = 'edit_bank_account';

            await ctx.replyWithMarkdown(
                `âœ… *ØªÙ… Ø­ÙØ¸ Ø§Ù„Ø³Ø¹Ø±:* ${priceNum}$\n\n` +
                `ðŸ“ *Ø§Ù„Ø¢Ù† Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¨Ù†ÙƒÙŠ Ø§Ù„Ø¬Ø¯ÙŠØ¯:*`
            );
        } else {
            await ctx.replyWithMarkdown('âŒ *Ø¥Ø¯Ø®Ø§Ù„ ØºÙŠØ± ØµØ­ÙŠØ­!*\n\nÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø³Ø¹Ø± ØµØ­ÙŠØ­ (Ù…Ø«Ø§Ù„: 15)');
        }

    } catch (error) {
        console.error('Admin edit bank price error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„');
    }
}

// ðŸ†• Ù…Ø¹Ø§Ù„Ø¬Ø© ØªØ¹Ø¯ÙŠÙ„ Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¨Ù†ÙƒÙŠ
async function handleAdminEditBankAccount(ctx, text) {
    try {
        if (text === 'Ø¥Ù„ØºØ§Ø¡') {
            ctx.session.adminStep = 'settings';
            ctx.session.editingSubscriptionType = null;
            ctx.session.adminPaymentSystem = null;
            ctx.session.bankEditData = {};
            await ctx.replyWithMarkdown('ðŸ”™ *ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡*', getAdminSettingsKeyboard());
            return;
        }

        if (text.length > 5) {
            const subscriptionType = ctx.session.bankEditData.subscriptionType;
            
            // Ø­ÙØ¸ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨ Ù…Ø¤Ù‚ØªØ§Ù‹
            ctx.session.bankEditData.account = text;
            ctx.session.bankEditData.step = 'image';
            ctx.session.adminStep = 'edit_bank_image';

            await ctx.replyWithMarkdown(
                `âœ… *ØªÙ… Ø­ÙØ¸ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨:* ${text}\n\n` +
                `ðŸ–¼ï¸ *Ø§Ù„Ø¢Ù† Ø£Ø±Ø³Ù„ ØµÙˆØ±Ø© Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¨Ù†ÙƒÙŠ:*\n\n` +
                `ðŸ’¡ *Ù…Ù„Ø§Ø­Ø¸Ø©:* Ù‡Ø°Ù‡ Ø§Ù„ØµÙˆØ±Ø© Ø³ØªØ¸Ù‡Ø± Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø¹Ù†Ø¯ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø¨Ø§Ù‚Ø©`
            );
        } else {
            await ctx.replyWithMarkdown('âŒ *Ø¥Ø¯Ø®Ø§Ù„ ØºÙŠØ± ØµØ­ÙŠØ­!*\n\nÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ Ø¨Ù†ÙƒÙŠ ØµØ­ÙŠØ­');
        }

    } catch (error) {
        console.error('Admin edit bank account error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„');
    }
}

// ðŸ†• Ù…Ø¹Ø§Ù„Ø¬Ø© Ø±ÙØ¹ ØµÙˆØ±Ø© Ø§Ù„Ø¨Ù†Ùƒ Ù…Ù† Ø§Ù„Ø¥Ø¯Ù…Ù†
async function handleAdminBankImageUpload(ctx, userId) {
    try {
        const subscriptionType = ctx.session.bankEditData.subscriptionType;
        const price = ctx.session.bankEditData.price;
        const account = ctx.session.bankEditData.account;
        
        if (!subscriptionType) {
            await ctx.replyWithMarkdown('âŒ Ù„Ù… ÙŠØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ù†ÙˆØ¹ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ', getAdminSettingsKeyboard());
            return;
        }

        const photo = ctx.message.photo[ctx.message.photo.length - 1];
        const fileLink = await bot.telegram.getFileLink(photo.file_id);
        const imageUrl = fileLink.href;

        // Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø© Ø¥Ù„Ù‰ imgbb
        const uploadResult = await imgbbUploader.uploadImageFromUrl(imageUrl);
        
        if (!uploadResult.success) {
            await ctx.replyWithMarkdown('âŒ ÙØ´Ù„ ÙÙŠ Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø©ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰');
            return;
        }

        const settings = await dbManager.getSettings();
        
        // ðŸ”§ FIX: Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª
        if (!settings.prices) settings.prices = {};
        if (!settings.prices.bank) settings.prices.bank = {};
        if (!settings.payment_links) settings.payment_links = {};
        if (!settings.payment_links.bank) settings.payment_links.bank = {};
        
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø³Ø¹Ø±
        settings.prices.bank[subscriptionType] = price;
        
        // ðŸ†• Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ÙˆØµÙ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
        const description = generateBankDescription(subscriptionType, price, account);
        
        // ØªØ­Ø¯ÙŠØ« Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¨Ù†Ùƒ
        settings.payment_links.bank[subscriptionType] = {
            account: account,
            image: uploadResult.url,
            description: description
        };
        
        await dbManager.updateSettings(settings);

        await ctx.replyWithMarkdown(
            `ðŸŽ‰ *ØªÙ… Ø§Ù„ØªØ­Ø¯ÙŠØ« Ø¨Ù†Ø¬Ø§Ø­!*\n\n` +
            `ðŸ“¦ *${getSubscriptionDisplayName(subscriptionType)} - ØªØ­ÙˆÙŠÙ„ Ø¨Ù†ÙƒÙŠ*\n\n` +
            `ðŸ’° Ø§Ù„Ø³Ø¹Ø±: ${price}$\n` +
            `ðŸ’³ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨: ${account}\n` +
            `ðŸ–¼ï¸ ØªÙ… Ø±ÙØ¹ ØµÙˆØ±Ø© Ø§Ù„Ø­Ø³Ø§Ø¨\n` +
            `ðŸ“‹ ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ÙˆØµÙ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹\n\n` +
            `âœ… *ØªÙ… Ø­ÙØ¸ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù…*`,
            getAdminSettingsKeyboard()
        );

        // ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø¬Ù„Ø³Ø©
        ctx.session.adminStep = 'settings';
        ctx.session.editingSubscriptionType = null;
        ctx.session.adminPaymentSystem = null;
        ctx.session.bankEditData = {};

    } catch (error) {
        console.error('Admin bank image upload error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø©', getAdminSettingsKeyboard());
    }
}

// ðŸ†• Ù…Ø¹Ø§Ù„Ø¬Ø© Ø±ÙØ¹ ØµÙˆØ±Ø© Ø§Ù„Ø¯ÙØ¹ Ù…Ù† Ø§Ù„Ø¥Ø¯Ù…Ù† (Ø¨Ø§ÙŠÙ†Ø§Ù†Ø³)
async function handleAdminPaymentImageUpload(ctx, userId) {
    try {
        const subscriptionType = ctx.session.editingSubscriptionType;
        const paymentSystem = ctx.session.adminPaymentSystem;
        
        if (!subscriptionType || paymentSystem !== 'binance') {
            await ctx.replyWithMarkdown('âŒ Ù„Ù… ÙŠØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ù†ÙˆØ¹ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø£Ùˆ Ù„ÙŠØ³ Ù†Ø¸Ø§Ù… Ø¨Ø§ÙŠÙ†Ø§Ù†Ø³', getAdminSettingsKeyboard());
            return;
        }

        const photo = ctx.message.photo[ctx.message.photo.length - 1];
        const fileLink = await bot.telegram.getFileLink(photo.file_id);
        const imageUrl = fileLink.href;

        // Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø© Ø¥Ù„Ù‰ imgbb
        const uploadResult = await imgbbUploader.uploadImageFromUrl(imageUrl);
        
        if (!uploadResult.success) {
            await ctx.replyWithMarkdown('âŒ ÙØ´Ù„ ÙÙŠ Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø©ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰');
            return;
        }

        const settings = await dbManager.getSettings();
        
        // ðŸ”§ FIX: Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª
        if (!settings.payment_links) settings.payment_links = {};
        if (!settings.payment_links.binance) settings.payment_links.binance = {};
        
        settings.payment_links.binance[subscriptionType] = uploadResult.url;
        await dbManager.updateSettings(settings);

        await ctx.replyWithMarkdown(
            `âœ… *ØªÙ… Ø§Ù„ØªØ­Ø¯ÙŠØ« Ø¨Ù†Ø¬Ø§Ø­!*\n\n` +
            `ðŸ“¦ ${getSubscriptionDisplayName(subscriptionType)} - Ø¨Ø§ÙŠÙ†Ø§Ù†Ø³\n` +
            `ðŸ’° Ø§Ù„Ø³Ø¹Ø±: ${settings.prices.binance[subscriptionType]}$\n` +
            `ðŸ–¼ï¸ ØªÙ… ØªØ­Ø¯ÙŠØ« ØµÙˆØ±Ø© Ø§Ù„Ø¯ÙØ¹\n\n` +
            `ðŸ”„ ØªÙ… Ø­ÙØ¸ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù…`,
            getAdminSettingsKeyboard()
        );

        ctx.session.adminStep = 'settings';
        ctx.session.editingSubscriptionType = null;
        ctx.session.adminPaymentSystem = null;
    } catch (error) {
        console.error('Admin payment image upload error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø©', getAdminSettingsKeyboard());
    }
}

// ðŸ› ï¸ Ø§Ù„Ø¥ØµÙ„Ø§Ø­ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ: Ù…Ø¹Ø§Ù„Ø¬Ø© ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø£Ø³Ø¹Ø§Ø± ÙˆØ§Ù„Ø¯ÙØ¹ (Ø¨Ø§ÙŠÙ†Ø§Ù†Ø³) - FIXED FOR three_months
async function handleAdminEditPriceAndPayment(ctx, text) {
    try {
        if (text === 'Ø¥Ù„ØºØ§Ø¡') {
            ctx.session.adminStep = 'settings';
            ctx.session.editingSubscriptionType = null;
            ctx.session.adminPaymentSystem = null;
            await ctx.replyWithMarkdown('ðŸ”™ *ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡*', getAdminSettingsKeyboard());
            return;
        }

        const subscriptionType = ctx.session.editingSubscriptionType;
        const paymentSystem = ctx.session.adminPaymentSystem;
        
        if (!subscriptionType || !paymentSystem) {
            await ctx.replyWithMarkdown('âŒ Ù„Ù… ÙŠØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ù†ÙˆØ¹ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø£Ùˆ Ù†Ø¸Ø§Ù… Ø§Ù„Ø¯ÙØ¹', getAdminSettingsKeyboard());
            return;
        }

        const settings = await dbManager.getSettings();

        if (paymentSystem === 'binance') {
            // Ù†Ø¸Ø§Ù… Ø¨Ø§ÙŠÙ†Ø§Ù†Ø³
            if (!isNaN(text) && parseFloat(text) > 0) {
                const priceNum = parseFloat(text);
                
                // ðŸ”§ FIX: Ensure the prices object exists
                if (!settings.prices) settings.prices = {};
                if (!settings.prices.binance) settings.prices.binance = {};
                
                settings.prices.binance[subscriptionType] = priceNum;
                await dbManager.updateSettings(settings);

                await ctx.replyWithMarkdown(
                    `âœ… *ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø³Ø¹Ø± Ø¨Ù†Ø¬Ø§Ø­*\n\n` +
                    `ðŸ’° ${getSubscriptionDisplayName(subscriptionType)}: ${priceNum}$\n\n` +
                    `ðŸ“ *Ø§Ù„Ø¢Ù† Ø£Ø±Ø³Ù„ Ø±Ø§Ø¨Ø· Ø§Ù„Ø¯ÙØ¹ Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ø£Ùˆ ØµÙˆØ±Ø© QR:*`
                );
            }
            else if (text.startsWith('http') || text.startsWith('https://i.ibb.co')) {
                // ðŸ”§ FIX: Ensure the payment_links object exists
                if (!settings.payment_links) settings.payment_links = {};
                if (!settings.payment_links.binance) settings.payment_links.binance = {};
                
                settings.payment_links.binance[subscriptionType] = text;
                await dbManager.updateSettings(settings);

                await ctx.replyWithMarkdown(
                    `âœ… *ØªÙ… Ø§Ù„ØªØ­Ø¯ÙŠØ« Ø¨Ù†Ø¬Ø§Ø­!*\n\n` +
                    `ðŸ“¦ ${getSubscriptionDisplayName(subscriptionType)} - Ø¨Ø§ÙŠÙ†Ø§Ù†Ø³\n` +
                    `ðŸ’° Ø§Ù„Ø³Ø¹Ø±: ${settings.prices.binance[subscriptionType]}$\n` +
                    `ðŸ“Ž ØªÙ… Ø­ÙØ¸ ${text.startsWith('https://i.ibb.co') ? 'ØµÙˆØ±Ø© Ø§Ù„Ø¯ÙØ¹' : 'Ø±Ø§Ø¨Ø· Ø§Ù„Ø¯ÙØ¹'} Ø¨Ù†Ø¬Ø§Ø­\n\n` +
                    `ðŸ”„ ØªÙ… Ø­ÙØ¸ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù…`,
                    getAdminSettingsKeyboard()
                );

                ctx.session.adminStep = 'settings';
                ctx.session.editingSubscriptionType = null;
                ctx.session.adminPaymentSystem = null;
            } else {
                await ctx.replyWithMarkdown('âŒ *Ø¥Ø¯Ø®Ø§Ù„ ØºÙŠØ± ØµØ­ÙŠØ­!*\n\nÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø³Ø¹Ø± ØµØ­ÙŠØ­ Ø£Ùˆ Ø±Ø§Ø¨Ø· ÙŠØ¨Ø¯Ø£ Ø¨Ù€ http Ø£Ùˆ https://i.ibb.co');
            }
        }

    } catch (error) {
        console.error('Admin edit price and payment error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„: ' + error.message);
    }
}

// ðŸ†• ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø© Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ø²Ø¯ÙˆØ¬
async function handleAdminGeneralSettings(ctx) {
    try {
        const settings = await dbManager.getSettings();
        
        // ðŸ”§ FIX: Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª
        const binancePrices = settings.prices?.binance || CONFIG.SUBSCRIPTION_PRICES.binance;
        const bankPrices = settings.prices?.bank || CONFIG.SUBSCRIPTION_PRICES.bank;
        const binanceLinks = settings.payment_links?.binance || CONFIG.PAYMENT_LINKS.binance;
        const bankLinks = settings.payment_links?.bank || CONFIG.PAYMENT_LINKS.bank;
        
        const generalMessage = `
âš™ï¸ *Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø©*

ðŸ”§ Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª: ${settings.maintenance_mode ? 'ðŸ”’ Ù…Ù‚ÙÙ„' : 'ðŸ”“ Ù…ÙØªÙˆØ­'}
ðŸ•’ Ø¢Ø®Ø± ØªØ­Ø¯ÙŠØ«: ${new Date(settings.updated_at).toLocaleString('ar-EG')}

ðŸ’³ *Ø£Ø³Ø¹Ø§Ø± Ø¨Ø§ÙŠÙ†Ø§Ù†Ø³:*
â€¢ Ø£Ø³Ø¨ÙˆØ¹ÙŠ: ${binancePrices.week}$
â€¢ Ø´Ù‡Ø±ÙŠ: ${binancePrices.month}$
â€¢ 3 Ø£Ø´Ù‡Ø±: ${binancePrices.three_months}$ 
â€¢ Ø³Ù†ÙˆÙŠ: ${binancePrices.year}$

ðŸ¦ *Ø£Ø³Ø¹Ø§Ø± Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¨Ù†ÙƒÙŠ:*
â€¢ Ø£Ø³Ø¨ÙˆØ¹ÙŠ: ${bankPrices.week}$
â€¢ Ø´Ù‡Ø±ÙŠ: ${bankPrices.month}$
â€¢ 3 Ø£Ø´Ù‡Ø±: ${bankPrices.three_months}$ 
â€¢ Ø³Ù†ÙˆÙŠ: ${bankPrices.year}$

ðŸ”— *Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¨Ø§ÙŠÙ†Ø§Ù†Ø³:*
â€¢ Ø£Ø³Ø¨ÙˆØ¹ÙŠ: ${binanceLinks.week.startsWith('https://i.ibb.co') ? '[ØµÙˆØ±Ø©]' : binanceLinks.week}
â€¢ Ø´Ù‡Ø±ÙŠ: ${binanceLinks.month.startsWith('https://i.ibb.co') ? '[ØµÙˆØ±Ø©]' : binanceLinks.month}
â€¢ 3 Ø£Ø´Ù‡Ø±: ${binanceLinks.three_months.startsWith('https://i.ibb.co') ? '[ØµÙˆØ±Ø©]' : binanceLinks.three_months}
â€¢ Ø³Ù†ÙˆÙŠ: ${binanceLinks.year.startsWith('https://i.ibb.co') ? '[ØµÙˆØ±Ø©]' : binanceLinks.year}

ðŸ’³ *Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¨Ù†Ùƒ:*
â€¢ Ø£Ø³Ø¨ÙˆØ¹ÙŠ: ${bankLinks.week?.account || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'}
â€¢ Ø´Ù‡Ø±ÙŠ: ${bankLinks.month?.account || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'}
â€¢ 3 Ø£Ø´Ù‡Ø±: ${bankLinks.three_months?.account || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'}
â€¢ Ø³Ù†ÙˆÙŠ: ${bankLinks.year?.account || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'}
        `;
        
        await ctx.replyWithMarkdown(generalMessage, getAdminSettingsKeyboard());
    } catch (error) {
        console.error('Admin general settings error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø©', getAdminSettingsKeyboard());
    }
}

async function handleAdminReset(ctx) {
    try {
        const resetKeyboard = Markup.inlineKeyboard([
            [
                Markup.button.callback('âœ… Ù†Ø¹Ù…ØŒ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ¹ÙŠÙŠÙ†', 'confirm_reset'),
                Markup.button.callback('âŒ Ø¥Ù„ØºØ§Ø¡', 'cancel_reset')
            ]
        ]);

        await ctx.replyWithMarkdown(
            'âš ï¸ *ØªØ­Ø°ÙŠØ±: Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ¹ÙŠÙŠÙ†*\n\n' +
            'Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡ Ø³ÙŠØ¹ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø¥Ù„Ù‰ Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©.\n\n' +
            'âŒ *Ø³ÙŠØªÙ… Ø­Ø°Ù:*\n' +
            'â€¢ Ø¬Ù…ÙŠØ¹ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø£Ø³Ø¹Ø§Ø±\n' +
            'â€¢ Ø¬Ù…ÙŠØ¹ Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ø¯ÙØ¹\n' +
            'â€¢ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØµÙˆØ±\n\n' +
            'âœ… *Ù„Ù† ÙŠØªÙ… Ø­Ø°Ù:*\n' +
            'â€¢ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†\n' +
            'â€¢ Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ø¯ÙØ¹\n\n' +
            'âš ï¸ *Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©ØŸ*',
            resetKeyboard
        );
    } catch (error) {
        console.error('Admin reset error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¥Ø¹Ø¯Ø§Ø¯ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ¹ÙŠÙŠÙ†', getAdminSettingsKeyboard());
    }
}

async function handlePaymentAccept(ctx, paymentId) {
    try {
        const payment = await dbManager.getPayment(paymentId);
        if (!payment) {
            await ctx.answerCbQuery('âŒ Ø·Ù„Ø¨ Ø§Ù„Ø¯ÙØ¹ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯');
            return;
        }
        
        const userData = await dbManager.getUser(payment.user_id);
        if (!userData) {
            await ctx.answerCbQuery('âŒ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯');
            return;
        }
        
        const startDate = new Date().toISOString();
        const endDate = addSubscriptionDays(startDate, payment.subscription_type);
        
        userData.subscription_status = 'active';
        userData.subscription_type = payment.subscription_type;
        userData.subscription_start_date = startDate;
        userData.subscription_end_date = endDate;
        userData.free_attempts = 0;
        
        await dbManager.saveUser(payment.user_id, userData);
        await dbManager.updatePayment(paymentId, { 
            status: 'accepted',
            processed_at: new Date().toISOString()
        });
        
        // Ø¥Ø´Ø¹Ø§Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        try {
            await bot.telegram.sendMessage(
                payment.user_id,
                `ðŸŽ‰ *ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ø´ØªØ±Ø§ÙƒÙƒ Ø¨Ù†Ø¬Ø§Ø­!*\n\n` +
                `âœ… ${getSubscriptionDisplayName(payment.subscription_type)}\n` +
                `ðŸ’° ${payment.amount}$\n` +
                `ðŸ’³ ${payment.payment_system === 'binance' ? 'Ø¨Ø§ÙŠÙ†Ø§Ù†Ø³' : 'ØªØ­ÙˆÙŠÙ„ Ø¨Ù†ÙƒÙŠ'}\n` +
                `ðŸ“… Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡: ${new Date(endDate).toLocaleDateString('ar-EG')}\n` +
                `â³ Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ: ${calculateRemainingDays(endDate)} ÙŠÙˆÙ…\n\n` +
                `ðŸŽ¯ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¢Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø®Ø¯Ù…Ø© Ø¨Ø¯ÙˆÙ† Ø­Ø¯ÙˆØ¯`,
                { parse_mode: 'Markdown' }
            );
        } catch (error) {
            console.error('Error notifying user:', error);
        }

        // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø± Ù„Ù„Ù‚Ù†Ø§Ø©
        await channelNotifier.sendSubscriptionNotification(userData, payment.subscription_type, payment.amount, payment.payment_system);
        
        await ctx.answerCbQuery('âœ… ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ');
        
        try {
            await ctx.editMessageCaption(
                `âœ… *ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø¨Ù†Ø¬Ø§Ø­*\n\n` +
                `ðŸ‘¤ ${userData.username}\n` +
                `ðŸ” ${userData.onexbet}\n` +
                `ðŸ“¦ ${getSubscriptionDisplayName(payment.subscription_type)}\n` +
                `ðŸ’° ${payment.amount}$\n` +
                `ðŸ’³ ${payment.payment_system === 'binance' ? 'Ø¨Ø§ÙŠÙ†Ø§Ù†Ø³' : 'ØªØ­ÙˆÙŠÙ„ Ø¨Ù†ÙƒÙŠ'}\n\n` +
                `ðŸ•’ ${new Date().toLocaleString('ar-EG')}`,
                { parse_mode: 'Markdown' }
            );
        } catch (editError) {
            console.log('Could not edit message:', editError);
        }

    } catch (error) {
        console.error('Payment accept error:', error);
        await ctx.answerCbQuery('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ù‚Ø¨ÙˆÙ„ Ø§Ù„Ø¯ÙØ¹');
    }
}

async function handlePaymentReject(ctx, paymentId) {
    try {
        const payment = await dbManager.getPayment(paymentId);
        if (!payment) {
            await ctx.answerCbQuery('âŒ Ø·Ù„Ø¨ Ø§Ù„Ø¯ÙØ¹ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯');
            return;
        }
        
        await dbManager.updatePayment(paymentId, { 
            status: 'rejected',
            processed_at: new Date().toLocaleString('ar-EG')
        });
        
        // Ø¥Ø´Ø¹Ø§Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        try {
            await bot.telegram.sendMessage(
                payment.user_id,
                `âŒ *ØªÙ… Ø±ÙØ¶ Ø·Ù„Ø¨ Ø§Ù„Ø¯ÙØ¹*\n\n` +
                `ðŸ’³ ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¯ÙØ¹ ÙˆØ§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰\n\n` +
                `ðŸ“ž Ù„Ù„Ø§Ø³ØªÙØ³Ø§Ø±: @GEMZGOOLBOT`,
                { parse_mode: 'Markdown' }
            );
        } catch (error) {
            console.error('Error notifying user:', error);
        }
        
        await ctx.answerCbQuery('âŒ ØªÙ… Ø±ÙØ¶ Ø§Ù„Ø·Ù„Ø¨');
        
        try {
            await ctx.editMessageCaption(
                `âŒ *ØªÙ… Ø±ÙØ¶ Ø·Ù„Ø¨ Ø§Ù„Ø¯ÙØ¹*\n\n` +
                `ðŸ†” ${paymentId}\n` +
                `ðŸ‘¤ ${payment.username}\n` +
                `ðŸ” ${payment.onexbet}\n` +
                `ðŸ’³ ${payment.payment_system === 'binance' ? 'Ø¨Ø§ÙŠÙ†Ø§Ù†Ø³' : 'ØªØ­ÙˆÙŠÙ„ Ø¨Ù†ÙƒÙŠ'}\n\n` +
                `ðŸ•’ ${new Date().toLocaleString('ar-EG')}`,
                { parse_mode: 'Markdown' }
            );
        } catch (editError) {
            console.log('Could not edit message:', editError);
        }

    } catch (error) {
        console.error('Payment reject error:', error);
        await ctx.answerCbQuery('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø±ÙØ¶ Ø§Ù„Ø¯ÙØ¹');
    }
}

// ðŸš€ START BOT
bot.launch().then(() => {
    console.log('ðŸŽ‰ SUCCESS! AI GOAL Predictor v16.0 FIXED with DUAL PAYMENT is RUNNING!');
    console.log('ðŸ’³ Payment Systems: Binance + Bank Transfer');
    console.log('ðŸ’¾ Persistent Data Storage: FIREBASE ENABLED');
    console.log('ðŸ” Channel Subscription: TELEGRAM API ONLY');
    console.log('ðŸ¤– Algorithm Reconnection: ENABLED (5 minutes)');
    console.log('ðŸ’¾ Enhanced Backup System: ENABLED (Auto-backup every 60 minutes)');
    console.log('ðŸ‘¤ Developer:', CONFIG.DEVELOPER);
    console.log('ðŸ“¢ Channel:', CONFIG.CHANNEL);
    console.log('ðŸŒ Health check: http://localhost:' + PORT);
    console.log('ðŸ”„ Keep alive: http://localhost:' + PORT + '/keep-alive');
    console.log('ðŸ”§ Admin ID:', CONFIG.ADMIN_ID);
}).catch(console.error);

// ðŸ›‘ GRACEFUL SHUTDOWN WITH DATA BACKUP
process.once('SIGINT', async () => {
    console.log('ðŸ”„ Creating final backup before shutdown...');
    await persistentStorage.createBackup();
    persistentStorage.stop();
    await bot.stop('SIGINT');
});

process.once('SIGTERM', async () => {
    console.log('ðŸ”„ Creating final backup before shutdown...');
    await persistentStorage.createBackup();
    persistentStorage.stop();
    await bot.stop('SIGTERM');
});

console.log('âœ… AI Goal Prediction System with Dual Payment & Firebase Data Ready!');
