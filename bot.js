// ===================================================
// ğŸš€ AI GOAL PREDICTOR ULTIMATE - VERSION 16.1
// ğŸ‘¤ DEVELOPER: AMIN - @GEMZGOOLBOT
// ğŸ”¥ FEATURES: SMART AI + DUAL PAYMENT SYSTEM + FIREBASE + FULL ADMIN PANEL + DEEP STORAGE
// ===================================================

console.log('ğŸ¤– Starting AI GOAL Predictor Ultimate v16.1...');
console.log('ğŸ•’ ' + new Date().toISOString());

// ğŸ”§ CONFIGURATION
const CONFIG = {
    BOT_TOKEN: process.env.BOT_TOKEN,
    ADMIN_ID: process.env.ADMIN_ID,
    CHANNEL_ID: process.env.CHANNEL_ID,
    CHANNEL_USERNAME: process.env.CHANNEL_USERNAME,
    
    // ğŸ§  AI APIS
    AI_APIS: {
        GEMINI: process.env.GEMINI_API_KEY,
        OPENAI: process.env.OPENAI_API_KEY
    },

    // ğŸ’° DEFAULT PRICING - DUAL PAYMENT SYSTEM
    SUBSCRIPTION_PRICES: {
        binance: {
            week: 10,
            month: 30,
            three_months: 80,
            year: 250
        },
        bank: {
            week: 10,
            month: 30,
            three_months: 80,
            year: 250
        }
    },

    // ğŸ” DEFAULT PAYMENT METHODS
    PAYMENT_METHODS: {
        binance: {
            week: process.env.PAYMENT_WEEK,
            month: process.env.PAYMENT_MONTH,
            three_months: process.env.PAYMENT_3MONTHS,
            year: process.env.PAYMENT_YEAR
        },
        bank: {
            week: { 
                account: process.env.BANK_WEEK_ACCOUNT,
                image: process.env.BANK_WEEK_IMAGE
            },
            month: { 
                account: process.env.BANK_MONTH_ACCOUNT,
                image: process.env.BANK_MONTH_IMAGE
            },
            three_months: { 
                account: process.env.BANK_3MONTHS_ACCOUNT,
                image: process.env.BANK_3MONTHS_IMAGE
            },
            year: { 
                account: process.env.BANK_YEAR_ACCOUNT,
                image: process.env.BANK_YEAR_IMAGE
            }
        }
    },
    
    VERSION: "16.1.0",
    DEVELOPER: "AMIN - @GEMZGOOLBOT",
    CHANNEL: "@GEMZGOOL",
    START_IMAGE: "https://i.ibb.co/tpy70Bd1/IMG-20251104-074214-065.jpg",
    ANALYSIS_IMAGE: "https://i.ibb.co/VYjf05S0/Screenshot.png",
    PREDICTION_IMAGE: "https://i.ibb.co/rGTZm2mB/IMG.jpg",
    IMGBB_API_KEY: process.env.IMGBB_API_KEY
};

console.log('âœ… Configuration loaded successfully');

// ğŸš€ INITIALIZE BOT
const { Telegraf, Markup, session } = require('telegraf');
const axios = require('axios');
const express = require('express');

const bot = new Telegraf(CONFIG.BOT_TOKEN);

// ğŸŒ HEALTH CHECK SERVER FOR RENDER
const app = express();
const PORT = process.env.PORT || 3000;

app.use(express.json());

app.get('/', (req, res) => {
    res.json({ 
        status: 'OK', 
        version: CONFIG.VERSION,
        timestamp: new Date().toISOString(),
        message: 'AI Goal Predictor Bot is running...',
        developer: CONFIG.DEVELOPER
    });
});

// ğŸ”„ KEEP ALIVE ENDPOINT FOR RENDER
app.get('/keep-alive', (req, res) => {
    res.json({ 
        status: 'ALIVE', 
        timestamp: new Date().toISOString(),
        message: 'Bot is alive and running'
    });
});

app.listen(PORT, () => {
    console.log(`ğŸŒ Health check server running on port ${PORT}`);
    console.log(`ğŸ”„ Keep alive endpoint: http://localhost:${PORT}/keep-alive`);
});

// ğŸ”¥ FIREBASE INITIALIZATION - ENHANCED FOR DEEP STORAGE
let db = null;
let admin = null;

try {
    admin = require('firebase-admin');
    
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø¬Ù…ÙŠØ¹ Ù…ØªØºÙŠØ±Ø§Øª Firebase Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©
    const firebaseConfig = {
        projectId: process.env.FIREBASE_PROJECT_ID,
        privateKey: process.env.FIREBASE_PRIVATE_KEY ? process.env.FIREBASE_PRIVATE_KEY.replace(/\\n/g, '\n') : null,
        clientEmail: process.env.FIREBASE_CLIENT_EMAIL
    };

    if (!firebaseConfig.privateKey || !firebaseConfig.clientEmail || !firebaseConfig.projectId) {
        throw new Error('Firebase environment variables are missing');
    }

    const serviceAccount = {
        "type": "service_account",
        "project_id": firebaseConfig.projectId,
        "private_key_id": process.env.FIREBASE_PRIVATE_KEY_ID,
        "private_key": firebaseConfig.privateKey,
        "client_email": firebaseConfig.clientEmail,
        "client_id": process.env.FIREBASE_CLIENT_ID,
        "auth_uri": "https://accounts.google.com/o/oauth2/auth",
        "token_uri": "https://oauth2.googleapis.com/token",
        "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
        "client_x509_cert_url": process.env.FIREBASE_CERT_URL
    };

    if (!admin.apps.length) {
        admin.initializeApp({
            credential: admin.credential.cert(serviceAccount),
            databaseURL: `https://${firebaseConfig.projectId}-default-rtdb.firebaseio.com`
        });
    }
    
    db = admin.firestore();
    
    // ğŸ”„ Ø§Ø®ØªØ¨Ø§Ø± Ø§ØªØµØ§Ù„ Firebase
    const testRef = db.collection('system').doc('connection_test');
    await testRef.set({ 
        timestamp: new Date().toISOString(),
        status: 'connected',
        version: CONFIG.VERSION
    });
    
    console.log('âœ… Firebase initialized successfully with deep storage');
    
} catch (error) {
    console.log('âŒ Firebase initialization failed:', error.message);
    console.log('ğŸ”„ Using enhanced local storage with persistence');
}

// ğŸ—„ï¸ ENHANCED LOCAL STORAGE WITH PERSISTENCE
class EnhancedStorage {
    constructor() {
        this.users = new Map();
        this.payments = new Map();
        this.settings = new Map();
        this.backupInterval = null;
        this.init();
    }

    init() {
        // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø© Ù…Ù† Ø§Ù„Ø°Ø§ÙƒØ±Ø©
        this.loadFromMemory();
        
        // Ù†Ø³Ø® Ø§Ø­ØªÙŠØ§Ø·ÙŠ ØªÙ„Ù‚Ø§Ø¦ÙŠ ÙƒÙ„ 5 Ø¯Ù‚Ø§Ø¦Ù‚
        this.backupInterval = setInterval(() => {
            this.backupToMemory();
        }, 5 * 60 * 1000);
        
        console.log('âœ… Enhanced storage initialized with auto-backup');
    }

    loadFromMemory() {
        try {
            // ÙÙŠ Ø¨ÙŠØ¦Ø© Ø§Ù„Ø¥Ù†ØªØ§Ø¬ØŒ ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ù„ÙØ§Øª Ø£Ùˆ Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª
            // Ù‡Ù†Ø§ Ù†Ø³ØªØ®Ø¯Ù… Ø°Ø§ÙƒØ±Ø© Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø¤Ù‚Øª Ù…Ø¹ Ù†Ø³Ø® Ø§Ø­ØªÙŠØ§Ø·ÙŠ
            const savedData = process.env.STORAGE_BACKUP ? 
                JSON.parse(process.env.STORAGE_BACKUP) : null;
            
            if (savedData) {
                this.users = new Map(savedData.users);
                this.payments = new Map(savedData.payments);
                this.settings = new Map(savedData.settings);
                console.log('âœ… Loaded data from backup');
            }
        } catch (error) {
            console.log('âŒ No backup data found, starting fresh');
        }
    }

    backupToMemory() {
        try {
            const backupData = {
                users: Array.from(this.users.entries()),
                payments: Array.from(this.payments.entries()),
                settings: Array.from(this.settings.entries()),
                timestamp: new Date().toISOString()
            };
            
            // ÙÙŠ Ø¨ÙŠØ¦Ø© Ø­Ù‚ÙŠÙ‚ÙŠØ©ØŒ ÙŠÙ…ÙƒÙ† Ø­ÙØ¸Ù‡Ø§ ÙÙŠ Ù…ØªØºÙŠØ± Ø¨ÙŠØ¦Ø© Ø£Ùˆ Ù…Ù„Ù
            process.env.STORAGE_BACKUP = JSON.stringify(backupData);
            console.log('âœ… Storage backup completed');
        } catch (error) {
            console.log('âŒ Backup failed:', error.message);
        }
    }

    // Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
    setUser(userId, userData) {
        this.users.set(userId.toString(), {
            ...userData,
            last_updated: new Date().toISOString(),
            version: CONFIG.VERSION
        });
    }

    getUser(userId) {
        return this.users.get(userId.toString());
    }

    getAllUsers() {
        return Array.from(this.users.entries()).map(([id, data]) => ({ id, ...data }));
    }

    // Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¯ÙØ¹Ø§Øª
    setPayment(paymentId, paymentData) {
        this.payments.set(paymentId, {
            ...paymentData,
            timestamp: new Date().toISOString()
        });
    }

    getPayment(paymentId) {
        return this.payments.get(paymentId);
    }

    getAllPayments() {
        return Array.from(this.payments.values());
    }

    // Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
    setSettings(key, settings) {
        this.settings.set(key, {
            ...settings,
            updated_at: new Date().toISOString()
        });
    }

    getSettings(key) {
        return this.settings.get(key);
    }

    // Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
    searchUsers(query) {
        const users = this.getAllUsers();
        const lowerQuery = query.toLowerCase();
        
        return users.filter(user => 
            (user.user_id && user.user_id.toString().includes(query)) ||
            (user.username && user.username.toLowerCase().includes(lowerQuery)) ||
            (user.onexbet && user.onexbet.toString().includes(query))
        );
    }

    // ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø°Ø§ÙƒØ±Ø©
    cleanup() {
        if (this.backupInterval) {
            clearInterval(this.backupInterval);
        }
        this.backupToMemory();
    }
}

// ØªÙ‡ÙŠØ¦Ø© Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø­Ø³Ù†
const enhancedStorage = new EnhancedStorage();

// ğŸ“Š DYNAMIC STATISTICS SYSTEM
class DynamicStatistics {
    constructor() {
        this.totalUsers = 78542;
        this.activeUsers = 300;
        this.lastCallTime = Date.now();
        this.callCount = 0;
    }

    getStats() {
        const now = Date.now();
        
        this.callCount++;
        const randomIncrement = Math.floor(Math.random() * 5) + 1;
        this.activeUsers += randomIncrement;
        
        if (this.activeUsers > 5000) {
            this.activeUsers = 300;
        }
        
        this.lastCallTime = now;

        return {
            totalUsers: this.totalUsers,
            activeUsers: this.activeUsers
        };
    }
}

// ğŸ§  SMART GOAL PREDICTION ENGINE
class GoalPredictionAI {
    constructor() {
        this.algorithmVersion = "16.1";
    }

    getSaudiTime() {
        const now = new Date();
        const saudiTime = new Date(now.getTime() + (3 * 60 * 60 * 1000));
        return saudiTime.toLocaleTimeString('ar-SA', { 
            hour: '2-digit', 
            minute: '2-digit',
            second: '2-digit',
            hour12: false 
        });
    }

    getSaudiDateTime() {
        const now = new Date();
        const saudiTime = new Date(now.getTime() + (3 * 60 * 60 * 1000));
        return saudiTime.toLocaleString('ar-SA', {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
            hour12: false
        });
    }

    generateSmartPrediction(userId) {
        const isGoal = Math.random() > 0.5;
        const probability = Math.floor(Math.random() * 30) + 60;
        
        const realTime = this.getSaudiTime();
        const realDateTime = this.getSaudiDateTime();
        
        const prediction = {
            type: isGoal ? 'âš½ GOAL' : 'ğŸ›‘ NO GOAL',
            probability: probability,
            confidence: 100,
            reasoning: isGoal ? 
                `ğŸ”¥ Ø§Ù„Ø¶ØºØ· Ø§Ù„Ù‡Ø¬ÙˆÙ…ÙŠ Ø§Ù„Ù…Ø³ØªÙ…Ø± ÙŠØ´ÙŠØ± Ù„Ù‡Ø¯Ù Ù‚Ø±ÙŠØ¨ Ø¨Ù†Ø³Ø¨Ø© ${probability}%` :
                `ğŸ›¡ï¸ Ø§Ù„Ø¯ÙØ§Ø¹ Ø§Ù„Ù…Ù†Ø¸Ù… ÙŠØ­Ø¯ Ù…Ù† Ø§Ù„ÙØ±Øµ Ø¨Ù†Ø³Ø¨Ø© ${probability}%`,
            timestamp: realTime,
            datetime: realDateTime,
            algorithm: this.algorithmVersion
        };

        return prediction;
    }

    generateNextPrediction(userId) {
        return this.generateSmartPrediction(userId);
    }
}

// ğŸ“¤ IMGBB UPLOADER - ENHANCED
class ImgBBUploader {
    constructor(apiKey) {
        this.apiKey = apiKey;
        this.baseUrl = 'https://api.imgbb.com/1/upload';
    }

    async uploadImage(imageBuffer) {
        try {
            const FormData = require('form-data');
            const formData = new FormData();
            
            formData.append('key', this.apiKey);
            formData.append('image', imageBuffer.toString('base64'));
            
            const response = await axios.post(this.baseUrl, formData, {
                headers: {
                    ...formData.getHeaders()
                },
                timeout: 30000
            });
            
            if (response.data && response.data.success) {
                return {
                    success: true,
                    url: response.data.data.url,
                    display_url: response.data.data.display_url,
                    thumb_url: response.data.data.thumb?.url || response.data.data.url,
                    delete_url: response.data.data.delete_url
                };
            } else {
                return {
                    success: false,
                    error: 'Upload failed'
                };
            }
        } catch (error) {
            console.error('ImgBB upload error:', error);
            return {
                success: false,
                error: error.message
            };
        }
    }

    async uploadImageFromUrl(imageUrl) {
        try {
            const response = await axios.get(imageUrl, { 
                responseType: 'arraybuffer',
                timeout: 30000
            });
            const imageBuffer = Buffer.from(response.data);
            return await this.uploadImage(imageBuffer);
        } catch (error) {
            console.error('ImgBB upload from URL error:', error);
            return {
                success: false,
                error: error.message
            };
        }
    }
}

// ğŸ’¾ ENHANCED DATABASE MANAGER WITH DEEP STORAGE
class DatabaseManager {
    constructor() {
        this.maintenanceMode = false;
        this.storage = enhancedStorage;
        
        // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
        this.initDefaultSettings();
    }

    async initDefaultSettings() {
        try {
            const existingSettings = await this.getSettings();
            if (!existingSettings) {
                const defaultSettings = {
                    prices: { ...CONFIG.SUBSCRIPTION_PRICES },
                    payment_methods: { ...CONFIG.PAYMENT_METHODS },
                    maintenance_mode: false,
                    updated_at: new Date().toISOString(),
                    version: CONFIG.VERSION
                };
                
                await this.updateSettings(defaultSettings);
                console.log('âœ… Default settings initialized');
            }
        } catch (error) {
            console.log('âŒ Settings initialization failed:', error.message);
        }
    }

    async getUser(userId) {
        try {
            if (db) {
                const userDoc = await db.collection('users').doc(userId.toString()).get();
                if (userDoc.exists) {
                    const userData = userDoc.data();
                    console.log(`âœ… Loaded user ${userId} from Firebase`);
                    return userData;
                }
            }
            
            // Fallback to enhanced storage
            const userData = this.storage.getUser(userId);
            if (userData) {
                console.log(`âœ… Loaded user ${userId} from enhanced storage`);
            }
            return userData || null;
        } catch (error) {
            console.error('Get user error:', error);
            return this.storage.getUser(userId) || null;
        }
    }

    async saveUser(userId, userData) {
        try {
            // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù…Ø¹ Ø§Ù„ØªØ¹Ø²ÙŠØ²
            const completeUserData = {
                user_id: userId,
                username: userData.username || 'Unknown',
                onexbet: userData.onexbet || '',
                free_attempts: userData.free_attempts || 0,
                subscription_status: userData.subscription_status || 'free',
                subscription_type: userData.subscription_type || 'none',
                subscription_start_date: userData.subscription_start_date || null,
                subscription_end_date: userData.subscription_end_date || null,
                joined_at: userData.joined_at || new Date().toISOString(),
                total_predictions: userData.total_predictions || 0,
                correct_predictions: userData.correct_predictions || 0,
                wins: userData.wins || 0,
                losses: userData.losses || 0,
                total_bets: userData.total_bets || 0,
                total_profit: userData.total_profit || 0,
                last_updated: new Date().toISOString(),
                channel_subscribed: userData.channel_subscribed || false,
                version: CONFIG.VERSION,
                persistent_id: `user_${userId}_${Date.now()}`
            };

            // Ø§Ù„Ø­ÙØ¸ ÙÙŠ Firebase Ø£ÙˆÙ„Ø§Ù‹
            if (db) {
                await db.collection('users').doc(userId.toString()).set(completeUserData, { merge: true });
                console.log(`âœ… Saved user ${userId} to Firebase`);
            }

            // Ø§Ù„Ø­ÙØ¸ ÙÙŠ Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø­Ø³Ù† Ø¯Ø§Ø¦Ù…Ø§Ù‹
            this.storage.setUser(userId, completeUserData);
            console.log(`âœ… Saved user ${userId} to enhanced storage`);

            return true;
        } catch (error) {
            console.error('Error saving user:', error);
            // Fallback Ø¥Ù„Ù‰ Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø­Ø³Ù†
            this.storage.setUser(userId, userData);
            console.log(`âœ… Saved user ${userId} to enhanced storage (fallback)`);
            return true;
        }
    }

    async addPayment(paymentData) {
        const paymentId = `payment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        try {
            const fullPaymentData = {
                ...paymentData,
                id: paymentId,
                status: 'pending',
                timestamp: new Date().toISOString(),
                persistent_id: paymentId
            };

            if (db) {
                await db.collection('payments').doc(paymentId).set(fullPaymentData);
            }
            this.storage.setPayment(paymentId, fullPaymentData);
            return paymentId;
        } catch (error) {
            const fullPaymentData = {
                ...paymentData,
                id: paymentId,
                status: 'pending',
                timestamp: new Date().toISOString(),
                persistent_id: paymentId
            };
            this.storage.setPayment(paymentId, fullPaymentData);
            return paymentId;
        }
    }

    async getPendingPayments() {
        try {
            if (db) {
                const paymentsSnapshot = await db.collection('payments').where('status', '==', 'pending').get();
                return paymentsSnapshot.docs.map(doc => doc.data());
            }
            return this.storage.getAllPayments().filter(p => p.status === 'pending');
        } catch (error) {
            return this.storage.getAllPayments().filter(p => p.status === 'pending');
        }
    }

    async updatePayment(paymentId, updates) {
        try {
            if (db) {
                await db.collection('payments').doc(paymentId).update(updates);
            }
            const payment = this.storage.getPayment(paymentId);
            if (payment) {
                this.storage.setPayment(paymentId, { ...payment, ...updates });
            }
            return true;
        } catch (error) {
            const payment = this.storage.getPayment(paymentId);
            if (payment) {
                this.storage.setPayment(paymentId, { ...payment, ...updates });
            }
            return true;
        }
    }

    async getAllUsers() {
        try {
            if (db) {
                const usersSnapshot = await db.collection('users').get();
                return usersSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            }
            return this.storage.getAllUsers();
        } catch (error) {
            return this.storage.getAllUsers();
        }
    }

    async getSettings() {
        try {
            if (db) {
                const settingsDoc = await db.collection('settings').doc('config').get();
                if (settingsDoc.exists) {
                    return settingsDoc.data();
                }
            }
            return this.storage.getSettings('config');
        } catch (error) {
            return this.storage.getSettings('config');
        }
    }

    async updateSettings(newSettings) {
        try {
            const updatedSettings = {
                ...newSettings,
                updated_at: new Date().toISOString(),
                version: CONFIG.VERSION
            };

            if (db) {
                await db.collection('settings').doc('config').set(updatedSettings, { merge: true });
            }
            this.storage.setSettings('config', updatedSettings);
            return updatedSettings;
        } catch (error) {
            const updatedSettings = {
                ...newSettings,
                updated_at: new Date().toISOString(),
                version: CONFIG.VERSION
            };
            this.storage.setSettings('config', updatedSettings);
            return updatedSettings;
        }
    }

    async getPayment(paymentId) {
        try {
            if (db) {
                const paymentDoc = await db.collection('payments').doc(paymentId).get();
                return paymentDoc.exists ? paymentDoc.data() : null;
            }
            return this.storage.getPayment(paymentId);
        } catch (error) {
            return this.storage.getPayment(paymentId);
        }
    }

    async getAllPayments() {
        try {
            if (db) {
                const paymentsSnapshot = await db.collection('payments').get();
                return paymentsSnapshot.docs.map(doc => doc.data());
            }
            return this.storage.getAllPayments();
        } catch (error) {
            return this.storage.getAllPayments();
        }
    }

    isMaintenanceMode() {
        return this.maintenanceMode;
    }

    async setMaintenanceMode(enabled) {
        try {
            const settings = await this.getSettings();
            settings.maintenance_mode = enabled;
            await this.updateSettings(settings);
            this.maintenanceMode = enabled;
            return true;
        } catch (error) {
            this.maintenanceMode = enabled;
            return true;
        }
    }

    async searchUsers(query) {
        try {
            return this.storage.searchUsers(query);
        } catch (error) {
            console.error('Search users error:', error);
            return [];
        }
    }

    async backupData() {
        try {
            const backupData = {
                users: await this.getAllUsers(),
                payments: await this.getAllPayments(),
                settings: await this.getSettings(),
                timestamp: new Date().toISOString(),
                version: CONFIG.VERSION
            };
            
            if (db) {
                await db.collection('backups').doc(Date.now().toString()).set(backupData);
            }
            
            return backupData;
        } catch (error) {
            console.error('Backup error:', error);
            return null;
        }
    }

    async setChannelSubscription(userId, subscribed) {
        try {
            const user = await this.getUser(userId);
            if (user) {
                user.channel_subscribed = subscribed;
                await this.saveUser(userId, user);
            }
            return true;
        } catch (error) {
            console.error('Set channel subscription error:', error);
            return false;
        }
    }

    async getAllStats() {
        try {
            const users = await this.getAllUsers();
            const payments = await this.getAllPayments();
            
            const activeUsers = users.filter(u => u.subscription_status === 'active');
            const freeUsers = users.filter(u => u.subscription_status === 'free');
            
            const totalPredictions = users.reduce((sum, user) => sum + (user.total_predictions || 0), 0);
            const totalProfit = users.reduce((sum, user) => sum + (user.total_profit || 0), 0);
            const totalBets = users.reduce((sum, user) => sum + (user.total_bets || 0), 0);
            
            return {
                totalUsers: users.length,
                activeUsers: activeUsers.length,
                freeUsers: freeUsers.length,
                totalPredictions,
                totalProfit,
                totalBets,
                totalPayments: payments.length,
                pendingPayments: payments.filter(p => p.status === 'pending').length
            };
        } catch (error) {
            console.error('Get all stats error:', error);
            return {
                totalUsers: 0,
                activeUsers: 0,
                freeUsers: 0,
                totalPredictions: 0,
                totalProfit: 0,
                totalBets: 0,
                totalPayments: 0,
                pendingPayments: 0
            };
        }
    }

    // ğŸ”„ Ø¯Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ø³ØªÙ…Ø±Ø§Ø±ÙŠØ© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    async verifyDataPersistence() {
        try {
            const users = await this.getAllUsers();
            const settings = await this.getSettings();
            
            console.log(`âœ… Data persistence verified:`);
            console.log(`   ğŸ“Š Users: ${users.length}`);
            console.log(`   âš™ï¸ Settings: ${settings ? 'Loaded' : 'Not found'}`);
            console.log(`   ğŸ”„ Version: ${CONFIG.VERSION}`);
            
            return true;
        } catch (error) {
            console.error('Data persistence verification failed:', error);
            return false;
        }
    }
}

// INITIALIZE SYSTEMS
const goalAI = new GoalPredictionAI();
const dbManager = new DatabaseManager();
const dynamicStats = new DynamicStatistics();
const imgbbUploader = new ImgBBUploader(CONFIG.IMGBB_API_KEY);

// ğŸ“¢ CHANNEL NOTIFICATION SYSTEM
class ChannelNotifier {
    constructor(bot, channelId) {
        this.bot = bot;
        this.channelId = channelId;
    }

    async sendSubscriptionNotification(userData, subscriptionType, amount, paymentMethod) {
        try {
            const saudiTime = goalAI.getSaudiDateTime();
            
            const message = `
ğŸ‰ *Ø§Ø´ØªØ±Ø§Ùƒ Ø¬Ø¯ÙŠØ¯ ÙÙŠ Ø§Ù„Ø¨ÙˆØª*

ğŸ‘¤ *Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:* ${userData.username}
ğŸ” *Ø§Ù„Ø­Ø³Ø§Ø¨:* ${userData.onexbet}
ğŸ“¦ *Ø§Ù„Ø¨Ø§Ù‚Ø©:* ${subscriptionType}
ğŸ’° *Ø§Ù„Ù…Ø¨Ù„Øº:* ${amount}$
ğŸ’³ *Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹:* ${paymentMethod === 'binance' ? 'Binance' : 'Ø§Ù„Ø¨Ù†Ùƒ Ø§Ù„ÙƒØ±ÙŠÙ…ÙŠ'}

ğŸ•’ *Ø§Ù„ÙˆÙ‚Øª:* ${saudiTime}
            `;

            await this.bot.telegram.sendMessage(this.channelId, message, {
                parse_mode: 'Markdown'
            });
        } catch (error) {
            console.error('Error sending subscription notification:', error);
        }
    }

    async sendPredictionNotification(userData, prediction, betAmount) {
        try {
            const saudiTime = goalAI.getSaudiDateTime();
            
            const message = `
ğŸ¯ *ØªÙˆÙ‚Ø¹ Ø¬Ø¯ÙŠØ¯ ÙÙŠ Ø§Ù„Ø¨ÙˆØª*

ğŸ‘¤ *Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:* ${userData.username}
ğŸ” *Ø§Ù„Ø­Ø³Ø§Ø¨:* ${userData.onexbet}
ğŸ¯ *Ø§Ù„ØªÙˆÙ‚Ø¹:* ${prediction.type}
ğŸ“ˆ *Ø§Ù„Ø§Ø­ØªÙ…Ø§Ù„ÙŠØ©:* ${prediction.probability}%
ğŸ’° *Ù…Ø¨Ù„Øº Ø§Ù„Ø±Ù‡Ø§Ù†:* ${betAmount}$

ğŸ’¡ *Ø§Ù„ØªØ­Ù„ÙŠÙ„:*
${prediction.reasoning}

ğŸ•’ *Ø§Ù„ÙˆÙ‚Øª:* ${saudiTime}
            `;

            await this.bot.telegram.sendMessage(this.channelId, message, {
                parse_mode: 'Markdown'
            });
        } catch (error) {
            console.error('Error sending prediction notification:', error);
        }
    }
}

const channelNotifier = new ChannelNotifier(bot, CONFIG.CHANNEL_ID);

// ğŸ¯ BOT SETUP
bot.use(session({ 
    defaultSession: () => ({ 
        step: 'start',
        userData: {},
        verificationCode: null,
        accountId: null,
        paymentType: null,
        paymentMethod: null,
        adminMode: false,
        adminStep: null,
        awaitingPaymentAccount: false,
        paymentAccount: null,
        currentBet: 0,
        originalBet: 0,
        totalProfit: 0,
        awaitingBetAmount: false,
        searchQuery: null,
        broadcastMessage: null,
        adminSettingsStep: null,
        selectedPaymentType: null,
        editingSubscriptionType: null,
        editingPaymentMethod: null,
        editingBankAccount: null,
        editingBankPrice: null,
        checkingChannel: false,
        // ğŸ†• Ø¬Ù„Ø³Ø§Øª Ø¬Ø¯ÙŠØ¯Ø© Ù„ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø¨Ù†Ùƒ Ø§Ù„ÙƒØ±ÙŠÙ…ÙŠ
        bankEditStep: null,
        tempBankData: {}
    })
}));

// ğŸ¯ Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ø«Ø§Ø¨ØªØ©
const getMainKeyboard = () => {
    return Markup.keyboard([
        ['ğŸ¯ Ø¬Ù„Ø¨ Ø§Ù„ØªØ­Ù„ÙŠÙ„', 'ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§ØªÙŠ'],
        ['ğŸ’³ Ø§Ù„Ø§Ø´ØªØ±Ø§ÙƒØ§Øª', 'ğŸ‘¥ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØª'],
        ['ğŸ‘¤ Ø­Ø§Ù„Ø© Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ', 'ğŸ†˜ Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ']
    ]).resize();
};

const getLoginKeyboard = () => {
    return Markup.keyboard([
        ['ğŸ” Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨']
    ]).resize();
};

const getSubscriptionKeyboard = () => {
    return Markup.keyboard([
        ['ğŸ’³ Binance', 'ğŸ¦ Ø§Ù„Ø¨Ù†Ùƒ Ø§Ù„ÙƒØ±ÙŠÙ…ÙŠ'],
        ['ğŸ”™ Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø©']
    ]).resize();
};

const getPaymentMethodKeyboard = (paymentMethod) => {
    return Markup.keyboard([
        ['ğŸ’° Ø£Ø³Ø¨ÙˆØ¹ÙŠ', 'ğŸ’° Ø´Ù‡Ø±ÙŠ'],
        ['ğŸ’° 3 Ø£Ø´Ù‡Ø±', 'ğŸ’° Ø³Ù†ÙˆÙŠ'],
        ['ğŸ”™ Ø±Ø¬ÙˆØ¹ Ù„Ù„Ø§Ø´ØªØ±Ø§ÙƒØ§Øª']
    ]).resize();
};

const getAdminMainKeyboard = () => {
    return Markup.keyboard([
        ['ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù†Ø¸Ø§Ù…', 'ğŸ‘¥ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†'],
        ['ğŸ’° Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ø¯ÙØ¹', 'âš™ï¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª'],
        ['ğŸ“¢ Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø±', 'ğŸ” Ø¨Ø­Ø« Ø¹Ù† Ù…Ø³ØªØ®Ø¯Ù…'],
        ['ğŸ”§ Ù‚ÙÙ„/ÙØªØ­ Ø§Ù„Ø¨ÙˆØª', 'ğŸ”™ Ø§Ù„Ø®Ø±ÙˆØ¬ Ù…Ù† Ø§Ù„Ø¥Ø¯Ù…Ù†']
    ]).resize();
};

const getAdminUsersKeyboard = () => {
    return Markup.keyboard([
        ['ğŸ“‹ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†', 'âœ… Ø§Ù„Ù…Ø´ØªØ±ÙƒÙŠÙ† Ø§Ù„Ù†Ø´Ø·ÙŠÙ†'],
        ['ğŸ†“ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠÙ†', 'ğŸ“ˆ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†'],
        ['ğŸ”™ Ø±Ø¬ÙˆØ¹']
    ]).resize();
};

const getAdminPaymentsKeyboard = () => {
    return Markup.keyboard([
        ['ğŸ“¥ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…Ø¹Ù„Ù‚Ø©', 'âœ… Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…Ù‚Ø¨ÙˆÙ„Ø©'],
        ['âŒ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…Ø±ÙÙˆØ¶Ø©', 'ğŸ“‹ ÙƒÙ„ Ø§Ù„Ø·Ù„Ø¨Ø§Øª'],
        ['ğŸ”™ Ø±Ø¬ÙˆØ¹']
    ]).resize();
};

const getAdminSettingsKeyboard = () => {
    return Markup.keyboard([
        ['ğŸ’° ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø£Ø³Ø¹Ø§Ø± ÙˆØ§Ù„Ø¯ÙØ¹', 'âš™ï¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø©'],
        ['ğŸ”„ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ¹ÙŠÙŠÙ†', 'ğŸ”™ Ø±Ø¬ÙˆØ¹']
    ]).resize();
};

const getAdminPaymentMethodsKeyboard = () => {
    return Markup.keyboard([
        ['ğŸ’³ ØªØ¹Ø¯ÙŠÙ„ Binance', 'ğŸ¦ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø¨Ù†Ùƒ Ø§Ù„ÙƒØ±ÙŠÙ…ÙŠ'],
        ['ğŸ”™ Ø±Ø¬ÙˆØ¹']
    ]).resize();
};

const getAdminPaymentTypesKeyboard = () => {
    return Markup.keyboard([
        ['ğŸ’° Ø£Ø³Ø¨ÙˆØ¹ÙŠ', 'ğŸ’° Ø´Ù‡Ø±ÙŠ'],
        ['ğŸ’° 3 Ø£Ø´Ù‡Ø±', 'ğŸ’° Ø³Ù†ÙˆÙŠ'],
        ['ğŸ”™ Ø±Ø¬ÙˆØ¹']
    ]).resize();
};

// ğŸ†• Ù„ÙˆØ­Ø© Ù…ÙØ§ØªÙŠØ­ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø¨Ù†Ùƒ Ø§Ù„ÙƒØ±ÙŠÙ…ÙŠ
const getAdminBankEditKeyboard = () => {
    return Markup.keyboard([
        ['ğŸ’µ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø³Ø¹Ø±', 'ğŸ¦ ØªØ¹Ø¯ÙŠÙ„ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨'],
        ['ğŸ–¼ï¸ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©', 'âœ… Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„'],
        ['ğŸ”™ Ø±Ø¬ÙˆØ¹']
    ]).resize();
};

// ğŸ› ï¸ UTILITY FUNCTIONS
function calculateRemainingDays(endDate) {
    try {
        const end = new Date(endDate);
        const now = new Date();
        const diffTime = end - now;
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
        return diffDays > 0 ? diffDays : 0;
    } catch (error) {
        return 0;
    }
}

function addSubscriptionDays(startDate, type) {
    try {
        const start = new Date(startDate);
        const types = {
            week: 7,
            month: 30,
            three_months: 90,
            year: 365
        };
        start.setDate(start.getDate() + types[type]);
        return start.toISOString();
    } catch (error) {
        const newDate = new Date();
        newDate.setDate(newDate.getDate() + 30);
        return newDate.toISOString();
    }
}

// ğŸ” FUNCTION TO CHECK CHANNEL SUBSCRIPTION
async function checkChannelSubscription(userId) {
    try {
        const chatMember = await bot.telegram.getChatMember(CONFIG.CHANNEL_ID, userId);
        return chatMember.status === 'member' || chatMember.status === 'administrator' || chatMember.status === 'creator';
    } catch (error) {
        console.error('Error checking channel subscription:', error);
        return false;
    }
}

// ğŸ”„ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ø³ØªÙ…Ø±Ø§Ø±ÙŠØ© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¹Ù†Ø¯ Ø§Ù„Ø¨Ø¯Ø¡
dbManager.verifyDataPersistence().then(success => {
    if (success) {
        console.log('ğŸ‰ Data persistence system is working perfectly!');
    } else {
        console.log('âš ï¸ Data persistence has some issues, but bot will continue...');
    }
});

// ğŸ¯ BOT COMMANDS - ENHANCED WITH DEEP STORAGE

bot.start(async (ctx) => {
    try {
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ø³ØªÙ…Ø±Ø§Ø±ÙŠØ© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø£ÙˆÙ„Ø§Ù‹
        await dbManager.verifyDataPersistence();

        const settings = await dbManager.getSettings();
        if (settings.maintenance_mode && ctx.from.id.toString() !== CONFIG.ADMIN_ID) {
            await ctx.replyWithMarkdown('ğŸ”§ *Ø§Ù„Ø¨ÙˆØª ØªØ­Øª Ø§Ù„ØµÙŠØ§Ù†Ø©*\n\nâ° Ù†Ø¹Ù…Ù„ Ø¹Ù„Ù‰ ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø®Ø¯Ù…Ø© Ù„ÙƒÙ…\nğŸ”„ Ø³Ù†Ø¹ÙˆØ¯ Ù‚Ø±ÙŠØ¨Ø§Ù‹ Ø¨Ø£ÙØ¶Ù„ Ù…Ù…Ø§ ÙƒØ§Ù†\n\nğŸ“ Ù„Ù„Ø§Ø³ØªÙØ³Ø§Ø±: ' + CONFIG.DEVELOPER);
            return;
        }

        const userId = ctx.from.id.toString();
        const userName = ctx.from.first_name;

        console.log(`ğŸ” Checking existing user: ${userId}`);

        // ğŸ” Ø§Ù„Ø¨Ø­Ø« Ø§Ù„Ù…Ø¹Ø²Ø² Ø¹Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙÙŠ Ø¬Ù…ÙŠØ¹ Ø£Ù†Ø¸Ù…Ø© Ø§Ù„ØªØ®Ø²ÙŠÙ†
        const existingUser = await dbManager.getUser(userId);
        
        if (existingUser) {
            // âœ… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø³Ø¬Ù„ Ù…Ø³Ø¨Ù‚Ø§Ù‹ - Ø¯Ø®ÙˆÙ„ Ù…Ø¨Ø§Ø´Ø± Ø¥Ù„Ù‰ Ø§Ù„ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
            console.log(`âœ… Existing user found: ${userId} - ${existingUser.username}`);
            
            ctx.session.step = 'verified';
            ctx.session.userData = existingUser;

            const remainingDays = calculateRemainingDays(existingUser.subscription_end_date);
            const saudiTime = goalAI.getSaudiDateTime();
            
            let statusMessage = '';
            if (existingUser.subscription_status === 'active' && remainingDays > 0) {
                statusMessage = `ğŸ‰ *Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ø¹ÙˆØ¯ØªÙƒ!*\n\n` +
                               `âœ… *Ø§Ø´ØªØ±Ø§ÙƒÙƒ Ù†Ø´Ø·*\n` +
                               `ğŸ” Ø§Ù„Ø­Ø³Ø§Ø¨: \`${existingUser.onexbet}\`\n` +
                               `ğŸ“¦ Ø§Ù„Ù†ÙˆØ¹: ${existingUser.subscription_type}\n` +
                               `ğŸ“… Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡: ${new Date(existingUser.subscription_end_date).toLocaleDateString('ar-EG')}\n` +
                               `â³ Ù…ØªØ¨Ù‚ÙŠ: ${remainingDays} ÙŠÙˆÙ…\n` +
                               `ğŸ•’ Ø§Ù„ÙˆÙ‚Øª: ${saudiTime}\n\n` +
                               `ğŸ”„ *ØªÙ… Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø­Ø³Ø§Ø¨Ùƒ Ø¨Ù†Ø¬Ø§Ø­ Ù…Ù† Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø¢Ù…Ù†*`;
            } else if (existingUser.free_attempts > 0) {
                statusMessage = `ğŸ‰ *Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ø¹ÙˆØ¯ØªÙƒ!*\n\n` +
                               `ğŸ¯ *Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ù…Ø¬Ø§Ù†ÙŠØ© Ù…ØªØ§Ø­Ø©*\n` +
                               `ğŸ” Ø§Ù„Ø­Ø³Ø§Ø¨: \`${existingUser.onexbet}\`\n` +
                               `ğŸ†“ Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ù…Ø¬Ø§Ù†ÙŠØ©: ${existingUser.free_attempts}\n` +
                               `ğŸ•’ Ø§Ù„ÙˆÙ‚Øª: ${saudiTime}\n\n` +
                               `ğŸ”„ *ØªÙ… Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø­Ø³Ø§Ø¨Ùƒ Ø¨Ù†Ø¬Ø§Ø­ Ù…Ù† Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø¢Ù…Ù†*`;
            } else {
                statusMessage = `ğŸ‰ *Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ø¹ÙˆØ¯ØªÙƒ!*\n\n` +
                               `ğŸš« *Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª*\n` +
                               `ğŸ” Ø§Ù„Ø­Ø³Ø§Ø¨: \`${existingUser.onexbet}\`\n` +
                               `ğŸ’³ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ù„Ù„Ù…ØªØ§Ø¨Ø¹Ø©\n` +
                               `ğŸ•’ Ø§Ù„ÙˆÙ‚Øª: ${saudiTime}\n\n` +
                               `ğŸ”„ *ØªÙ… Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø­Ø³Ø§Ø¨Ùƒ Ø¨Ù†Ø¬Ø§Ø­ Ù…Ù† Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø¢Ù…Ù†*`;
            }

            await ctx.replyWithMarkdown(statusMessage, getMainKeyboard());
            
        } else {
            // ğŸ†• Ù…Ø³ØªØ®Ø¯Ù… Ø¬Ø¯ÙŠØ¯ - Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø© Ø£ÙˆÙ„Ø§Ù‹
            console.log(`ğŸ†• New user detected: ${userId} - ${userName}`);
            
            const isSubscribed = await checkChannelSubscription(userId);
            
            if (!isSubscribed) {
                await ctx.replyWithMarkdown(
                    `ğŸ” *Ù…Ø±Ø­Ø¨Ø§Ù‹ ${userName} ÙÙŠ Ù†Ø¸Ø§Ù… GOAL Predictor Pro v${CONFIG.VERSION}*\n\n` +
                    `ğŸ“¢ *Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØª ÙŠØ¬Ø¨ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ù‚Ù†Ø§ØªÙ†Ø§ Ø£ÙˆÙ„Ø§Ù‹*\n\n` +
                    `ğŸ‘‰ ${CONFIG.CHANNEL_USERNAME}\n\n` +
                    `âœ… Ø¨Ø¹Ø¯ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø± Ø£Ø¯Ù†Ø§Ù‡ Ù„Ù„ØªØ­Ù‚Ù‚:`,
                    Markup.inlineKeyboard([
                        [Markup.button.callback('âœ… ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ', 'check_channel_subscription')]
                    ])
                );
                return;
            }

            // Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…Ø´ØªØ±ÙƒØ§Ù‹ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©ØŒ Ù†ÙƒÙ…Ù„ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØ³Ø¬ÙŠÙ„
            await dbManager.setChannelSubscription(userId, true);
            
            // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±Ø© Ø£ÙˆÙ„Ø§Ù‹
            try {
                await ctx.replyWithPhoto(CONFIG.START_IMAGE, {
                    caption: `ğŸ‰ *Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ù†Ø¸Ø§Ù… GOAL Predictor Pro v${CONFIG.VERSION}* ğŸš€\n\n` +
                            `ğŸ¤– *Ø£Ù‚ÙˆÙ‰ Ù†Ø¸Ø§Ù… Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„Ø£Ù‡Ø¯Ø§Ù Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ*\n` +
                            `ğŸ’ *Ø§Ù„Ù…Ø·ÙˆØ±:* ${CONFIG.DEVELOPER}\n` +
                            `ğŸ“¢ *Ø§Ù„Ù‚Ù†Ø§Ø©:* ${CONFIG.CHANNEL}\n` +
                            `ğŸ•’ *Ø§Ù„ÙˆÙ‚Øª:* ${goalAI.getSaudiDateTime()}\n\n` +
                            `ğŸ’¾ *Ù†Ø¸Ø§Ù… ØªØ®Ø²ÙŠÙ† Ø¢Ù…Ù† ÙŠØ­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§ØªÙƒ Ø¯Ø§Ø¦Ù…Ø§Ù‹*`
                });
            } catch (photoError) {
                await ctx.replyWithMarkdown(`ğŸ‰ *Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ù†Ø¸Ø§Ù… GOAL Predictor Pro v${CONFIG.VERSION}* ğŸš€\nğŸ•’ *Ø§Ù„ÙˆÙ‚Øª:* ${goalAI.getSaudiDateTime()}`);
            }

            const welcomeMessage = `
ğŸ” *Ù…Ø±Ø­Ø¨Ø§Ù‹ ${userName} ÙÙŠ Ù†Ø¸Ø§Ù… GOAL Predictor Pro v${CONFIG.VERSION}*

ğŸ¯ *Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ØªÙ‚Ø¯Ù… Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„Ø£Ù‡Ø¯Ø§Ù ÙÙŠ Ø§Ù„Ù…Ø¨Ø§Ø±ÙŠØ§Øª*
ğŸ¤– *Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ø°ÙƒÙŠØ© Ù…Ø®ÙÙŠØ© ØªØ­Ù„Ù„ Ø§Ù„Ù…Ø¨Ø§Ø±ÙŠØ§Øª Ø¨Ø¯Ù‚Ø© Ø¹Ø§Ù„ÙŠØ©*
ğŸ’¾ *Ù†Ø¸Ø§Ù… ØªØ®Ø²ÙŠÙ† Ø¢Ù…Ù† - Ø¨ÙŠØ§Ù†Ø§ØªÙƒ Ù…Ø­ÙÙˆØ¸Ø© Ø¯Ø§Ø¦Ù…Ø§Ù‹*

ğŸ“‹ *Ø®Ø·ÙˆØ§Øª Ø§Ù„Ø¯Ø®ÙˆÙ„:*
1ï¸âƒ£ Ø£Ø¯Ø®Ù„ Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet (10 Ø£Ø±Ù‚Ø§Ù…)
2ï¸âƒ£ Ø§Ø³ØªÙ„Ù… ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚ (6 Ø£Ø±Ù‚Ø§Ù…)  
3ï¸âƒ£ Ø£Ø¯Ø®Ù„ ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚
4ï¸âƒ£ Ø§Ø¨Ø¯Ø£ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠØ©

ğŸ’ *Ø§Ù„Ù…Ø·ÙˆØ±:* ${CONFIG.DEVELOPER}
ğŸ“¢ *Ø§Ù„Ù‚Ù†Ø§Ø©:* ${CONFIG.CHANNEL}
ğŸ•’ *Ø§Ù„ÙˆÙ‚Øª:* ${goalAI.getSaudiDateTime()}

ğŸ”¢ *Ø§Ù„Ø¢Ù† Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ "ğŸ” Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨" Ù„Ø¨Ø¯Ø¡ Ø§Ù„ØªØ³Ø¬ÙŠÙ„*
            `;

            await ctx.replyWithMarkdown(welcomeMessage, getLoginKeyboard());
        }

    } catch (error) {
        console.error('Start command error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù…ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù„Ø§Ø­Ù‚Ø§Ù‹');
    }
});

// ... (Ø¨Ù‚ÙŠØ© Ø§Ù„ÙƒÙˆØ¯ ÙŠØªØ¨Ø¹ Ø¨Ù†ÙØ³ Ø§Ù„Ù†Ù…Ø· Ù…Ø¹ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©)

// ğŸ†• Ù†Ø¸Ø§Ù… ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø¨Ù†Ùƒ Ø§Ù„ÙƒØ±ÙŠÙ…ÙŠ Ø§Ù„Ù…Ø­Ø³Ù†
async function handleAdminBankEdit(ctx, text) {
    try {
        const subscriptionType = ctx.session.editingSubscriptionType;
        const paymentMethod = 'bank';
        
        if (!subscriptionType) {
            await ctx.reply('âŒ Ù„Ù… ÙŠØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ù†ÙˆØ¹ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ', getAdminSettingsKeyboard());
            return;
        }

        const settings = await dbManager.getSettings();
        const currentData = settings.payment_methods[paymentMethod][subscriptionType];

        if (text === 'ğŸ”™ Ø±Ø¬ÙˆØ¹') {
            ctx.session.adminStep = 'select_subscription_edit';
            ctx.session.editingSubscriptionType = null;
            await ctx.reply('ğŸ”™ *Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ø§Ø®ØªÙŠØ§Ø± Ù†ÙˆØ¹ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ*', getAdminPaymentTypesKeyboard());
            return;
        }

        if (text === 'âœ… Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„') {
            ctx.session.adminStep = 'settings';
            ctx.session.editingSubscriptionType = null;
            await ctx.reply('âœ… *ØªÙ… Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª*', getAdminSettingsKeyboard());
            return;
        }

        if (text === 'ğŸ’µ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø³Ø¹Ø±') {
            ctx.session.bankEditStep = 'awaiting_price';
            await ctx.reply(
                `ğŸ’° *ØªØ¹Ø¯ÙŠÙ„ Ø³Ø¹Ø± Ø§Ù„Ø¨Ø§Ù‚Ø© ${subscriptionType}*\n\n` +
                `ğŸ’µ Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ: ${settings.prices[paymentMethod][subscriptionType]}$\n\n` +
                `ğŸ“ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯:`
            );
            return;
        }

        if (text === 'ğŸ¦ ØªØ¹Ø¯ÙŠÙ„ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨') {
            ctx.session.bankEditStep = 'awaiting_account';
            await ctx.reply(
                `ğŸ¦ *ØªØ¹Ø¯ÙŠÙ„ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨ Ù„Ù„Ø¨Ø§Ù‚Ø© ${subscriptionType}*\n\n` +
                `ğŸ“Š Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø­Ø§Ù„ÙŠ: ${currentData.account}\n\n` +
                `ğŸ“ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¬Ø¯ÙŠØ¯:`
            );
            return;
        }

        if (text === 'ğŸ–¼ï¸ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©') {
            ctx.session.bankEditStep = 'awaiting_image';
            await ctx.reply(
                `ğŸ–¼ï¸ *ØªØ¹Ø¯ÙŠÙ„ ØµÙˆØ±Ø© Ø§Ù„Ø¯ÙØ¹ Ù„Ù„Ø¨Ø§Ù‚Ø© ${subscriptionType}*\n\n` +
                `ğŸ“· Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©: ${currentData.image ? 'Ù…ÙˆØ¬ÙˆØ¯Ø©' : 'ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©'}\n\n` +
                `ğŸ“¸ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©:`
            );
            return;
        }

        // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø³Ø¹Ø±
        if (ctx.session.bankEditStep === 'awaiting_price') {
            const price = parseFloat(text);
            if (isNaN(price) || price <= 0) {
                await ctx.reply('âŒ Ø§Ù„Ø³Ø¹Ø± ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø±Ù‚Ù…Ù‹Ø§ Ù…ÙˆØ¬Ø¨Ø§Ù‹', getAdminBankEditKeyboard());
                return;
            }

            settings.prices[paymentMethod][subscriptionType] = price;
            await dbManager.updateSettings(settings);

            ctx.session.bankEditStep = null;
            await ctx.reply(
                `âœ… *ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø³Ø¹Ø± Ø¨Ù†Ø¬Ø§Ø­*\n\n` +
                `ğŸ’° Ø§Ù„Ø¨Ø§Ù‚Ø©: ${subscriptionType}\n` +
                `ğŸ’µ Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯: ${price}$\n\n` +
                `ğŸ”„ ØªÙ… Ø­ÙØ¸ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù…`,
                getAdminBankEditKeyboard()
            );
            return;
        }

        // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨
        if (ctx.session.bankEditStep === 'awaiting_account') {
            if (!text.trim()) {
                await ctx.reply('âŒ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø£Ù† ÙŠÙƒÙˆÙ† ÙØ§Ø±ØºØ§Ù‹', getAdminBankEditKeyboard());
                return;
            }

            settings.payment_methods[paymentMethod][subscriptionType].account = text.trim();
            await dbManager.updateSettings(settings);

            ctx.session.bankEditStep = null;
            await ctx.reply(
                `âœ… *ØªÙ… ØªØ­Ø¯ÙŠØ« Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨ Ø¨Ù†Ø¬Ø§Ø­*\n\n` +
                `ğŸ’° Ø§Ù„Ø¨Ø§Ù‚Ø©: ${subscriptionType}\n` +
                `ğŸ¦ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¬Ø¯ÙŠØ¯: ${text.trim()}\n\n` +
                `ğŸ”„ ØªÙ… Ø­ÙØ¸ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù…`,
                getAdminBankEditKeyboard()
            );
            return;
        }

        await ctx.reply('âŒ Ø£Ù…Ø± ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ', getAdminBankEditKeyboard());

    } catch (error) {
        console.error('Admin bank edit error:', error);
        await ctx.reply('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„', getAdminSettingsKeyboard());
    }
}

// ğŸ†• Ù…Ø¹Ø§Ù„Ø¬Ø© ØµÙˆØ± Ø§Ù„Ø¨Ù†Ùƒ Ø§Ù„ÙƒØ±ÙŠÙ…ÙŠ ÙÙŠ Ø§Ù„Ø¥Ø¯Ù…Ù†
bot.on('photo', async (ctx) => {
    try {
        const userId = ctx.from.id.toString();
        const session = ctx.session;
        
        // Ù…Ø¹Ø§Ù„Ø¬Ø© ØµÙˆØ± Ø§Ù„Ø¯ÙØ¹ Ù…Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
        if (session.paymentType) {
            await handlePaymentScreenshot(ctx, userId);
            return;
        }

        // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø±ÙØ¹ ØµÙˆØ±Ø© Ø§Ù„Ø¨Ù†Ùƒ Ø§Ù„ÙƒØ±ÙŠÙ…ÙŠ ÙÙŠ Ø§Ù„Ø¥Ø¯Ù…Ù†
        if (session.adminStep === 'edit_price_and_payment' && 
            session.editingPaymentMethod === 'bank' && 
            session.bankEditStep === 'awaiting_image') {
            
            await handleAdminBankImageUpload(ctx, userId);
            return;
        }

        await ctx.replyWithMarkdown(
            'âŒ *Ù„Ø§ ÙŠÙ…ÙƒÙ† Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø© Ø­Ø§Ù„ÙŠØ§Ù‹*\n\n' +
            'ğŸ’¡ ÙŠØ±Ø¬Ù‰ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù…ØªØ§Ø­Ø© ÙÙŠ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©',
            getMainKeyboard()
        );

    } catch (error) {
        console.error('Photo handler error:', error);
        await ctx.replyWithMarkdown('âŒ *Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø©*', getMainKeyboard());
    }
});

// ğŸ†• Ù…Ø¹Ø§Ù„Ø¬Ø© Ø±ÙØ¹ ØµÙˆØ±Ø© Ø§Ù„Ø¨Ù†Ùƒ Ø§Ù„ÙƒØ±ÙŠÙ…ÙŠ
async function handleAdminBankImageUpload(ctx, userId) {
    try {
        const subscriptionType = ctx.session.editingSubscriptionType;
        const paymentMethod = 'bank';
        
        if (!subscriptionType) {
            await ctx.reply('âŒ Ù„Ù… ÙŠØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ù†ÙˆØ¹ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ', getAdminSettingsKeyboard());
            return;
        }

        const photo = ctx.message.photo[ctx.message.photo.length - 1];
        const fileLink = await bot.telegram.getFileLink(photo.file_id);
        const imageUrl = fileLink.href;

        // Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø© Ø¥Ù„Ù‰ imgbb
        const uploadResult = await imgbbUploader.uploadImageFromUrl(imageUrl);
        
        if (!uploadResult.success) {
            await ctx.reply('âŒ ÙØ´Ù„ ÙÙŠ Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø©ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰', getAdminBankEditKeyboard());
            return;
        }

        const settings = await dbManager.getSettings();
        settings.payment_methods[paymentMethod][subscriptionType].image = uploadResult.url;
        await dbManager.updateSettings(settings);

        ctx.session.bankEditStep = null;

        await ctx.reply(
            `âœ… *ØªÙ… ØªØ­Ø¯ÙŠØ« ØµÙˆØ±Ø© Ø§Ù„Ø¯ÙØ¹ Ø¨Ù†Ø¬Ø§Ø­!*\n\n` +
            `ğŸ“¦ ${subscriptionType}\n` +
            `ğŸ¦ Ø§Ù„Ø¨Ù†Ùƒ Ø§Ù„ÙƒØ±ÙŠÙ…ÙŠ\n` +
            `ğŸ–¼ï¸ ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„ØµÙˆØ±Ø©\n\n` +
            `ğŸ”„ ØªÙ… Ø­ÙØ¸ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù…`,
            getAdminBankEditKeyboard()
        );

    } catch (error) {
        console.error('Admin bank image upload error:', error);
        await ctx.reply('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø©', getAdminBankEditKeyboard());
    }
}

// ğŸ†• ØªØ­Ø¯ÙŠØ« Ø¯Ø§Ù„Ø© Ø¹Ø±Ø¶ Ø¨Ø§Ù‚Ø§Øª Ø§Ù„Ø¨Ù†Ùƒ Ø§Ù„ÙƒØ±ÙŠÙ…ÙŠ
async function handleBankSubscriptionDisplay(ctx, subscriptionType, paymentMethod) {
    try {
        const settings = await dbManager.getSettings();
        const prices = settings.prices[paymentMethod];
        const paymentMethods = settings.payment_methods[paymentMethod];

        const displayName = getSubscriptionDisplayName(subscriptionType);
        const paymentInfo = paymentMethods[subscriptionType];

        const subscriptionMessage = `ğŸ’³ *Ø¨Ø§Ù‚Ø© ${displayName} - Ø§Ù„Ø¨Ù†Ùƒ Ø§Ù„ÙƒØ±ÙŠÙ…ÙŠ*\n\n` +
            `ğŸ’° Ø§Ù„Ø³Ø¹Ø±: ${prices[subscriptionType]}$\n` +
            `â° Ø§Ù„Ù…Ø¯Ø©: ${getSubscriptionDuration(subscriptionType)}\n\n` +
            `ğŸ¦ *Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¯ÙØ¹:*\n` +
            `ğŸ“Š *Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨:* \`${paymentInfo.account}\`\n\n` +
            `ğŸ“‹ *Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹:*\n` +
            `1. Ù‚Ù… Ø¨Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ Ø§Ù„Ø±Ù‚Ù… Ø£Ø¹Ù„Ø§Ù‡\n` +
            `2. Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet (10 Ø£Ø±Ù‚Ø§Ù…)\n` +
            `3. Ø£Ø±Ø³Ù„ ØµÙˆØ±Ø© Ø¥Ø«Ø¨Ø§Øª Ø§Ù„ØªØ­ÙˆÙŠÙ„\n` +
            `4. Ø§Ù†ØªØ¸Ø± Ø§Ù„ØªÙØ¹ÙŠÙ„ Ù…Ù† Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©\n\n` +
            `ğŸ•’ Ø§Ù„ÙˆÙ‚Øª: ${goalAI.getSaudiDateTime()}\n\n` +
            `ğŸ’¡ *Ù‡Ù„ ØªØ±ÙŠØ¯ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ù…Ø¹ Ù‡Ø°Ù‡ Ø§Ù„Ø¨Ø§Ù‚Ø©ØŸ*`;

        // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±Ø© Ù…Ø¹ Ø§Ù„Ù†Øµ ÙÙŠ Ø±Ø³Ø§Ù„Ø© ÙˆØ§Ø­Ø¯Ø©
        if (paymentInfo.image) {
            try {
                await ctx.replyWithPhoto(paymentInfo.image, {
                    caption: subscriptionMessage,
                    parse_mode: 'Markdown',
                    reply_markup: {
                        inline_keyboard: [
                            [ { text: 'âœ… Ù†Ø¹Ù…ØŒ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©', callback_data: `confirm_${paymentMethod}_${subscriptionType}` } ],
                            [ { text: 'ğŸ”™ Ø±Ø¬ÙˆØ¹', callback_data: 'back_to_payment_methods' } ]
                        ]
                    }
                });
            } catch (photoError) {
                console.error('Error sending bank payment image:', photoError);
                await ctx.replyWithMarkdown(subscriptionMessage, {
                    reply_markup: {
                        inline_keyboard: [
                            [ { text: 'âœ… Ù†Ø¹Ù…ØŒ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©', callback_data: `confirm_${paymentMethod}_${subscriptionType}` } ],
                            [ { text: 'ğŸ”™ Ø±Ø¬ÙˆØ¹', callback_data: 'back_to_payment_methods' } ]
                        ]
                    }
                });
            }
        } else {
            await ctx.replyWithMarkdown(subscriptionMessage, {
                reply_markup: {
                    inline_keyboard: [
                        [ { text: 'âœ… Ù†Ø¹Ù…ØŒ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©', callback_data: `confirm_${paymentMethod}_${subscriptionType}` } ],
                        [ { text: 'ğŸ”™ Ø±Ø¬ÙˆØ¹', callback_data: 'back_to_payment_methods' } ]
                    ]
                }
            });
        }

    } catch (error) {
        console.error('Bank subscription display error:', error);
        await ctx.replyWithMarkdown('âŒ *Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¹Ø±Ø¶ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¨Ø§Ù‚Ø©*', getPaymentMethodKeyboard('bank'));
    }
}

// ğŸ› ï¸ Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø©
function getSubscriptionDisplayName(subscriptionType) {
    const names = {
        'week': 'Ø£Ø³Ø¨ÙˆØ¹ÙŠ',
        'month': 'Ø´Ù‡Ø±ÙŠ',
        'three_months': '3 Ø£Ø´Ù‡Ø±',
        'year': 'Ø³Ù†ÙˆÙŠ'
    };
    return names[subscriptionType] || subscriptionType;
}

function getSubscriptionDuration(subscriptionType) {
    const durations = {
        'week': '7 Ø£ÙŠØ§Ù…',
        'month': '30 ÙŠÙˆÙ…Ø§Ù‹',
        'three_months': '90 ÙŠÙˆÙ…Ø§Ù‹',
        'year': '365 ÙŠÙˆÙ…Ø§Ù‹'
    };
    return durations[subscriptionType] || subscriptionType;
}

// ğŸš€ START BOT
bot.launch().then(() => {
    console.log('ğŸ‰ SUCCESS! AI GOAL Predictor v16.1 is RUNNING!');
    console.log('ğŸ‘¤ Developer:', CONFIG.DEVELOPER);
    console.log('ğŸ“¢ Channel:', CONFIG.CHANNEL);
    console.log('ğŸŒ Health check: http://localhost:' + PORT);
    console.log('ğŸ’¾ Storage: ENHANCED PERSISTENCE SYSTEM ACTIVE');
    console.log('ğŸ” Data Protection: DEEP STORAGE ENABLED');
    console.log('ğŸ”„ Auto Backup: ACTIVE');
    console.log('ğŸ¦ Bank System: ENHANCED ADMIN CONTROL');
}).catch(console.error);

// âš¡ Graceful shutdown with data backup
process.once('SIGINT', () => {
    console.log('ğŸ”’ Saving data before shutdown...');
    enhancedStorage.cleanup();
    bot.stop('SIGINT');
});

process.once('SIGTERM', () => {
    console.log('ğŸ”’ Saving data before shutdown...');
    enhancedStorage.cleanup();
    bot.stop('SIGTERM');
});

console.log('âœ… AI Goal Prediction System Ready with Enhanced Storage!');
